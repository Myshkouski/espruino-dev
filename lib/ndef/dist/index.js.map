{"version":3,"file":"index.js","sources":["../src/ndef-util.js","../src/ndef-text.js","../src/ndef-uri.js","../src/ndef.js"],"sourcesContent":["// ndef-util.js\n// Copyright 2013 Don Coleman\n//\n\n// This is from phonegap-nfc.js and is a combination of helpers in nfc and util\n// https://github.com/chariotsolutions/phonegap-nfc/blob/master/www/phonegap-nfc.js\n\nconst stringToBytes = string =>\n  Buffer.from(string)\n\nfunction bytesToString(bytes) {\n    return Buffer.from(bytes).toString();\n}\n\n// useful for readable version of Tag UID\nfunction bytesToHexString(bytes) {\n    var dec, hexstring, bytesAsHexString = \"\";\n    for (var i = 0; i < bytes.length; i++) {\n       if (bytes[i] >= 0) {\n           dec = bytes[i];\n       } else {\n           dec = 256 + bytes[i];\n       }\n       hexstring = dec.toString(16);\n       // zero padding\n       if (hexstring.length == 1) {\n           hexstring = \"0\" + hexstring;\n       }\n       bytesAsHexString += hexstring;\n    }\n    return bytesAsHexString;\n}\n\n// i must be <= 256\nfunction toHex(i) {\n    var hex;\n\n    if (i < 0) {\n        i += 256;\n    }\n    hex = i.toString(16);\n\n    // zero padding\n    if (hex.length == 1) {\n        hex = \"0\" + hex;\n    }\n    return hex;\n}\n\nfunction toPrintable(i) {\n    if (i >= 0x20 & i <= 0x7F) {\n        return String.fromCharCode(i);\n    } else {\n        return '.';\n    }\n}\n\nexport {\n  stringToBytes,\n  bytesToString,\n  bytesToHexString,\n  toHex,\n  toPrintable\n}\n","import {\n  bytesToString,\n  stringToBytes\n} from './ndef-util'\n\n/**\n  * decode text bytes from ndef record payload\n  *\n  * @returns a string\n  */\nexport const decode = data => {\n  var languageCodeLength = (data[0] & 0x3F), // 6 LSBs\n      languageCode = data.slice(1, 1 + languageCodeLength),\n      utf16 = (data[0] & 0x80) !== 0 // assuming UTF-16BE\n\n  // TODO need to deal with UTF in the future\n  // console.log(\"lang \" + languageCode + (utf16 ? \" utf16\" : \" utf8\"))\n\n  return bytesToString(data.slice(languageCodeLength + 1))\n}\n\n/**\n  * Encode text payload\n  *\n  * @returns an array of bytes\n  */\nexport const encode = (text, lang, encoding) => {\n    // ISO/IANA language code, but we're not enforcing\n    if (!lang) { lang = 'en' }\n\n    var encoded = stringToBytes(lang.length + lang + text)\n\n    return encoded\n}\n","import {\n  bytesToString,\n  stringToBytes\n} from './ndef-util'\n\n// URI identifier codes from URI Record Type Definition NFCForum-TS-RTD_URI_1.0 2006-07-24\n// index in array matches code in the spec\nconst protocols = [ \"\", \"http://www.\", \"https://www.\", \"http://\", \"https://\", \"tel:\", \"mailto:\", \"ftp://anonymous:anonymous@\", \"ftp://ftp.\", \"ftps://\", \"sftp://\", \"smb://\", \"nfs://\", \"ftp://\", \"dav://\", \"news:\", \"telnet://\", \"imap:\", \"rtsp://\", \"urn:\", \"pop:\", \"sip:\", \"sips:\", \"tftp:\", \"btspp://\", \"btl2cap://\", \"btgoep://\", \"tcpobex://\", \"irdaobex://\", \"file://\", \"urn:epc:id:\", \"urn:epc:tag:\", \"urn:epc:pat:\", \"urn:epc:raw:\", \"urn:epc:\", \"urn:nfc:\" ]\n\n/**\n  * @returns a string\n  */\nexport const decode = data => {\n    var prefix = protocols[data[0]]\n    if (!prefix) { // 36 to 255 should be \"\"\n        prefix = \"\"\n    }\n    return prefix + bytesToString(data.slice(1))\n}\n\n/**\n  * shorten a URI with standard prefix\n  *\n  * @returns an array of bytes\n  */\nexport const encode = uri => {\n    var prefix,\n        protocolCode,\n        encoded\n\n    // check each protocol, unless we've found a match\n    // \"urn:\" is the one exception where we need to keep checking\n    // slice so we don't check \"\"\n    protocols.slice(1).forEach(protocol => {\n      if ((!prefix || prefix === \"urn:\") && uri.indexOf(protocol) === 0) {\n        prefix = protocol\n      }\n    })\n\n    if (!prefix) {\n        prefix = \"\"\n    }\n\n    encoded = stringToBytes(uri.slice(prefix.length))\n    protocolCode = protocols.indexOf(prefix)\n    // prepend protocol code\n    encoded.unshift(protocolCode)\n\n    return encoded\n}\n","// ndef.js\n// Copyright 2013 Don Coleman\n//\n// This code is from phonegap-nfc.js https://github.com/don/phonegap-nfc\n\n// see android.nfc.NdefRecord for documentation about constants\n// http://developer.android.com/reference/android/nfc/NdefRecord.html\n\nimport CONSTANTS from './constants.yaml'\n\nimport {\n  bytesToString,\n  stringToBytes\n} from './ndef-util'\n\nimport {\n  encode as encodeTextPayload,\n  decode as decodeTextPayload\n} from './ndef-text'\n\nimport {\n  encode as encodeUriPayload,\n  decode as decodeUriPayload\n} from './ndef-uri'\n\n/**\n * Creates a JSON representation of a NDEF Record.\n *\n * @tnf 3-bit TNF (Type Name Format) - use one of the CONSTANTS.TNF_* constants\n * @type byte array, containing zero to 255 bytes, must not be null\n * @id byte array, containing zero to 255 bytes, must not be null\n * @payload byte array, containing zero to (2 ** 32 - 1) bytes, must not be null\n *\n * @returns JSON representation of a NDEF record\n *\n * @see Ndef.textRecord, Ndef.uriRecord and Ndef.mimeMediaRecord for examples\n */\n\n// convert bytes to a String\nconst s = bytes =>\n  Buffer.from(bytes).toString()\n\nexport const record = (tnf = CONSTANTS.TNF_EMPTY, type = [], id = [], payload = [], value) => {\n  // store type as String so it's easier to compare\n  if(type instanceof Array) {\n    type = bytesToString(type)\n  }\n\n  // in the future, id could be a String\n  if (!(id instanceof Array)) {\n    id = stringToBytes(id)\n  }\n\n  // Payload must be binary\n  if (!(payload instanceof Array)) {\n    payload = stringToBytes(payload)\n  }\n\n  // Experimental feature\n  // Convert payload to text for Text and URI records\n  if (tnf == CONSTANTS.TNF_WELL_KNOWN) {\n    if(type == CONSTANTS.RTD_TEXT) {\n      value = decodeTextPayload(payload)\n    }\n    else if(type == RTD_URI) {\n      value = decodeUriPayload(payload)\n    }\n  }\n\n  return {\n    tnf,\n    type,\n    id,\n    payload,\n    value\n  }\n}\n\n/**\n * Helper that creates an NDEF record containing plain text.\n *\n * @text String of text to encode\n * @languageCode ISO/IANA language code. Examples: “fi”, “en-US”, “fr-CA”, “jp”. (optional)\n * @id byte[] (optional)\n */\nexport const textRecord = (text, languageCode, id = []) => {\n  console.log(CONSTANTS.TNF_WELL_KNOWN, RTD_TEXT, id, encodeTextPayload(text, languageCode))\n  record(CONSTANTS.TNF_WELL_KNOWN, RTD_TEXT, id, encodeTextPayload(text, languageCode))\n}\n/**\n * Helper that creates a NDEF record containing a URI.\n *\n * @uri String\n * @id byte[] (optional)\n */\nexport const uriRecord = (uri, id = []) =>\n  record(CONSTANTS.TNF_WELL_KNOWN, RTD_URI, id, encodeUriPayload(uri))\n\n/**\n * Helper that creates a NDEF record containing an absolute URI.\n *\n * An Absolute URI record means the URI describes the payload of the record.\n *\n * For example a SOAP message could use \"http://schemas.xmlsoap.org/soap/envelope/\"\n * as the type and XML content for the payload.\n *\n * Absolute URI can also be used to write LaunchApp records for Windows.\n *\n * See 2.4.2 Payload Type of the NDEF Specification\n * http://www.nfc-forum.org/specs/spec_list#ndefts\n *\n * Note that by default, Android will open the URI defined in the type\n * field of an Absolute URI record (TNF=3) and ignore the payload.\n * BlackBerry and Windows do not open the browser for TNF=3.\n *\n * To write a URI as the payload use ndef.uriRecord(uri)\n *\n * @uri String\n * @payload byte[] or String\n * @id byte[] (optional)\n */\nexport const absoluteUriRecord = (uri, payload = [], id = []) =>\n  record(CONSTANTS.TNF_ABSOLUTE_URI, uri, id, payload)\n\n/**\n* Helper that creates a NDEF record containing an mimeMediaRecord.\n*\n* @mimeType String\n* @payload byte[]\n* @id byte[] (optional)\n*/\nexport const mimeMediaRecord = (mimeType, payload = [], id = []) =>\n  record(CONSTANTS.TNF_MIME_MEDIA, mimeType, id, payload)\n\n/**\n* Helper that creates an NDEF record containing an Smart Poster.\n*\n* @ndefRecords array of NDEF Records\n* @id byte[] (optional)\n*/\nexport const smartPoster = (ndefRecords, id, payload) => {\n  payload = []\n\n  if (ndefRecords) {\n    // make sure we have an array of something like NDEF records before encoding\n    if (ndefRecords[0] instanceof Object && ndefRecords[0].hasOwnProperty('tnf')) {\n      payload = encodeMessage(ndefRecords)\n    } else {\n      // assume the caller has already encoded the NDEF records into a byte array\n      payload = ndefRecords\n    }\n  } else {\n    console.warn(\"WARNING: Expecting an array of NDEF records\")\n  }\n\n  return record(CONSTANTS.TNF_WELL_KNOWN, RTD_SMART_POSTER, id, payload)\n}\n\n/**\n* Helper that creates an empty NDEF record.\n*\n*/\nexport const emptyRecord = () =>\n  record(CONSTANTS.TNF_EMPTY, [], [], [])\n\n/**\n* Helper that creates an Android Application Record (AAR).\n* http://developer.android.com/guide/topics/connectivity/nfc/nfc.html#aar\n*\n*/\nexport const androidApplicationRecord = packageName =>\n  record(CONSTANTS.TNF_EXTERNAL_TYPE, 'android.com:pkg', [], packageName)\n\n/**\n* Encodes an NDEF Message into bytes that can be written to a NFC tag.\n*\n* @ndefRecords an Array of NDEF Records\n*\n* @returns byte array\n*\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\n*/\nexport const encodeMessage = ndefRecords => {\n  let encoded = [],\n      tnf_byte,\n      record_type,\n      payload_length,\n      id_length,\n      i,\n      mb, me, // messageBegin, messageEnd\n      cf = false, // chunkFlag TODO implement\n      sr, // boolean shortRecord\n      il // boolean idLengthFieldIsPresent\n\n  for (i = 0; i < ndefRecords.length; i++) {\n    mb = (i === 0)\n    me = (i === (ndefRecords.length - 1))\n    sr = (ndefRecords[i].payload.length < 0xFF)\n    il = (ndefRecords[i].id.length > 0)\n    tnf_byte = encodeTnf(mb, me, cf, sr, il, ndefRecords[i].tnf)\n    encoded.push(tnf_byte)\n\n    // type is stored as String, converting to bytes for storage\n    record_type = stringToBytes(ndefRecords[i].type)\n    encoded.push(record_type.length)\n\n    if (sr) {\n      payload_length = ndefRecords[i].payload.length\n      encoded.push(payload_length)\n    } else {\n      payload_length = ndefRecords[i].payload.length\n      // 4 bytes\n      encoded.push((payload_length >> 24))\n      encoded.push((payload_length >> 16))\n      encoded.push((payload_length >> 8))\n      encoded.push((payload_length & 0xFF))\n    }\n\n    if (il) {\n      id_length = ndefRecords[i].id.length\n      encoded.push(id_length)\n    }\n\n    encoded = encoded.concat(record_type)\n\n    if (il) {\n      encoded = encoded.concat(ndefRecords[i].id)\n    }\n\n    encoded = encoded.concat(ndefRecords[i].payload)\n  }\n\n  return encoded\n}\n\n/**\n* Decodes an array bytes into an NDEF Message\n*\n* @bytes an array bytes read from a NFC tag\n*\n* @returns array of NDEF Records\n*\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\n*/\nexport const decodeMessage = _bytes => {\n  let bytes = _bytes.slice(0), // clone since parsing is destructive\n      ndef_message = [],\n      tnf_byte,\n      header,\n      type_length = 0,\n      payload_length = 0,\n      id_length = 0,\n      record_type = [],\n      id = [],\n      payload = []\n\n  while(bytes.length) {\n    tnf_byte = bytes.shift()\n    header = decodeTnf(tnf_byte)\n\n    type_length = bytes.shift()\n\n    if (header.sr) {\n      payload_length = bytes.shift()\n    } else {\n      // next 4 bytes are length\n      payload_length = ((0xFF & bytes.shift()) << 24) |\n        ((0xFF & bytes.shift()) << 16) |\n        ((0xFF & bytes.shift()) << 8) |\n        (0xFF & bytes.shift())\n    }\n\n    if (header.il) {\n      id_length = bytes.shift()\n    }\n\n    record_type = bytes.splice(0, type_length)\n    id = bytes.splice(0, id_length)\n    payload = bytes.splice(0, payload_length)\n\n    ndef_message.push(\n      record(header.tnf, record_type, id, payload)\n    )\n\n    if (header.me) break // last message\n  }\n\n  return ndef_message\n}\n\n/**\n* Decode the bit flags from a TNF Byte.\n*\n* @returns object with decoded data\n*\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\n*/\nexport const decodeTnf = tnf_byte => {\n  return {\n    mb: (tnf_byte & 0x80) !== 0,\n    me: (tnf_byte & 0x40) !== 0,\n    cf: (tnf_byte & 0x20) !== 0,\n    sr: (tnf_byte & 0x10) !== 0,\n    il: (tnf_byte & 0x8) !== 0,\n    tnf: (tnf_byte & 0x7)\n  }\n}\n\n/**\n* Encode NDEF bit flags into a TNF Byte.\n*\n* @returns tnf byte\n*\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\n*/\nexport const encodeTnf = (mb, me, cf, sr, il, tnf, value = tnf) => {\n  if (mb) {\n    value = value | 0x80\n  }\n\n  if (me) {\n    value = value | 0x40\n  }\n\n  // note if cf: me, mb, li must be false and tnf must be 0x6\n  if (cf) {\n    value = value | 0x20\n  }\n\n  if (sr) {\n    value = value | 0x10\n  }\n\n  if (il) {\n    value = value | 0x8\n  }\n\n  return value\n}\n\n// TODO test with byte[] and string\nexport const isType = (record, tnf, type) =>\n  record.tnf === tnf\n    ? s(record) === s(type)\n    : false\n\nexport const tnfToString = (tnf, value = tnf) => {\n  if(tnf == CONSTANTS.TNF_EMPTY) {\n    value = \"Empty\"\n  }\n  else if(CONSTANTS.TNF_WELL_KNOWN) {\n    value = \"Well Known\"\n  }\n  else if(CONSTANTS.TNF_MIME_MEDIA) {\n    value = \"Mime Media\"\n  }\n  else if(CONSTANTS.TNF_ABSOLUTE_URI) {\n    value = \"Absolute URI\"\n  }\n  else if(CONSTANTS.TNF_EXTERNAL_TYPE) {\n    value = \"External\"\n  }\n  else if(CONSTANTS.TNF_UNKNOWN) {\n    value = \"Unknown\"\n  }\n  else if(CONSTANTS.TNF_UNCHANGED) {\n    value = \"Unchanged\"\n  }\n  else if(CONSTANTS.TNF_RESERVED) {\n    value = \"Reserved\"\n  }\n  return value\n}\n\n// Convert NDEF records and messages to strings\n// This works OK for demos, but real code proably needs\n// a custom implementation. It would be nice to make\n// smarter record objects that can print themselves\nvar stringifier = {\n    stringify: function (data, separator) {\n      if (data instanceof Array) {\n        if (typeof data[0] === 'number') {\n          // guessing this message bytes\n          data = decodeMessage(data)\n        }\n\n        return stringifier.printRecords(data, separator)\n      } else {\n        return stringifier.printRecord(data, separator)\n      }\n    },\n\n    // @message - NDEF Message (array of NDEF Records)\n    // @separator - line separator, optional, defaults to \\n\n    // @returns string with NDEF Message\n    printRecords: function (message, separator) {\n\n        if(!separator) { separator = \"\\n\" }\n        result = \"\"\n\n        // Print out the payload for each record\n        message.forEach(function(record) {\n            result += stringifier.printRecord(record, separator)\n            result += separator\n        })\n\n        return result.slice(0, (-1 * separator.length))\n    },\n\n    // @record - NDEF Record\n    // @separator - line separator, optional, defaults to \\n\n    // @returns string with NDEF Record\n    printRecord: function (record, separator) {\n\n        var result = \"\"\n\n        if(!separator) { separator = \"\\n\" }\n\n        switch(record.tnf) {\n            case ndef.CONSTANTS.TNF_EMPTY:\n                result += \"Empty Record\"\n                result += separator\n                break\n            case ndef.CONSTANTS.TNF_WELL_KNOWN:\n                result += stringifier.printWellKnown(record, separator)\n                break\n            case ndef.CONSTANTS.TNF_MIME_MEDIA:\n                result += \"MIME Media\"\n                result += separator\n                result += s(record.type)\n                result += separator\n                result += s(record.payload) // might be binary\n                break\n            case ndef.CONSTANTS.TNF_ABSOLUTE_URI:\n                result += \"Absolute URI\"\n                result += separator\n                result += s(record.type)    // the URI is the type\n                result += separator\n                result += s(record.payload) // might be binary\n                break\n            case ndef.CONSTANTS.TNF_EXTERNAL_TYPE:\n                // AAR contains strings, other types could\n                // contain binary data\n                result += \"External\"\n                result += separator\n                result += s(record.type)\n                result += separator\n                result += s(record.payload)\n                break\n            default:\n                result += s(\"Can't process TNF \" + record.tnf)\n        }\n\n        result += separator\n        return result\n    },\n\n    printWellKnown: function (record, separator) {\n\n        var result = \"\"\n\n        if (record.tnf !== ndef.CONSTANTS.TNF_WELL_KNOWN) {\n            return \"ERROR expecting TNF Well Known\"\n        }\n\n        switch(record.type) {\n            case ndef.RTD_TEXT:\n                result += \"Text Record\"\n                result += separator\n                result += (ndef.text.decodePayload(record.payload))\n                break\n            case ndef.RTD_URI:\n                result += \"URI Record\"\n                result += separator\n                result += (ndef.uri.decodePayload(record.payload))\n                break\n            case ndef.RTD_SMART_POSTER:\n                result += \"Smart Poster\"\n                result += separator\n                // the payload of a smartposter is a NDEF message\n                result += stringifier.printRecords(ndef.decodeMessage(record.payload))\n                break\n            default:\n                // attempt to display other types\n                result += record.type + \" Record\"\n                result += separator\n                result += s(record.payload)\n        }\n\n        return result\n    }\n}\n\nexport const stringify = stringifier.stringify\n"],"names":["stringToBytes","Buffer","from","string","bytesToString","bytes","toString","decode","languageCodeLength","data","slice","encode","text","lang","encoding","encoded","length","protocols","prefix","protocolCode","forEach","uri","indexOf","protocol","unshift","s","record","tnf","CONSTANTS","TNF_EMPTY","type","id","payload","value","Array","TNF_WELL_KNOWN","RTD_TEXT","decodeTextPayload","RTD_URI","decodeUriPayload","textRecord","languageCode","log","encodeTextPayload","uriRecord","encodeUriPayload","absoluteUriRecord","TNF_ABSOLUTE_URI","mimeMediaRecord","mimeType","TNF_MIME_MEDIA","smartPoster","ndefRecords","Object","hasOwnProperty","encodeMessage","warn","RTD_SMART_POSTER","emptyRecord","androidApplicationRecord","TNF_EXTERNAL_TYPE","packageName","tnf_byte","record_type","payload_length","id_length","i","mb","me","encodeTnf","cf","sr","il","push","concat","decodeMessage","_bytes","header","type_length","shift","decodeTnf","splice","ndef_message","isType","tnfToString","TNF_UNKNOWN","TNF_UNCHANGED","TNF_RESERVED","stringifier","separator","printRecords","printRecord","message","result","ndef","printWellKnown","decodePayload","stringify"],"mappings":"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"}