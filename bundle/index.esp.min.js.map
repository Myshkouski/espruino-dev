{"version":3,"file":"index.esp.min.js","sources":["../lib/events.js","../lib/schedule.js","../helpers/series.js","../lib/bus/index.js","../lib/blink.js","../globals/buffer/index.js","../globals/console.js","../globals/object.js","../globals/extend/index.js","../globals/array.js","../globals/promise.js","../globals/event-loop.js","../lib/nfc/index.js","../node_modules/esp-ndef/dist/index.esm.js","../src/index.js"],"sourcesContent":["function EventEmitter() {\r\n  this._listeners = {}\r\n}\r\n\r\n_named('EventEmitter', EventEmitter)\r\n\r\nfunction _duplicateEvent(event) {\r\n  if(event) {\r\n    if(`#${ event }` in this) {\r\n      this._listeners[event] = this[`#${ event }`]\r\n    } else {\r\n      delete this._listeners[event]\r\n    }\r\n  }\r\n}\r\n\r\nEventEmitter.prototype = {\r\n  on(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n\r\n    // this._listeners[event]\r\n    //   ? this._listeners[event].push(listener)\r\n    //   : this._listeners[event] = [listener]\r\n\r\n    return this\r\n  },\r\n\r\n  removeListener(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n    // if(!event) {\r\n    //   this._listeners = {}\r\n    // } else {\r\n    //   if(listener && this._listeners[event]) {\r\n    //     const index = this._listeners[event].indexOf(listener)\r\n    //\r\n    //     if(~index) {\r\n    //       this._listeners[event].splice(index, 1)\r\n    //     }\r\n    //   }\r\n    //\r\n    //   if(!listener || !this._listeners[event]) {\r\n    //     delete this._listeners[event]\r\n    //   }\r\n    // }\r\n    return this\r\n  },\r\n\r\n  once(event, listener) {\r\n    function once() {\r\n      this.removeListener(event, _listener)\r\n      return listener.apply(this, arguments)\r\n    }\r\n\r\n    return this.on(event, once)\r\n  }\r\n}\r\n\r\nexport default EventEmitter\r\n","import EventEmitter from 'events'\r\n\r\nfunction Schedule() {\r\n  this.pending = Promise.resolve(null)\r\n}\r\n\r\nSchedule.prototype = {\r\n  immediate(task) {\r\n    this.pending = Promise.all([\r\n      this.pending,\r\n      new Promise((done, fail) => {\r\n        task(done, fail)\r\n      }).catch(err => this.emit('error', err))\r\n    ])\r\n\r\n    return this\r\n  },\r\n\r\n  deferred(task) {\r\n    this.pending = this.pending\r\n      .then(r => new Promise((done, fail) => {\r\n        task(done, fail)\r\n      }))\r\n      .catch(err => this.emit('error', err))\r\n\r\n    return this\r\n  }\r\n}\r\n\r\nexport default Schedule\r\n","export default function series(arr, cb, done) {\r\n  let i = 0\r\n  ;(function next(res) {\r\n    if (res !== undefined || i >= arr.length) {\r\n      done && done(res)\r\n    }\r\n    else {\r\n      setImmediate(() => cb(next, arr[i], i++, arr))\r\n    }\r\n  })()\r\n}\r\n","// import { Writable } from 'stream'\r\nimport Schedule from 'schedule'\r\nimport series from 'series'\r\n\r\nfunction _parse(chunk, encoding, cb) {\r\n  const { incoming, watching, frame } = this._busState\r\n\r\n  let currentChunkIndex = 0,\r\n      currentIncomingWatcherIndex = 0,\r\n      incomingIndex = 0,\r\n      isEqual = false,\r\n      isChunkCorrupted = false\r\n\r\n  if(!watching.length) {\r\n    this.emit('error', new Error({\r\n      msg: 'Unexpected incoming data',\r\n      data: chunk\r\n    }))\r\n  }\r\n  else {\r\n    for(;currentChunkIndex < chunk.length; currentChunkIndex ++) {\r\n      frame.push(chunk[currentChunkIndex])\r\n\r\n      if(!incoming.length) {\r\n        for(let watchingIndex in watching) {\r\n          try {\r\n            incoming.push({\r\n              patterns: watching[watchingIndex].patterns,\r\n              callback: watching[watchingIndex].callback,\r\n              currentPattern: watching[watchingIndex].patterns[0] instanceof Function ? watching[watchingIndex].patterns[0]([]) : watching[watchingIndex].patterns[0],\r\n              arrayOffset: 0,\r\n              patternIndex: 0,\r\n              byteIndex: 0,\r\n              length: 0\r\n            })\r\n          } catch(err) {\r\n            this.emit('error', err)\r\n          }\r\n        }\r\n      }\r\n\r\n      for(incomingIndex = 0; incomingIndex < incoming.length;) {\r\n        const incomingI = incoming[incomingIndex],\r\n              expected = incomingI.currentPattern[incomingI.byteIndex]\r\n\r\n        if(expected === undefined || expected === chunk[currentChunkIndex]) {\r\n          isEqual = true\r\n\r\n          incomingI.byteIndex ++\r\n        }\r\n        else if(expected instanceof Array) {\r\n          isEqual = true\r\n\r\n          if(incomingI.arrayOffset <= 0 && expected[0] > 0) {\r\n            incomingI.arrayOffset = expected[0]\r\n          }\r\n\r\n          if(--incomingI.arrayOffset > 0) {\r\n            continue\r\n          }\r\n          else {\r\n            incomingI.byteIndex ++\r\n          }\r\n        }\r\n        else if(expected instanceof Function) {\r\n          try {\r\n            isEqual = !!expected.call(this, chunk[currentChunkIndex], incomingI.length, frame.slice(-incomingI.length - 1))\r\n            incomingI.byteIndex ++\r\n          } catch(err) {\r\n            this.emit('error', err)\r\n            isEqual = false\r\n          }\r\n        }\r\n        else {\r\n          isEqual = false\r\n        }\r\n\r\n        if(isEqual) {\r\n          incomingI.length ++\r\n\r\n          if(incomingI.byteIndex >= incomingI.currentPattern.length) {\r\n            if(++ incomingI.patternIndex >= incomingI.patterns.length) {\r\n              try {\r\n                incomingI.callback.call(\r\n                  this,\r\n                  frame.splice(-incomingI.length),\r\n                  incomingI.pattern\r\n                )\r\n              } catch(err) {\r\n                this.emit('error', err)\r\n              }\r\n\r\n              incoming.splice(0)\r\n              //break\r\n            }\r\n            else {\r\n              const nextPattern = incomingI.patterns[incomingI.patternIndex]\r\n              incomingI.byteIndex = 0\r\n              try {\r\n                if(nextPattern instanceof Function) {\r\n                  incomingI.currentPattern = nextPattern(frame.slice(-incomingI.length))\r\n                }\r\n                else {\r\n                  incomingI.currentPattern = nextPattern\r\n                }\r\n                incomingIndex ++\r\n              } catch(err) {\r\n                this.emit('error', err)\r\n                incoming.splice(incomingIndex, 1)\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            incomingIndex ++\r\n          }\r\n        }\r\n        else {\r\n          incoming.splice(incomingIndex, 1)\r\n        }\r\n      }\r\n\r\n      if(!incoming.length && frame.length) {\r\n        this.emit('error', {\r\n          msg: 'Unparsed chunk',\r\n          data: frame.splice(0)\r\n        })\r\n        /*\r\n        if(!isChunkCorrupted) {\r\n          isChunkCorrupted = true\r\n          setImmediate(() => {\r\n            isChunkCorrupted = false\r\n            this.emit('error', {\r\n              msg: 'Unparsed chunk',\r\n              data: frame.splice(0)\r\n            })\r\n          })\r\n        }*/\r\n      }\r\n    }\r\n  }\r\n\r\n  cb()\r\n}\r\n\r\nfunction _write(chunk, encoding, cb) {\r\n  const highWaterMark = this.options.highWaterMark\r\n\r\n  if(chunk.length > highWaterMark) {\r\n    const chunks = []\r\n    let subchunkIndex = 0\r\n\r\n    for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\r\n      const subchunk = chunk.slice(offset, offset += highWaterMark)\r\n      chunks.push(next => _parse.call(this, subchunk, encoding, next))\r\n    }\r\n\r\n    series(chunks, cb)\r\n  }\r\n  else {\r\n    _parse.apply(this, arguments)\r\n  }\r\n}\r\n\r\nfunction _Bus(options = {}) {\r\n  Writable.call(this, Object.assign({}, options, {\r\n    write: _write\r\n  }))\r\n\r\n  this._setup = options.setup.bind(this)\r\n\r\n  this._busState = {\r\n    watching: [],\r\n    incoming: [],\r\n    frame: [],\r\n    configured: false\r\n  }\r\n}\r\n\r\n_Bus.prototype = {\r\n  setup (...args) {\r\n    return this.deferred(slots => {\r\n      if(this._busState.configured)\r\n        return Promise.reject('already configured')\r\n\r\n      this._busState.configured = true\r\n      return this._setup(slots, ...args)\r\n    })\r\n  },\r\n\r\n  watch (patterns, callback) {\r\n    const watcher = {\r\n      patterns,\r\n      callback\r\n    }\r\n\r\n    this._busState.watching.push(watcher)\r\n\r\n    return watcher\r\n  },\r\n\r\n  unwatch (watcher) {\r\n    if(watcher) {\r\n      const index = this._busState.watching.indexOf(watcher)\r\n\r\n      if(index >= 0)\r\n        this._busState.watching.splice(index, 1)\r\n    } else {\r\n      this._busState.watching.splice(0)\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  /**\r\n    * @TODO - Proper unwatch(): delete all previously RXed watchers\r\n    */\r\n  rx(patterns, cb) {\r\n    const watcher = this.watch(patterns, frame => {\r\n      //this.unwatch(watcher)\r\n      const index = this._busState.watching.indexOf(watcher)\r\n\r\n      if(index >= 0)\r\n        this._busState.watching.splice(0, index + 1)\r\n\r\n      cb(frame)\r\n    })\r\n\r\n    return this\r\n  },\r\n\r\n  tx(binary, options = {}) {\r\n    return this.deferred(() => {\r\n      console.log('tx')\r\n      if('timeout' in options) {\r\n        return new Promise((done, fail) => {\r\n          setTimeout(() => {\r\n            this.write(binary)\r\n            done()\r\n          }, options.timeout)\r\n        })\r\n      }\r\n\r\n      this.write(binary)\r\n\r\n      return Promise.resolve()\r\n    })\r\n  },\r\n\r\n  reset () {\r\n    this._busState.frame.splice(0)\r\n    this._busState.incoming.splice(0)\r\n    return this\r\n  }\r\n}\r\n\r\nconst Bus = _extend({\r\n  name: 'Bus',\r\n  super: [Writable, Schedule, _Bus],\r\n  apply: [_Bus, Schedule]\r\n})\r\n\r\nexport default Bus\r\n","let status = false\r\nconst defaultInterval = 20\r\n\r\nfunction blink(mode) {\r\n  if(mode === undefined)\r\n    mode = !status\r\n\r\n  !mode\r\n    ? blink.stop()\r\n    : blink.start()\r\n\r\n  return !!status\r\n}\r\n\r\nblink.start = () => {\r\n  if(!status) {\r\n    status = true\r\n\r\n    blink.once(LED2, 20, function cb() {\r\n      if(status) {\r\n        setTimeout(() => blink.once(LED2, 20, cb), 980)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nblink.stop = () => {\r\n  if(status) {\r\n    status = false\r\n  }\r\n}\r\n\r\nblink.once = (led, on = 20, cb) => {\r\n  led.write(true)\r\n  setTimeout(() => {\r\n    led.write(false)\r\n    cb && cb()\r\n  }, on)\r\n}\r\n\r\nexport default blink\r\n","import Proto from './proto'\r\nimport { toBuffer } from './utils/to'\r\n\r\nfunction copy(target) {\r\n\tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\r\n\t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\r\n\t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\r\n\r\n\tlet copied = 0\r\n\r\n\tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\r\n\t\ttarget.set([ this[sourceIndex] ], targetIndex)\r\n\r\n\treturn copied\r\n}\r\n\r\nfunction Buffer() {\r\n\tthrow new Error('Buffer constructor is deprecated. Use Buffer.from() instead.')\r\n}\r\n\r\nBuffer.from = function _createBuffer() {\r\n\t//console.log(arguments)\r\n\tlet iterable = []\r\n\tif(typeof arguments[0] === 'string') {\r\n    for(let c in arguments[0])\r\n  \t\titerable[c] = arguments[0].charCodeAt(c)\r\n\r\n  \titerable = new Proto(iterable)\r\n  }\r\n\r\n  else if(arguments[0] instanceof Proto || arguments[0] instanceof Array)\r\n\t\titerable = new Proto(arguments[0])\r\n\r\n\tconst offset = arguments[1] !== undefined ? arguments[1] : 0,\r\n\t\tlength = arguments[2] !== undefined ? arguments[2] : iterable.length\r\n\r\n\tconst array = []\r\n\r\n\tfor(let i = offset;i--;)\r\n\t\tarray[i] = 0\r\n\r\n\tfor(let i = 0; (i < iterable.length) && (i < length); i++)\r\n\t\tarray[offset + i] = iterable[i]\r\n\r\n\tfor(let i = array.length; i < length; i++)\r\n\t\tarray[i] = 0\r\n\r\n\tconst buffer = new Proto(array)\r\n\r\n\treturn buffer\r\n}\r\n\r\nBuffer.concat = function concat() {\r\n\tconst list = arguments[0] || [],\r\n\t\t\t\ttotalLength = arguments[1] !== undefined ? arguments[1] : list.reduce((totalLength, array) => (totalLength + array.length), 0),\r\n\t\t\t\tbuffer = Buffer.from([], 0, totalLength)\r\n\r\n\tlet offset = 0\r\n\r\n\tlist.forEach(buf => {\r\n\t\tbuffer.set(buf, offset)\r\n\t\toffset += buf.length\r\n\t})\r\n\r\n\treturn buffer\r\n}\r\n\r\nexport default Buffer\r\n","const timers = {}\r\n\r\nfunction time(label) {\r\n  timers[label] = Date.now()\r\n}\r\n\r\nfunction timeEnd(label) {\r\n  if(label in timers) {\r\n    console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\r\n    delete timers[label]\r\n  }\r\n}\r\n\r\nif(typeof console.time !== 'function') {\r\n  console.time = time\r\n  console.timeEnd = timeEnd\r\n}\r\n\r\nif(typeof console.error !== 'function') {\r\n  console.error = console.log\r\n}\r\n\r\nexport default console\r\n","Object.assign = (target, ...args) => {\r\n  for(let i in args) {\r\n    const obj = args[i]\r\n    if(obj instanceof Object) {\r\n      for(let key in obj) {\r\n        target[key] = obj[key]\r\n      }\r\n    }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\nexport default Object\r\n","import {\r\n  SUPER_CHAIN_PROTO_PROP,\r\n  SUPER_CHAIN_APPLY_PROP,\r\n  PROTOTYPE_IS_EXTENDED_PROP\r\n} from './props'\r\n\r\nconst _copyChain = (Extended, ProtoChain, chainPropName, ignoreExtended) => {\r\n  //if chain on [Extended] has not been created yet\r\n  if(!Extended.prototype[chainPropName]) {\r\n    Object.defineProperty(Extended.prototype, chainPropName, { value: [] })\r\n  }\r\n\r\n  ProtoChain.forEach(Proto => {\r\n    //console.log(!!Proto.prototype['__extended__'], Proto)\r\n    //if [Proto] has been '__extended__' and has same-named proto chain, copy the Proto chain to Extended chain\r\n    const isExtended = !!Proto.prototype[PROTOTYPE_IS_EXTENDED_PROP],\r\n          hasSameChain = !!Proto.prototype[chainPropName]\r\n\r\n    const alreadyInChain = Extended.prototype[chainPropName].some(P => P === Proto),\r\n          shouldBePushed = (!isExtended || !ignoreExtended) && !alreadyInChain,\r\n          shouldCopyChain = isExtended && hasSameChain\r\n\r\n    if(shouldCopyChain)\r\n      Proto.prototype[chainPropName].forEach(Proto => {\r\n        //avoid pushing twice\r\n        if(!Extended.prototype[chainPropName].some(P => P === Proto) ) {\r\n          //console.log('pushed', Proto)\r\n          Extended.prototype[chainPropName].push(Proto)\r\n        }\r\n      })\r\n\r\n    if(shouldBePushed) {\r\n      Extended.prototype[chainPropName].push(Proto)\r\n    }\r\n  })\r\n\r\n  //console.log(Extended.prototype[chainPropName])\r\n}\r\n\r\nconst _extend = (options = {}) => {\r\n  if(!options.apply)\r\n    options.apply = []\r\n  if(!options.super)\r\n    options.super = []\r\n  if(!options.static)\r\n    options.static = []\r\n\r\n  const Child = options.super[0]\r\n\r\n  if(!options.name)\r\n    options.name = Child.name\r\n\r\n  function Extended() {\r\n    Extended.prototype[SUPER_CHAIN_APPLY_PROP].forEach(Super => {\r\n      if(Super !== Extended) {\r\n        Super.apply(this, arguments)\r\n      }\r\n    })\r\n  }\r\n\r\n  _named(options.name, Extended)\r\n\r\n  for(let i in options.static) {\r\n    for(let prop in options.static[i]) {\r\n      if('prototype' != prop) {\r\n        defProp(Extended, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  Object.defineProperty(Extended, 'prototype', { value: {} })\r\n  Object.defineProperty(Extended.prototype, 'constructor', { value: Child })\r\n  Object.defineProperty(Extended.prototype, PROTOTYPE_IS_EXTENDED_PROP, { value: true })\r\n\r\n  for(let i in options.super) {\r\n    function Proto() {}\r\n    Proto.prototype = options.super[i].prototype\r\n    const proto = new Proto()\r\n\r\n    for(let prop in proto) {\r\n      if(['constructor', PROTOTYPE_IS_EXTENDED_PROP, SUPER_CHAIN_PROTO_PROP, SUPER_CHAIN_APPLY_PROP].indexOf(prop) < 0) {\r\n        defProp(Extended.prototype, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  _copyChain(Extended, options.super, SUPER_CHAIN_PROTO_PROP, false)\r\n  _copyChain(Extended, options.apply, SUPER_CHAIN_APPLY_PROP, true)\r\n\r\n  return Extended\r\n}\r\n\r\nconst extend = (...args) => _extend({ super: args.slice(1), apply: args })\r\n\r\nexport { extend, _extend, _copyChain }\r\n","Array.prototype.concat = function () {\r\n  const concatenated = []\r\n\r\n  for(let i in this) {\r\n    concatenated.push(this[i])\r\n  }\r\n\r\n  for(let i in arguments) {\r\n    for(let j in arguments[i]) {\r\n      concatenated.push(arguments[i][j])\r\n    }\r\n  }\r\n\r\n  return concatenated\r\n}\r\n\r\nexport default Array\r\n","// var PENDING = 'pending'\r\n// var SEALED = 'sealed'\r\n// var FULFILLED = 'fulfilled'\r\n// var REJECTED = 'rejected'\r\n//\r\n// var NOOP = function() {}\r\n//\r\n// function invokeResolver(resolver, promise) {\r\n//   function resolvePromise(value) {\r\n//     resolve(promise, value)\r\n//   }\r\n//\r\n//   function rejectPromise(reason) {\r\n//     reject(promise, reason)\r\n//   }\r\n//\r\n//   try {\r\n//     resolver(resolvePromise, rejectPromise)\r\n//   } catch(e) {\r\n//     rejectPromise(e)\r\n//   }\r\n// }\r\n//\r\n// function invokeCallback(subscriber) {\r\n//   var owner = subscriber.owner\r\n//   var settled = owner.state_\r\n//   var value = owner.data_\r\n//   var callback = subscriber[settled]\r\n//   var promise = subscriber.then\r\n//\r\n//   if (typeof callback === 'function')\r\n//   {\r\n//     settled = FULFILLED\r\n//     try {\r\n//       value = callback(value)\r\n//     } catch(e) {\r\n//       reject(promise, e)\r\n//     }\r\n//   }\r\n//\r\n//   if (!handleThenable(promise, value))\r\n//   {\r\n//     if (settled === FULFILLED)\r\n//       resolve(promise, value)\r\n//\r\n//     if (settled === REJECTED)\r\n//       reject(promise, value)\r\n//   }\r\n// }\r\n//\r\n// function handleThenable(promise, value) {\r\n//   var resolved\r\n//\r\n//   try {\r\n//     if (promise === value)\r\n//       throw new TypeError('A promises callback cannot return that same promise.')\r\n//\r\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\r\n//     {\r\n//       var then = value.then  // then should be retrived only once\r\n//\r\n//       if (typeof then === 'function')\r\n//       {\r\n//         then.call(value, function(val){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             if (value !== val)\r\n//               resolve(promise, val)\r\n//             else\r\n//               fulfill(promise, val)\r\n//           }\r\n//         }, function(reason){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             reject(promise, reason)\r\n//           }\r\n//         })\r\n//\r\n//         return true\r\n//       }\r\n//     }\r\n//   } catch (e) {\r\n//     if (!resolved)\r\n//       reject(promise, e)\r\n//\r\n//     return true\r\n//   }\r\n//\r\n//   return false\r\n// }\r\n//\r\n// function resolve(promise, value){\r\n//   if (promise === value || !handleThenable(promise, value))\r\n//     fulfill(promise, value)\r\n// }\r\n//\r\n// function publish(promise) {\r\n//   var callbacks = promise.then_\r\n//   promise.then_ = undefined\r\n//\r\n//   for (var i = 0 i < callbacks.length i++) {\r\n//     invokeCallback(callbacks[i])\r\n//   }\r\n// }\r\n//\r\n// function fulfill(promise, value){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = value\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = FULFILLED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function reject(promise, reason){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = reason\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = REJECTED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function Promise(resolver) {\r\n//   if (typeof resolver !== 'function')\r\n//     throw new TypeError('Promise constructor takes a function argument')\r\n//\r\n//   if (this instanceof Promise === false)\r\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\r\n//\r\n//   this.then_ = []\r\n//\r\n//   invokeResolver(resolver, this)\r\n// }\r\n//\r\n// Promise.prototype = {\r\n//   constructor: Promise,\r\n//\r\n//   state_: PENDING,\r\n//   then_: null,\r\n//   data_: undefined,\r\n//\r\n//   then: function(onFulfillment, onRejection){\r\n//     var subscriber = {\r\n//       owner: this,\r\n//       then: new this.constructor(NOOP),\r\n//       fulfilled: onFulfillment,\r\n//       rejected: onRejection\r\n//     }\r\n//\r\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\r\n//     {\r\n//       // already resolved, call callback async\r\n//       setImmediate(() => {invokeCallback(subscriber)})\r\n//     }\r\n//     else\r\n//     {\r\n//       // subscribe\r\n//       this.then_.push(subscriber)\r\n//     }\r\n//\r\n//     return subscriber.then\r\n//   },\r\n//\r\n//   'catch': function(onRejection) {\r\n//     return this.then(null, onRejection)\r\n//   }\r\n// }\r\n//\r\n// Promise.all = function(promises){\r\n//   var Class = this\r\n//\r\n//   if (!(promises instanceof Array))\r\n//     throw new TypeError('You must pass an array to Promise.all().')\r\n//\r\n//   return new Class((resolve, reject) => {\r\n//     var results = []\r\n//     var remaining = 0\r\n//\r\n//     function resolver(index){\r\n//       remaining++\r\n//       return function(value){\r\n//         results[index] = value\r\n//         if (!--remaining)\r\n//           resolve(results)\r\n//       }\r\n//     }\r\n//\r\n//     for (var i = 0, promise i < promises.length i++)\r\n//     {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function')\r\n//         promise.then(resolver(i), reject)\r\n//       else\r\n//         results[i] = promise\r\n//     }\r\n//\r\n//     if (!remaining)\r\n//       resolve(results)\r\n//   })\r\n// }\r\n//\r\n// Promise.race = function(promises){\r\n//   var Class = this\r\n//\r\n//   if (!(promises instanceof Array))\r\n//     throw new TypeError('You must pass an array to Promise.race().')\r\n//\r\n//   return new Class((resolve, reject) => {\r\n//     for (var i = 0, promise i < promises.length i++)\r\n//     {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function')\r\n//         promise.then(resolve, reject)\r\n//       else\r\n//         resolve(promise)\r\n//     }\r\n//   })\r\n// }\r\n//\r\n// Promise.resolve = function(value) {\r\n//   var Class = this\r\n//\r\n//   if (value && typeof value === 'object' && value.constructor === Class)\r\n//     return value\r\n//\r\n//   return new Class(function(resolve){\r\n//     resolve(value)\r\n//   })\r\n// }\r\n//\r\n// Promise.reject = function(reason){\r\n//   var Class = this\r\n//\r\n//   return new Class(function(resolve, reject){\r\n//     reject(reason)\r\n//   })\r\n// }\r\n//\r\nif(!Promise.race) {\r\n  Promise.race = promises => {\r\n    if (!(promises instanceof Array))\r\n      throw new TypeError('You must pass an array to Promise.race().')\r\n\r\n    return new Promise((resolve, reject) => {\r\n      for (let i = 0, promise; i < promises.length; i ++) {\r\n        promise = promises[i]\r\n\r\n        promise && typeof promise.then === 'function'\r\n          ? promise.then(resolve, reject)\r\n          : resolve(promise)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport default Promise\r\n","const loop = [\r\n  // immediate\r\n  { queue: [], immediatePush: true, tick: false },\r\n  // timeout\r\n  { queue: [], immediatePush: false, tick: false }\r\n]\r\n\r\nlet tick = false,\r\n    timers = {}\r\n\r\nconst asyncFlush = () => {\r\n  for (let stage in loop) {\r\n    if(loop[stage].queue.length) {\r\n      if(loop[stage].immediatePush) {\r\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\r\n          loop[stage].queue[exec]()\r\n        }\r\n        loop[stage].queue.splice(0)\r\n      } else {\r\n        const queue = loop[stage].queue.splice(0)\r\n        for (let exec = 0; exec < queue.length; exec ++) {\r\n          queue[exec]()\r\n        }\r\n      }\r\n    }\r\n\r\n    loop[stage].tick = tick = false\r\n  }\r\n}\r\n\r\nconst asyncCall = stage => cb => {\r\n  loop[stage].queue.push(cb)\r\n\r\n  if (!tick && !loop[stage].tick) {\r\n    loop[stage].tick = tick = true\r\n\r\n    setTimeout(asyncFlush)\r\n  }\r\n}\r\n\r\nconst setImmediate = asyncCall(/* .immediate */0)\r\n\r\nconst timeoutCall = asyncCall(/* .timeeout */1)\r\n\r\nexport const _setTimeout = (cb, timeout) => setTimeout(() => { timeoutCall(cb) }, timeout)\r\n\r\nexport const _setInterval = (cb, timeout) => (function setTimer() {\r\n  return _setTimeout(() => {\r\n    setTimer()\r\n    cb()\r\n  }, timeout)\r\n})()\r\n\r\nexport {\r\n  setImmediate,\r\n  _setTimeout as setTimeout,\r\n  _setInterval as setInterval\r\n}\r\n","import {\r\n  PN532_PREAMBLE,\r\n  PN532_STARTCODE1,\r\n  PN532_STARTCODE2,\r\n  PN532_HOST_TO_PN532,\r\n  PN532_PN532_TO_HOST,\r\n  PN532_POSTAMBLE\r\n} from './constants'\r\n\r\nconst check = values => 0x00 == 0xff & values.reduce((sum, value) => sum += value, 0x00)\r\n\r\nconst LCS_std = (byte, length, frame) => check(frame.slice(-2))\r\n\r\nconst LCS_ext = (byte, length, frame) => check([frame[5] * 256 + frame[6], frame[7]])\r\n\r\nconst CHECKSUM_std = (byte, length, frame) => check(frame.slice(5))\r\n\r\nconst CHECKSUM_ext = (byte, length, frame) => check(frame.slice(8))\r\n\r\nconst BODY_std = frame => {\r\n  const arr = []\r\n  for(let i = 0; i < frame[3] - 1; i ++)\r\n    arr.push(undefined)\r\n  return arr\r\n}\r\n\r\nconst BODY_ext = frame => {\r\n  const arr = [], length = frame[5] * 256 + frame[6]\r\n  for(let i = 0; i < length - 1; i ++)\r\n    arr.push(undefined)\r\n  return arr\r\n}\r\n\r\nexport const INFO = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, undefined, LCS_std, PN532_PN532_TO_HOST],\r\n  BODY_std,\r\n  [CHECKSUM_std, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const XINFO = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0xff, undefined, undefined, LCS_ext, PN532_PN532_TO_HOST],\r\n  BODY_ext,\r\n  [CHECKSUM_ext, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const ERR = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1 , PN532_STARTCODE2, 0x01, 0xff, undefined, CHECKSUM_std, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const ACK = [\r\n  new Uint8ClampedArray([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x00, 0xff, PN532_POSTAMBLE])\r\n]\r\n\r\nexport const NACK = [\r\n  new Uint8ClampedArray([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0x00, PN532_POSTAMBLE])\r\n]\r\n\r\nexport const command = command =>\r\n  new Uint8ClampedArray([\r\n    PN532_PREAMBLE,\r\n    PN532_STARTCODE1,\r\n    PN532_STARTCODE2,\r\n    0xff & (command.length + 1),\r\n    0xff & (~command.length),\r\n    PN532_HOST_TO_PN532,\r\n    ...command,\r\n    // checksum\r\n    ~(0xff & command.reduce((checksum, byte) => checksum += byte, 1 /** include PN532_HOST_TO_PN532 1 byte to length */)),\r\n    PN532_POSTAMBLE\r\n  ])\r\n","var data = { TNF_EMPTY: 0,\r\n  TNF_WELL_KNOWN: 1,\r\n  TNF_MIME_MEDIA: 2,\r\n  TNF_ABSOLUTE_URI: 3,\r\n  TNF_EXTERNAL_TYPE: 4,\r\n  TNF_UNKNOWN: 5,\r\n  TNF_UNCHANGED: 6,\r\n  TNF_RESERVED: 7,\r\n  RTD_TEXT: \"T\",\r\n  RTD_URI: \"U\",\r\n  RTD_SMART_POSTER: \"Sp\",\r\n  RTD_ALTERNATIVE_CARRIER: \"ac\",\r\n  RTD_HANDOVER_CARRIER: \"Hc\",\r\n  RTD_HANDOVER_REQUEST: \"Hr\",\r\n  RTD_HANDOVER_SELECT: \"Hs\",\r\n  BLOCK_SIZE: 16,\r\n  TLV_START: 64,\r\n  TL_LENGTH: 4 };\r\n\r\n/**\r\n  * decode text bytes from ndef record payload\r\n  *\r\n  * @returns a string\r\n  */\r\nvar decode = function decode(data) {\r\n    var languageCodeLength = data[0] & 0x3F,\r\n        // 6 LSBs\r\n    languageCode = data.slice(1, 1 + languageCodeLength),\r\n        utf16 = (data[0] & 0x80) !== 0; // assuming UTF-16BE\r\n\r\n    // TODO need to deal with UTF in the future\r\n    // console.log(\"lang \" + languageCode + (utf16 ? \" utf16\" : \" utf8\"))\r\n\r\n    return Buffer.from(data.slice(languageCodeLength + 1)).toString();\r\n};\r\n\r\n/**\r\n  * Encode text payload\r\n  *\r\n  * @returns an array of bytes\r\n  */\r\nvar encode = function encode(text, lang, encoding) {\r\n    // ISO/IANA language code, but we're not enforcing\r\n    if (!lang) {\r\n        lang = 'en';\r\n    }\r\n\r\n    var encoded = Buffer.from([lang.length].concat([].slice.call(Buffer.from(lang + text))));\r\n\r\n    return encoded;\r\n};\r\n\r\n// URI identifier codes from URI Record Type Definition NFCForum-TS-RTD_URI_1.0 2006-07-24\r\n// index in array matches code in the spec\r\nvar protocols = [\"\", \"http://www.\", \"https://www.\", \"http://\", \"https://\", \"tel:\", \"mailto:\", \"ftp://anonymous:anonymous@\", \"ftp://ftp.\", \"ftps://\", \"sftp://\", \"smb://\", \"nfs://\", \"ftp://\", \"dav://\", \"news:\", \"telnet://\", \"imap:\", \"rtsp://\", \"urn:\", \"pop:\", \"sip:\", \"sips:\", \"tftp:\", \"btspp://\", \"btl2cap://\", \"btgoep://\", \"tcpobex://\", \"irdaobex://\", \"file://\", \"urn:epc:id:\", \"urn:epc:tag:\", \"urn:epc:pat:\", \"urn:epc:raw:\", \"urn:epc:\", \"urn:nfc:\"];\r\n\r\n/**\r\n  * @returns a string\r\n  */\r\nvar decode$1 = function decode(data) {\r\n    var prefix = protocols[data[0]];\r\n    if (!prefix) {\r\n        // 36 to 255 should be \"\"\r\n        prefix = \"\";\r\n    }\r\n    return prefix + Buffer.from(data.slice(1)).toString();\r\n};\r\n\r\n/**\r\n  * shorten a URI with standard prefix\r\n  *\r\n  * @returns an array of bytes\r\n  */\r\nvar encode$1 = function encode(uri) {\r\n    var prefix, protocolCode, encoded;\r\n\r\n    // check each protocol, unless we've found a match\r\n    // \"urn:\" is the one exception where we need to keep checking\r\n    // slice so we don't check \"\"\r\n    protocols.slice(1).forEach(function (protocol) {\r\n        if ((!prefix || prefix === \"urn:\") && uri.indexOf(protocol) === 0) {\r\n            prefix = protocol;\r\n        }\r\n    });\r\n\r\n    if (!prefix) {\r\n        prefix = \"\";\r\n    }\r\n\r\n    protocolCode = protocols.indexOf(prefix);\r\n    encoded = Buffer.from([protocolCode].concat([].slice.call(Buffer.from(uri.slice(prefix.length)))));\r\n\r\n    return encoded;\r\n};\r\n\r\n// ndef.js\r\n// Copyright 2013 Don Coleman\r\n//\r\n// This code is from phonegap-nfc.js https://github.com/don/phonegap-nfc\r\n\r\n// see android.nfc.NdefRecord for documentation about constants\r\n// http://developer.android.com/reference/android/nfc/NdefRecord.html\r\n\r\n// convert bytes to a String\r\nvar s = function s(bytes) {\r\n  return Buffer.from(bytes).toString();\r\n};\r\n\r\n/**\r\n * Creates a JSON representation of a NDEF Record.\r\n *\r\n * @tnf 3-bit TNF (Type Name Format) - use one of the constants.TNF_* constants\r\n * @type byte array, containing zero to 255 bytes, must not be null\r\n * @id byte array, containing zero to 255 bytes, must not be null\r\n * @payload byte array, containing zero to (2 ** 32 - 1) bytes, must not be null\r\n *\r\n * @returns JSON representation of a NDEF record\r\n *\r\n * @see Ndef.textRecord, Ndef.uriRecord and Ndef.mimeMediaRecord for examples\r\n */\r\n\r\nvar record = function record(tnf, type, id, payload, value) {\r\n  if (!tnf) {\r\n    tnf = data.TNF_EMPTY;\r\n  }\r\n  if (!type) {\r\n    type = [];\r\n  }\r\n  if (!id) {\r\n    id = [];\r\n  }\r\n  if (!payload) {\r\n    payload = [];\r\n  }\r\n  // store type as String so it's easier to compare\r\n  if (type instanceof Array) {\r\n    type = Buffer.from(type).toString();\r\n  }\r\n\r\n  // in the future, id could be a String\r\n  if (!(id instanceof Array)) {\r\n    id = Buffer.from(id);\r\n  }\r\n\r\n  // Payload must be binary\r\n  if (!(payload instanceof Array)) {\r\n    payload = Buffer.from(payload);\r\n  }\r\n\r\n  // Experimental feature\r\n  // Convert payload to text for Text and URI records\r\n  if (tnf == data.TNF_WELL_KNOWN) {\r\n    if (type == data.RTD_TEXT) {\r\n      value = decode(payload);\r\n    } else if (type == data.RTD_URI) {\r\n      value = decode$1(payload);\r\n    }\r\n  }\r\n\r\n  return {\r\n    tnf: tnf,\r\n    type: type,\r\n    id: id,\r\n    payload: payload,\r\n    value: value\r\n  };\r\n};\r\n\r\n/**\r\n * Helper that creates an NDEF record containing plain text.\r\n *\r\n * @text String of text to encode\r\n * @languageCode ISO/IANA language code. Examples: “fi”, “en-US”, “fr-CA”, “jp”. (optional)\r\n * @id byte[] (optional)\r\n */\r\nvar textRecord = function textRecord(text, languageCode, id) {\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_TEXT, id || [], encode(text, languageCode));\r\n};\r\n\r\n/**\r\n * Helper that creates a NDEF record containing a URI.\r\n *\r\n * @uri String\r\n * @id byte[] (optional)\r\n */\r\nvar uriRecord = function uriRecord(uri, id) {\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_URI, id || [], encode$1(uri));\r\n};\r\n\r\n/**\r\n * Helper that creates a NDEF record containing an absolute URI.\r\n *\r\n * An Absolute URI record means the URI describes the payload of the record.\r\n *\r\n * For example a SOAP message could use \"http://schemas.xmlsoap.org/soap/envelope/\"\r\n * as the type and XML content for the payload.\r\n *\r\n * Absolute URI can also be used to write LaunchApp records for Windows.\r\n *\r\n * See 2.4.2 Payload Type of the NDEF Specification\r\n * http://www.nfc-forum.org/specs/spec_list#ndefts\r\n *\r\n * Note that by default, Android will open the URI defined in the type\r\n * field of an Absolute URI record (TNF=3) and ignore the payload.\r\n * BlackBerry and Windows do not open the browser for TNF=3.\r\n *\r\n * To write a URI as the payload use ndef.uriRecord(uri)\r\n *\r\n * @uri String\r\n * @payload byte[] or String\r\n * @id byte[] (optional)\r\n */\r\nvar absoluteUriRecord = function absoluteUriRecord(uri, payload, id) {\r\n  return record(data.TNF_ABSOLUTE_URI, uri, id || [], payload || []);\r\n};\r\n\r\n/**\r\n* Helper that creates a NDEF record containing an mimeMediaRecord.\r\n*\r\n* @mimeType String\r\n* @payload byte[]\r\n* @id byte[] (optional)\r\n*/\r\nvar mimeMediaRecord = function mimeMediaRecord(mimeType, payload, id) {\r\n  return record(data.TNF_MIME_MEDIA, mimeType, id || [], payload || []);\r\n};\r\n\r\n/**\r\n* Helper that creates an NDEF record containing an Smart Poster.\r\n*\r\n* @ndefRecords array of NDEF Records\r\n* @id byte[] (optional)\r\n*/\r\nvar smartPoster = function smartPoster(ndefRecords, id) {\r\n  var payload = [];\r\n\r\n  if (ndefRecords) {\r\n    // make sure we have an array of something like NDEF records before encoding\r\n    if (ndefRecords[0] instanceof Object && ndefRecords[0].hasOwnProperty('tnf')) {\r\n      payload = encodeMessage(ndefRecords);\r\n    } else {\r\n      // assume the caller has already encoded the NDEF records into a byte array\r\n      payload = ndefRecords;\r\n    }\r\n  } else {\r\n    //console.warn(\"WARNING: Expecting an array of NDEF records\")\r\n    throw new Error('Expecting an array of NDEF records');\r\n  }\r\n\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_SMART_POSTER, id, payload);\r\n};\r\n\r\n/**\r\n* Helper that creates an empty NDEF record.\r\n*\r\n*/\r\nvar emptyRecord = function emptyRecord() {\r\n  return record(data.TNF_EMPTY, [], [], []);\r\n};\r\n\r\n/**\r\n* Helper that creates an Android Application Record (AAR).\r\n* http://developer.android.com/guide/topics/connectivity/nfc/nfc.html#aar\r\n*\r\n*/\r\nvar androidApplicationRecord = function androidApplicationRecord(packageName) {\r\n  return record(data.TNF_EXTERNAL_TYPE, 'android.com:pkg', [], packageName);\r\n};\r\n\r\n/**\r\n* Encodes an NDEF Message into bytes that can be written to a NFC tag.\r\n*\r\n* @ndefRecords an Array of NDEF Records\r\n*\r\n* @returns byte array\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\r\nvar encodeMessage = function encodeMessage(ndefRecords) {\r\n  var encoded = [],\r\n      tnf_byte = void 0,\r\n      record_type = void 0,\r\n      payload_length = void 0,\r\n      id_length = void 0,\r\n      i = void 0,\r\n      mb = void 0,\r\n      me = void 0,\r\n      // messageBegin, messageEnd\r\n  cf = false,\r\n      // chunkFlag TODO implement\r\n  sr = void 0,\r\n      // boolean shortRecord\r\n  il = void 0; // boolean idLengthFieldIsPresent\r\n\r\n  for (i = 0; i < ndefRecords.length; i++) {\r\n    mb = i === 0;\r\n    me = i === ndefRecords.length - 1;\r\n    sr = ndefRecords[i].payload.length < 0xFF;\r\n    il = ndefRecords[i].id.length > 0;\r\n    tnf_byte = encodeTnf(mb, me, cf, sr, il, ndefRecords[i].tnf);\r\n    encoded.push(tnf_byte);\r\n\r\n    // type is stored as String, converting to bytes for storage\r\n    record_type = [].slice.call(Buffer.from(ndefRecords[i].type));\r\n    encoded.push(record_type.length);\r\n\r\n    if (sr) {\r\n      payload_length = ndefRecords[i].payload.length;\r\n      encoded.push(payload_length);\r\n    } else {\r\n      payload_length = ndefRecords[i].payload.length;\r\n      // 4 bytes\r\n      encoded.push(payload_length >> 24);\r\n      encoded.push(payload_length >> 16);\r\n      encoded.push(payload_length >> 8);\r\n      encoded.push(payload_length & 0xFF);\r\n    }\r\n\r\n    if (il) {\r\n      id_length = ndefRecords[i].id.length;\r\n      encoded.push(id_length);\r\n    }\r\n\r\n    encoded = encoded.concat(record_type);\r\n\r\n    if (il) {\r\n      encoded = encoded.concat(ndefRecords[i].id);\r\n    }\r\n\r\n    encoded = encoded.concat([].slice.call(ndefRecords[i].payload));\r\n  }\r\n\r\n  return encoded;\r\n};\r\n\r\n/**\r\n* Decodes an array bytes into an NDEF Message\r\n*\r\n* @bytes an array bytes read from a NFC tag\r\n*\r\n* @returns array of NDEF Records\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\r\nvar decodeMessage = function decodeMessage(_bytes) {\r\n  var bytes = _bytes.slice(0),\r\n      // clone since parsing is destructive\r\n  ndef_message = [],\r\n      tnf_byte = void 0,\r\n      header = void 0,\r\n      type_length = 0,\r\n      payload_length = 0,\r\n      id_length = 0,\r\n      record_type = [],\r\n      id = [],\r\n      payload = [];\r\n\r\n  while (bytes.length) {\r\n    tnf_byte = bytes.shift();\r\n    header = decodeTnf(tnf_byte);\r\n\r\n    type_length = bytes.shift();\r\n\r\n    if (header.sr) {\r\n      payload_length = bytes.shift();\r\n    } else {\r\n      // next 4 bytes are length\r\n      payload_length = (0xFF & bytes.shift()) << 24 | (0xFF & bytes.shift()) << 16 | (0xFF & bytes.shift()) << 8 | 0xFF & bytes.shift();\r\n    }\r\n\r\n    if (header.il) {\r\n      id_length = bytes.shift();\r\n    }\r\n\r\n    record_type = bytes.splice(0, type_length);\r\n    id = bytes.splice(0, id_length);\r\n    payload = bytes.splice(0, payload_length);\r\n\r\n    ndef_message.push(record(header.tnf, record_type, id, payload));\r\n\r\n    if (header.me) {\r\n      // last message\r\n      break;\r\n    }\r\n  }\r\n\r\n  return ndef_message;\r\n};\r\n\r\n/**\r\n* Decode the bit flags from a TNF Byte.\r\n*\r\n* @returns object with decoded data\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\r\nvar decodeTnf = function decodeTnf(tnf_byte) {\r\n  return {\r\n    mb: (tnf_byte & 0x80) !== 0,\r\n    me: (tnf_byte & 0x40) !== 0,\r\n    cf: (tnf_byte & 0x20) !== 0,\r\n    sr: (tnf_byte & 0x10) !== 0,\r\n    il: (tnf_byte & 0x8) !== 0,\r\n    tnf: tnf_byte & 0x7\r\n  };\r\n};\r\n\r\n/**\r\n* Encode NDEF bit flags into a TNF Byte.\r\n*\r\n* @returns tnf byte\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\r\nvar encodeTnf = function encodeTnf(mb, me, cf, sr, il, tnf, value) {\r\n  if (!value) {\r\n    value = tnf;\r\n  }\r\n\r\n  if (mb) {\r\n    value = value | 0x80;\r\n  }\r\n\r\n  if (me) {\r\n    value = value | 0x40;\r\n  }\r\n\r\n  // note if cf: me, mb, li must be false and tnf must be 0x6\r\n  if (cf) {\r\n    value = value | 0x20;\r\n  }\r\n\r\n  if (sr) {\r\n    value = value | 0x10;\r\n  }\r\n\r\n  if (il) {\r\n    value = value | 0x8;\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\n// TODO test with byte[] and string\r\nvar isType = function isType(record, tnf, type) {\r\n  return record.tnf === tnf ? s(record) === s(type) : false;\r\n};\r\n\r\n// export const tnfToString = (tnf, value = tnf) => {\r\n//   if(tnf == constants.TNF_EMPTY) {\r\n//     value = \"Empty\"\r\n//   }\r\n//   else if(constants.TNF_WELL_KNOWN) {\r\n//     value = \"Well Known\"\r\n//   }\r\n//   else if(constants.TNF_MIME_MEDIA) {\r\n//     value = \"Mime Media\"\r\n//   }\r\n//   else if(constants.TNF_ABSOLUTE_URI) {\r\n//     value = \"Absolute URI\"\r\n//   }\r\n//   else if(constants.TNF_EXTERNAL_TYPE) {\r\n//     value = \"External\"\r\n//   }\r\n//   else if(constants.TNF_UNKNOWN) {\r\n//     value = \"Unknown\"\r\n//   }\r\n//   else if(constants.TNF_UNCHANGED) {\r\n//     value = \"Unchanged\"\r\n//   }\r\n//   else if(constants.TNF_RESERVED) {\r\n//     value = \"Reserved\"\r\n//   }\r\n//   return value\r\n// }\r\n\r\n// Convert NDEF records and messages to strings\r\n// This works OK for demos, but real code proably needs\r\n// a custom implementation. It would be nice to make\r\n// smarter record objects that can print themselves\r\n// var stringifier = {\r\n//     stringify: function (data, separator) {\r\n//       if (Array.isArray(data)) {\r\n//         if (typeof data[0] === 'number') {\r\n//           // guessing this message bytes\r\n//           data = decodeMessage(data)\r\n//         }\r\n//\r\n//         return stringifier.printRecords(data, separator)\r\n//       } else {\r\n//         return stringifier.printRecord(data, separator)\r\n//       }\r\n//     },\r\n//\r\n//     // @message - NDEF Message (array of NDEF Records)\r\n//     // @separator - line separator, optional, defaults to \\n\r\n//     // @returns string with NDEF Message\r\n//     printRecords: function (message, separator) {\r\n//\r\n//         if(!separator) { separator = \"\\n\" }\r\n//         result = \"\"\r\n//\r\n//         // Print out the payload for each record\r\n//         message.forEach(function(record) {\r\n//             result += stringifier.printRecord(record, separator)\r\n//             result += separator\r\n//         })\r\n//\r\n//         return result.slice(0, (-1 * separator.length))\r\n//     },\r\n//\r\n//     // @record - NDEF Record\r\n//     // @separator - line separator, optional, defaults to \\n\r\n//     // @returns string with NDEF Record\r\n//     printRecord: function (record, separator) {\r\n//\r\n//         var result = \"\"\r\n//\r\n//         if(!separator) { separator = \"\\n\" }\r\n//\r\n//         switch(record.tnf) {\r\n//             case ndef.constants.TNF_EMPTY:\r\n//                 result += \"Empty Record\"\r\n//                 result += separator\r\n//                 break\r\n//             case ndef.constants.TNF_WELL_KNOWN:\r\n//                 result += stringifier.printWellKnown(record, separator)\r\n//                 break\r\n//             case ndef.constants.TNF_MIME_MEDIA:\r\n//                 result += \"MIME Media\"\r\n//                 result += separator\r\n//                 result += s(record.type)\r\n//                 result += separator\r\n//                 result += s(record.payload) // might be binary\r\n//                 break\r\n//             case ndef.constants.TNF_ABSOLUTE_URI:\r\n//                 result += \"Absolute URI\"\r\n//                 result += separator\r\n//                 result += s(record.type)    // the URI is the type\r\n//                 result += separator\r\n//                 result += s(record.payload) // might be binary\r\n//                 break\r\n//             case ndef.constants.TNF_EXTERNAL_TYPE:\r\n//                 // AAR contains strings, other types could\r\n//                 // contain binary data\r\n//                 result += \"External\"\r\n//                 result += separator\r\n//                 result += s(record.type)\r\n//                 result += separator\r\n//                 result += s(record.payload)\r\n//                 break\r\n//             default:\r\n//                 result += s(\"Can't process TNF \" + record.tnf)\r\n//         }\r\n//\r\n//         result += separator\r\n//         return result\r\n//     },\r\n//\r\n//     printWellKnown: function (record, separator) {\r\n//\r\n//         var result = \"\"\r\n//\r\n//         if (record.tnf !== ndef.constants.TNF_WELL_KNOWN) {\r\n//             return \"ERROR expecting TNF Well Known\"\r\n//         }\r\n//\r\n//         switch(record.type) {\r\n//             case ndef.constants.RTD_TEXT:\r\n//                 result += \"Text Record\"\r\n//                 result += separator\r\n//                 result += (ndef.text.decodePayload(record.payload))\r\n//                 break\r\n//             case ndef.constants.RTD_URI:\r\n//                 result += \"URI Record\"\r\n//                 result += separator\r\n//                 result += (ndef.uri.decodePayload(record.payload))\r\n//                 break\r\n//             case ndef.constants.RTD_SMART_POSTER:\r\n//                 result += \"Smart Poster\"\r\n//                 result += separator\r\n//                 // the payload of a smartposter is a NDEF message\r\n//                 result += stringifier.printRecords(ndef.decodeMessage(record.payload))\r\n//                 break\r\n//             default:\r\n//                 // attempt to display other types\r\n//                 result += record.type + \" Record\"\r\n//                 result += separator\r\n//                 result += s(record.payload)\r\n//         }\r\n//\r\n//         return result\r\n//     }\r\n// }\r\n//\r\n// export const stringify = { stringifier }\r\n\r\nexport { data as constants, record, textRecord, uriRecord, absoluteUriRecord, mimeMediaRecord, smartPoster, emptyRecord, androidApplicationRecord, encodeMessage, decodeMessage, decodeTnf, encodeTnf, isType };\r\n","import Bus from 'bus'\r\nimport blink from 'blink'\r\nimport { command, ACK, NACK, INFO, XINFO } from 'nfc'\r\nimport {\r\n  PN532_COMMAND_SAMCONFIGURATION,\r\n  PN532_SAM_NORMAL_MODE,\r\n  PN532_COMMAND_WRITEGPIO,\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  PN532_COMMAND_GETFIRMWAREVERSION,\r\n  PN532_WAKEUP,\r\n  MIFARE_CMD_READ,\r\n  MIFARE_CMD_AUTH_A,\r\n  MIFARE_CMD_AUTH_B,\r\n  MIFARE_CMD_WRITE_4,\r\n  MIFARE_CMD_WRITE_16\r\n} from 'nfc/constants'\r\n\r\nimport series from 'series'\r\n\r\nimport { encodeMessage, textRecord } from 'esp-ndef'\r\n\r\nblink()\r\n\r\nconst encoded = encodeMessage([\r\n  textRecord('2enhello world!')\r\n])\r\n\r\nconst wakeup = command([PN532_WAKEUP])\r\nconst sam = command([PN532_COMMAND_SAMCONFIGURATION, PN532_SAM_NORMAL_MODE, 20, 0])\r\n\r\n\r\n\r\n\r\nfunction setup(done) {\r\n  Serial1.setup(115200, {\r\n    rx: B7, tx: B6\r\n  })\r\n\r\n  Serial1.write(wakeup)\r\n  Serial1.write(sam)\r\n\r\n  setTimeout(() => {\r\n    Serial1.read()\r\n    Serial1.pipe(this)\r\n  }, 1500)\r\n\r\n  setTimeout(() => {\r\n    blink.once(LED1, 20, () => setTimeout(() => blink.once(LED1, 20), 200))\r\n\r\n    done()\r\n  }, 2000)\r\n}\r\n\r\nconst bus = new Bus({\r\n  setup, highWaterMark: 64\r\n})\r\n\r\nbus.on('error', console.error)\r\n\r\nbus.setup(Serial1)\r\n\r\nconst KEY = new Uint8ClampedArray([0xff, 0xff, 0xff, 0xff, 0xff, 0xff])\r\n\r\nlet afi = 0x00\r\n\r\n;(function poll() {\r\n  let uid,\r\n      block = 4,\r\n      data = null\r\n\r\n  bus.deferred(done => {\r\n    const LIST = command([\r\n      PN532_COMMAND_INLISTPASSIVETARGET,\r\n      1,\r\n      0\r\n    ])\r\n\r\n    bus.rx(ACK, () => {\r\n      console.log('ACK')\r\n    })\r\n\r\n    bus.rx(INFO, frame => {\r\n      const body = frame.slice(7, 5 + frame[3]),\r\n            uidLength = body[5],\r\n            _uid = body.slice(6, 6 + uidLength)\r\n\r\n      console.log('FOUND', {\r\n        code: frame[6],\r\n        body,\r\n        count: body[0],\r\n        ATQA: body.slice(2, 4), // SENS_RES\r\n        SAK: body[4],\r\n        uidLength,\r\n        uid: _uid\r\n      }['ATQA'])\r\n\r\n      uid = _uid\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(LIST)\r\n  })\r\n\r\n  bus.deferred((done, fail) => {\r\n    const AUTH = command([\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_CMD_AUTH_A,\r\n      block\r\n    ].concat(KEY).concat(uid))\r\n\r\n    bus.rx(ACK, ACK => {})\r\n\r\n    bus.rx(ERR, fail)\r\n\r\n    bus.rx(INFO, frame => {\r\n      console.log('AUTH SUCCEED'/*, {\r\n        code: frame[6],\r\n        body: frame.slice(7, 5 + frame[3])\r\n      }*/)\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(AUTH)\r\n  })\r\n\r\n  bus.deferred((done, fail) => {\r\n    const WRITE = command([\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_CMD_WRITE_4,\r\n      block\r\n    ].concat(encoded))\r\n\r\n    bus.rx(ACK, ACK => {})\r\n\r\n    bus.rx(ERR, fail)\r\n\r\n    bus.rx(INFO, block => {\r\n      console.log('WRITE SUCCEED')\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(WRITE)\r\n  })\r\n\r\n  bus.deferred((done, fail) => {\r\n    const READ = command([\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_CMD_READ,\r\n      block\r\n    ])\r\n\r\n    bus.rx(ACK, ACK => {})\r\n\r\n    bus.rx(ERR, fail)\r\n\r\n    bus.rx(INFO, block => {\r\n      console.log(\"RED\", block)\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(READ)\r\n  })\r\n\r\n  bus.deferred(done => {\r\n    setTimeout(() => {\r\n      console.log(process.memory().free)\r\n      done()\r\n      poll()\r\n    }, 1000)\r\n  })\r\n})()\r\n"],"names":["EventEmitter","_listeners","_duplicateEvent","event","this","Schedule","pending","Promise","resolve","series","arr","cb","done","i","next","res","undefined","length","_parse","chunk","encoding","_busState","incoming","watching","frame","currentChunkIndex","incomingIndex","isEqual","push","watchingIndex","patterns","callback","Function","err","emit","incomingI","expected","currentPattern","byteIndex","Array","arrayOffset","call","slice","patternIndex","splice","pattern","nextPattern","Error","_write","highWaterMark","options","chunks","bytesLeft","offset","subchunk","apply","arguments","_Bus","Object","assign","_setup","setup","bind","blink","mode","status","start","stop","Buffer","timers","console","time","label","Date","now","timeEnd","log","toFixed","error","target","args","obj","key","_copyChain","Extended","ProtoChain","chainPropName","ignoreExtended","prototype","defineProperty","value","forEach","isExtended","Proto","PROTOTYPE_IS_EXTENDED_PROP","hasSameChain","alreadyInChain","some","P","shouldBePushed","concat","concatenated","j","race","promises","TypeError","reject","promise","then","_named","listener","on","removeListener","_listener","task","all","fail","catch","_this","_this2","loop","queue","immediatePush","tick","asyncFlush","stage","exec","asyncCall","setImmediate","deferred","configured","slots","watcher","index","indexOf","watch","_this3","binary","write","timeout","Bus","SUPER_CHAIN_APPLY_PROP","Super","super","static","Child","name","prop","proto","SUPER_CHAIN_PROTO_PROP","_extend","Writable","once","LED2","led","check","values","reduce","sum","INFO","PN532_PREAMBLE","PN532_STARTCODE1","PN532_STARTCODE2","byte","ACK","Uint8ClampedArray","command","PN532_HOST_TO_PN532","checksum","from","iterable","c","charCodeAt","array","list","totalLength","buffer","set","buf","decode","data","languageCodeLength","protocols","decode$1","prefix","encodeTnf","mb","me","cf","sr","il","tnf","encoded","ndefRecords","tnf_byte","record_type","payload_length","id_length","payload","id","type","encodeMessage","record","text","lang","encode","textRecord","wakeup","sam","bus","B7","tx","B6","read","pipe","LED1","setTimeout","Serial1","KEY","poll","uid","block","LIST","rx","body","uidLength","_uid","AUTH","PN532_COMMAND_INDATAEXCHANGE","MIFARE_CMD_AUTH_A","ERR","WRITE","MIFARE_CMD_WRITE_4","READ","process","memory","free"],"mappings":"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"}