{"version":3,"file":"index.esp.min.js","sources":["../globals/console.js","../node_modules/events/events.js","../lib/stream/stream.js","../globals/buffer/index.js","../lib/stream/bufferState.js","../lib/stream/readable.js","../lib/stream/writable.js","../lib/stream/duplex.js","../lib/stream/Duplex.js","../lib/stream/transform.js","../lib/stream/passthrough.js","../lib/schedule.js","../helpers/series.js","../lib/bus/index.js","../lib/blink.js","../src/index.js","../globals/event-loop.js","../globals/process.js","../globals/object.js","../globals/def.js","../globals/namedFunc.js","../globals/extend/vars.js","../globals/extend/index.js","../globals/array.js","../globals/promise.js","../lib/nfc/index.js","../node_modules/esp-ndef/dist/index.esm.js"],"sourcesContent":["const timers = {}\r\n\r\nfunction time(label) {\r\n  timers[label] = Date.now()\r\n}\r\n\r\nfunction timeEnd(label) {\r\n  if(label in timers) {\r\n    console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\r\n    delete timers[label]\r\n  }\r\n}\r\n\r\nif(typeof console.time !== 'function') {\r\n  console.time = time\r\n  console.timeEnd = timeEnd\r\n}\r\n\r\nif(typeof console.error !== 'function') {\r\n  console.error = console.log\r\n}\r\n\r\nexport default console\r\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","import EventEmitter from 'events'\r\n\r\nfunction _Stream(options = {}) {\r\n\tthis.options = {\r\n\t\thighWaterMark: options.highWaterMark || 128\r\n\t}\r\n}\r\n\r\nconst Stream = _extend({\r\n\tname: 'Stream',\r\n\tsuper: [EventEmitter],\r\n\tapply: [EventEmitter, _named('Stream', _Stream)]\r\n})\r\n\r\nStream.prototype.emit = function (event, err) {\r\n\tif(event === 'error' && !(this['#onerror'] || this._events['error']))\r\n\t\tthrow new Error(err)\r\n\r\n\treturn EventEmitter.prototype.emit.apply(this, arguments)\r\n}\r\n\r\nexport default Stream\r\n","import Proto from './proto'\r\nimport { toBuffer } from './utils/to'\r\n\r\nfunction copy(target) {\r\n\tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\r\n\t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\r\n\t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\r\n\r\n\tlet copied = 0\r\n\r\n\tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\r\n\t\ttarget.set([ this[sourceIndex] ], targetIndex)\r\n\r\n\treturn copied\r\n}\r\n\r\nfunction Buffer() {\r\n\tthrow new Error('Buffer constructor is deprecated. Use Buffer.from() instead.')\r\n}\r\n\r\nBuffer.from = function _createBuffer() {\r\n\t//console.log(arguments)\r\n\tlet iterable = []\r\n\tif(typeof arguments[0] === 'string') {\r\n    for(let c in arguments[0])\r\n  \t\titerable[c] = arguments[0].charCodeAt(c)\r\n\r\n  \titerable = new Proto(iterable)\r\n  }\r\n\r\n  else if(arguments[0] instanceof Proto || arguments[0] instanceof Array)\r\n\t\titerable = new Proto(arguments[0])\r\n\r\n\tconst offset = arguments[1] !== undefined ? arguments[1] : 0,\r\n\t\tlength = arguments[2] !== undefined ? arguments[2] : iterable.length\r\n\r\n\tconst array = []\r\n\r\n\tfor(let i = offset;i--;)\r\n\t\tarray[i] = 0\r\n\r\n\tfor(let i = 0; (i < iterable.length) && (i < length); i++)\r\n\t\tarray[offset + i] = iterable[i]\r\n\r\n\tfor(let i = array.length; i < length; i++)\r\n\t\tarray[i] = 0\r\n\r\n\tconst buffer = new Proto(array)\r\n\r\n\treturn buffer\r\n}\r\n\r\nBuffer.concat = function concat() {\r\n\tconst list = arguments[0] || [],\r\n\t\t\t\ttotalLength = arguments[1] !== undefined ? arguments[1] : list.reduce((totalLength, array) => (totalLength + array.length), 0),\r\n\t\t\t\tbuffer = Buffer.from([], 0, totalLength)\r\n\r\n\tlet offset = 0\r\n\r\n\tlist.forEach(buf => {\r\n\t\tbuffer.set(buf, offset)\r\n\t\toffset += buf.length\r\n\t})\r\n\r\n\treturn buffer\r\n}\r\n\r\nexport default Buffer\r\n","function BufferState(options = {}) {\r\n  Object.assign(this, {\r\n\t\t_buffer: [],\r\n\t\tlength: 0\r\n\t}, options)\r\n}\r\n\r\nBufferState.prototype = {\r\n  push(chunk) {\r\n    const node = {\r\n  \t\tchunk: Buffer.from(chunk),\r\n  \t\tnext: null\r\n  \t}\r\n\r\n    if(this._buffer.length) {\r\n      this._buffer[this._buffer.length - 1].next = node\r\n    }\r\n\r\n    this._buffer.push(node)\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  unshift(chunk) {\r\n    const node = {\r\n  \t\tchunk: Buffer.from(chunk),\r\n      encoding: 'binary',\r\n  \t\tnext: null\r\n  \t}\r\n\r\n    if(this._buffer.length) {\r\n      node.next = this._buffer[0]\r\n    }\r\n\r\n    this._buffer.unshift(node)\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  nodes(count) {\r\n    const nodes = this._buffer.splice(0, count)\r\n    nodes.forEach(node => this.length -= node.chunk.length)\r\n\r\n    return nodes\r\n  },\r\n\r\n  at(index) {\r\n    if(index >= this.length || index < 0) {\r\n      return\r\n    }\r\n\r\n    for(let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex ++) {\r\n      if(index < this._buffer[nodeIndex].chunk.length) {\r\n        return {\r\n          index,\r\n          nodeIndex\r\n        }\r\n      }\r\n\r\n      index -= this._buffer[nodeIndex].chunk.length\r\n    }\r\n  },\r\n\r\n  buffer(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!this.length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      to = this.at(length)\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n\r\n    const buffer = Buffer.from([], 0, length)\r\n\r\n    const offset = this.nodes(to.nodeIndex).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset += node.chunk.length\r\n    }, 0)\r\n\r\n    if(offset < length) {\r\n      const node = this.nodes(1).shift()\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n      node.chunk = node.chunk.slice(length - offset)\r\n\r\n      this.unshift(node)\r\n    }\r\n\r\n    return buffer\r\n\r\n    // return from.nodeIndex == to.nodeIndex\r\n    //   ? this._buffer[from.nodeIndex].chunk.slice(from.index, to.index)\r\n    //   : Buffer.concat([\r\n    //       this._buffer[from.nodeIndex].chunk.slice(from.index),\r\n    //       ...this._buffer.slice(1 + from.nodeIndex, to.nodeIndex).map(node => node.chunk),\r\n    //       this._buffer[to.nodeIndex].chunk.slice(0, to.index)\r\n    //     ])\r\n  }\r\n}\r\n\r\nexport default BufferState\r\n","import Stream from './stream'\r\nimport BufferState from './bufferState'\r\n\r\nconst encodings = {\r\n\tBINARY: 'binary',\r\n\tUTF8: 'utf8'\r\n}\r\n\r\nfunction toString(binary) {\r\n\tlet str = ''\r\n\tfor(let i = 0; i < binary.length; i++)\r\n\t\tstr += String.fromCharCode(binary[i])\r\n\treturn str\r\n}\r\n\r\n// function _broadcast() {\r\n// \tlet chunk = this.read()\r\n// \tif(chunk && chunk.length) {\r\n// \t\tprocess.nextTick(() => {\r\n// \t\t\tif(this._readableState.defaultEncoding == encodings.UTF8) {\r\n// \t\t\t\tchunk = toString(chunk)\r\n// \t\t\t}\r\n// \t\t\tthis.emit('data', chunk, this._readableState.defaultEncoding)\r\n// \t\t})\r\n// \t}\r\n// }\r\n\r\nfunction _flow() {\r\n\tif(this._readableState.flowing) {\r\n\t\t// _broadcast.call(this)\r\n\t\tlet chunk = this.read()\r\n\t\tif(chunk && chunk.length) {\r\n\t\t\tprocess.nextTick(() => {\r\n\t\t\t\tif(this._readableState.defaultEncoding == encodings.UTF8) {\r\n\t\t\t\t\tchunk = toString(chunk)\r\n\t\t\t\t}\r\n\t\t\t\tthis.emit('data', chunk, this._readableState.defaultEncoding)\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction _end() {\r\n\tthis._readableState.flowing = null\r\n\tthis._readableState.ended = true\r\n\r\n}\r\n\r\nfunction _Readable(options = {}) {\r\n\tthis._readableState = new BufferState({\r\n\t\tflowing: null,\r\n\t\tended: false,\r\n\t\tdefaultEncoding: encodings.BINARY\r\n\t})\r\n\r\n\tthis.pipes = []\r\n\r\n\tthis._read = options.read.bind(this)\r\n\r\n\tif(!this._read)\r\n\t\tthrow new TypeError('_read() is not implemented')\r\n\tif(!this._read instanceof Function)\r\n\t\tthrow new TypeError('\\'options.read\\' should be a function, passed', typeof options.read)\r\n}\r\n\r\n_Readable.prototype = {\r\n\tpause() {\r\n\t\t//console.log('pause()')\r\n\t\tif(this._readableState.flowing !== false) {\r\n\t\t\tthis._readableState.flowing = false\r\n\t\t\tthis.emit('pause')\r\n\t\t}\r\n\r\n\t\treturn this\r\n\t},\r\n\r\n\tresume() {\r\n\t\tif(!this._readableState.flowing) {\r\n\t\t\tthis._readableState.flowing = true\r\n\t\t\tthis.emit('resume')\r\n\t\t\t_flow.call(this)\r\n\t\t}\r\n\r\n\t\treturn this\r\n\t},\r\n\r\n\tread(length) {\r\n\t\tif(length < 0) {\r\n\t\t\tthrow new Error('\"length\" must be more than 0')\r\n\t\t}\r\n\r\n\t\tif(!this._readableState.ended) {\r\n\t\t\tif(length === undefined) {\r\n\t\t\t\tif(this._readableState.length < this.options.highWaterMark) {\r\n\t\t\t\t\tthis._read(this.options.highWaterMark - this._readableState.length)\r\n\t\t\t\t}\r\n\t\t\t} else if(length > this._readableState.length) {\r\n\t\t \t\tthis._read(length - this._readableState.length)\r\n\t\t \t}\r\n\t\t}\r\n\r\n\t\tif(this._readableState.ended) {\r\n\t\t\tif(this._readableState.length) {\r\n\t\t\t\treturn this._readableState.buffer()\r\n\t\t\t}\r\n\r\n\t\t\treturn null\r\n\t\t}\r\n\r\n\t\tif(length !== undefined && this._readableState.length < length) {\r\n\t\t\treturn null\r\n\t\t}\r\n\r\n\t\treturn this._readableState.buffer(length)\r\n\t},\r\n\r\n\tpush(chunk) {\r\n\t\t//console.log('push(' + chunk + ')')\r\n\t\tif(chunk === null) {\r\n\t\t\t_end.call(this)\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\tconst overflow = this._readableState.push(chunk) > this.options.highWaterMark\r\n\r\n\t\tif(!overflow)\r\n\t\t\t_flow.call(this)\r\n\r\n\t\treturn !overflow\r\n\t},\r\n\r\n\tpipe(writable) {\r\n\t\tif(!this.pipes.some(pipe => { pipe.writable === writable }) ) {\r\n\t\t\tconst listener = (data, pipe) => {\r\n\t\t\t\tif(!writable.write(data)) {\r\n\t\t\t\t\tpipe.stopped = true\r\n\t\t\t\t\tthis.pause()\r\n\r\n\t\t\t\t\twritable.once('drain', () => { this.resume() })\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tconst pipe = { writable, listener, stopped: undefined }\r\n\r\n\t\t\tthis\r\n\t\t\t\t.on('data', data => { listener(data, pipe) })\r\n\t\t\t\t.pipes.push(pipe)\r\n\r\n\t\t\tif(writable instanceof Stream)\r\n\t\t\t\twritable.emit('pipe')\r\n\t\t}\r\n\r\n\t\treturn writable\r\n\t},\r\n\r\n\tunpipe(writable) {\r\n\t  if(writable) {\r\n\t    const pipe = this.pipes.find(pipe => { pipe.writable === writable })\r\n\r\n\t    if(pipe)\r\n\t      this.removeListener('data', pipe.listener)\r\n\t  }\r\n\r\n\t  else {\r\n\t    for(let index in this.pipes)\r\n\t      this.removeListener(this.pipes[index].listener)\r\n\t    this.pipes.splice(0)\r\n\t  }\r\n\t},\r\n\r\n\ton(event, listener) {\r\n\t\tif(event == 'data')\r\n\t\t\tthis.resume()\r\n\r\n\t\treturn Stream.prototype.on.apply(this, arguments)\r\n\t},\r\n\r\n\tremoveListener(event, listener) {\r\n\t\tif(event == 'data') {\r\n\t\t\t//@TODO !!! this._listeners should be implemented\r\n\t\t\t//console.log(this.listeners)\r\n\t\t\tthis.pause()\r\n\t\t}\r\n\r\n\t\treturn Stream.prototype.removeListener.apply(this, arguments)\r\n\t},\r\n\r\n\tisPaused() {\r\n\t\treturn !this._readableState.flowing\r\n\t}\r\n}\r\n\r\nconst Readable = _extend({\r\n\tname: 'Readable',\r\n\tsuper: [Stream, _Readable],\r\n\tapply: [Stream, _named('Readable', _Readable)]\r\n})\r\n\r\nexport default Readable\r\n","import Stream from './stream'\r\nimport BufferState from './bufferState'\r\n\r\nfunction _readFromInternalBuffer(...args) {\r\n  const spliced = this._writableState.nodes(...args)\r\n\r\n  if(this._writableState.needDrain && (this._writableState.length < this.options.highWaterMark)) {\r\n    this._writableState.needDrain = false\r\n    this.emit('drain')\r\n  }\r\n\r\n  return spliced\r\n}\r\n\r\nfunction _flush() {\r\n  const { _writableState } = this\r\n\r\n  if(_writableState.corked)\r\n    return\r\n\r\n  if(!_writableState.length) {\r\n    if(_writableState.ended)\r\n      this.emit('finish')\r\n\r\n    return\r\n  }\r\n\r\n  const cb = err => {\r\n    if(err)\r\n      this.emit('error', err)\r\n\r\n    _writableState.consumed = true\r\n\r\n    process.nextTick(() => {\r\n      _flush.call(this)\r\n    })\r\n  }\r\n\r\n  if(!_writableState.corked && _writableState.consumed) {\r\n    _writableState.consumed = false\r\n\r\n    if(this._writev) {\r\n      const nodes = _readFromInternalBuffer.call(this)\r\n\r\n      this._writev(nodes, cb)\r\n    } else {\r\n      const node = _readFromInternalBuffer.call(this, 1)[0]\r\n\r\n      this._write(node.chunk, node.encoding, cb)\r\n    }\r\n  }\r\n}\r\n\r\nfunction _Writable(options = {}) {\r\n\tthis._write = options.write.bind(this)\r\n\r\n  this._writableState = new BufferState({\r\n    getBuffer: () => this._writableState._buffer,\r\n\r\n    corked: 0,\r\n    consumed: true,\r\n    needDrain: false,\r\n    ended: false,\r\n    decodeStrings: true\r\n  })\r\n}\r\n\r\n_Writable.prototype = {\r\n  write(chunk/*, encoding*/) {\r\n    const { _writableState } = this,\r\n          { buffer } = _writableState\r\n\r\n    if(_writableState.ended)\r\n      throw new Error('Write after end')\r\n\r\n    this._writableState.push(chunk)\r\n\r\n    _flush.call(this)\r\n\r\n    return _writableState.length < this.options.highWaterMark\r\n  },\r\n\r\n  end() {\r\n    this.write.apply(this, arguments)\r\n    this._writableState.ended = true\r\n    return this\r\n  },\r\n\r\n  cork() {\r\n    this._writableState.corked++\r\n  },\r\n\r\n  uncork() {\r\n    if(this._writableState.corked > 0) {\r\n      this._writableState.corked--\r\n      _flush.call(this)\r\n    }\r\n  }\r\n}\r\n\r\nconst Writable = _extend({\r\n\tname: 'Writable',\r\n  super: [Stream, _Writable],\r\n  apply: [Stream, _named('Writable', _Writable)]\r\n})\r\n\r\nexport default Writable\r\n","import Readable from './readable'\r\nimport Writable from './writable'\r\n\r\nfunction _Duplex(options = {}) {}\r\n\r\nconst Duplex = _extend({\r\n\tname: 'Duplex',\r\n  super: [Readable, Writable],\r\n  apply: [Readable, Writable, _named('Duplex', _Duplex)]\r\n})\r\n\r\nDuplex.prototype.on = function on() {\r\n  Readable.prototype.on.apply(this, arguments)\r\n  //Writable.prototype.on.apply(this, arguments)\r\n\r\n  return this\r\n}\r\n\r\nexport default Duplex\r\n","import Readable from './readable'\r\nimport Writable from './writable'\r\n\r\nfunction _Duplex(options = {}) {}\r\n\r\nconst Duplex = _extend({\r\n\tname: 'Duplex',\r\n  super: [Readable, Writable],\r\n  apply: [Readable, Writable, _named('Duplex', _Duplex)]\r\n})\r\n\r\nDuplex.prototype.on = function on() {\r\n  Readable.prototype.on.apply(this, arguments)\r\n  //Writable.prototype.on.apply(this, arguments)\r\n\r\n  return this\r\n}\r\n\r\nexport default Duplex\r\n","import Duplex from './Duplex'\r\n\r\nfunction _read(size) {\r\n  //console.log('_read()')\r\n  //dumb function\r\n}\r\n\r\nfunction _Transform(options = {}) {\r\n  Duplex.call(this, Object.assign({}, options, {\r\n    read: _read,\r\n    write: options.transform\r\n  }))\r\n}\r\n\r\nconst Transform = _extend({\r\n\tname: 'Transform',\r\n  super: [Duplex],\r\n  apply: [_named('Transform', _Transform)]\r\n})\r\n\r\nexport default Transform\r\n","import Transform from './transform'\r\n\r\nfunction _transform(data, encoding, cb) {\r\n  this.push(data, encoding)\r\n  cb()\r\n}\r\n\r\nfunction _PassThrough(options = {}) {\r\n  Transform.call(this, Object.assign({}, options, {\r\n    transform: _transform\r\n  }))\r\n}\r\n\r\nconst PassThrough = _extend({\r\n  name: 'PassThrough',\r\n  super: [Transform],\r\n  apply: [_PassThrough]\r\n})\r\n\r\nexport default PassThrough\r\n","import EventEmitter from 'events'\r\n\r\nfunction _Schedule() {\r\n  this.pending = Promise.resolve(null)\r\n}\r\n\r\n_Schedule.prototype = {\r\n  immediate(task) {\r\n    this.pending = Promise.all([\r\n      this.pending,\r\n      new Promise((done, fail) => {\r\n        task(done, fail)\r\n      }).catch(err => this.emit('error', err))\r\n    ])\r\n\r\n    return this\r\n  },\r\n\r\n  deferred(task) {\r\n    this.pending = this.pending\r\n      .then(r => new Promise((done, fail) => {\r\n        task(done, fail)\r\n      }))\r\n      .catch(err => this.emit('error', err))\r\n\r\n    return this\r\n  }\r\n}\r\n\r\nconst Schedule = _extend({\r\n  name: 'Schedule',\r\n  super: [EventEmitter, _named('Schedule', _Schedule)],\r\n  apply: [EventEmitter, _named('Schedule', _Schedule)]\r\n})\r\n\r\nexport default Schedule\r\n","export default function series(arr, cb, done) {\r\n  let i = 0\r\n  ;(function next(res) {\r\n    if (res !== undefined || i >= arr.length) {\r\n      done && done(res)\r\n    }\r\n    else {\r\n      setImmediate(() => cb(next, arr[i], i++, arr))\r\n    }\r\n  })()\r\n}\r\n","import { Writable } from 'stream'\r\nimport Schedule from 'schedule'\r\nimport series from 'series'\r\n\r\nfunction _parse(chunk, encoding, cb) {\r\n  const { incoming, watching, frame } = this._busState\r\n\r\n  let currentChunkIndex = 0,\r\n      currentIncomingWatcherIndex = 0,\r\n      incomingIndex = 0,\r\n      isEqual = false,\r\n      isChunkCorrupted = false\r\n\r\n  if(!watching.length) {\r\n    this.emit('error', new Error({\r\n      msg: 'Unexpected incoming data',\r\n      data: chunk\r\n    }))\r\n  }\r\n  else {\r\n    for(;currentChunkIndex < chunk.length; currentChunkIndex ++) {\r\n      frame.push(chunk[currentChunkIndex])\r\n\r\n      if(!incoming.length) {\r\n        for(let watchingIndex in watching) {\r\n          try {\r\n            incoming.push({\r\n              patterns: watching[watchingIndex].patterns,\r\n              callback: watching[watchingIndex].callback,\r\n              currentPattern: watching[watchingIndex].patterns[0] instanceof Function ? watching[watchingIndex].patterns[0]([]) : watching[watchingIndex].patterns[0],\r\n              arrayOffset: 0,\r\n              patternIndex: 0,\r\n              byteIndex: 0,\r\n              length: 0\r\n            })\r\n          } catch(err) {\r\n            this.emit('error', err)\r\n          }\r\n        }\r\n      }\r\n\r\n      for(incomingIndex = 0; incomingIndex < incoming.length;) {\r\n        const incomingI = incoming[incomingIndex],\r\n              expected = incomingI.currentPattern[incomingI.byteIndex]\r\n\r\n        if(expected === undefined || expected === chunk[currentChunkIndex]) {\r\n          isEqual = true\r\n\r\n          incomingI.byteIndex ++\r\n        }\r\n        else if(expected instanceof Array) {\r\n          isEqual = true\r\n\r\n          if(incomingI.arrayOffset <= 0 && expected[0] > 0) {\r\n            incomingI.arrayOffset = expected[0]\r\n          }\r\n\r\n          if(--incomingI.arrayOffset > 0) {\r\n            continue\r\n          }\r\n          else {\r\n            incomingI.byteIndex ++\r\n          }\r\n        }\r\n        else if(expected instanceof Function) {\r\n          try {\r\n            isEqual = !!expected.call(this, chunk[currentChunkIndex], incomingI.length, frame.slice(-incomingI.length - 1))\r\n            incomingI.byteIndex ++\r\n          } catch(err) {\r\n            this.emit('error', err)\r\n            isEqual = false\r\n          }\r\n        }\r\n        else {\r\n          isEqual = false\r\n        }\r\n\r\n        if(isEqual) {\r\n          incomingI.length ++\r\n\r\n          if(incomingI.byteIndex >= incomingI.currentPattern.length) {\r\n            if(++ incomingI.patternIndex >= incomingI.patterns.length) {\r\n              try {\r\n                incomingI.callback.call(\r\n                  this,\r\n                  frame.splice(-incomingI.length),\r\n                  incomingI.pattern\r\n                )\r\n              } catch(err) {\r\n                this.emit('error', err)\r\n              }\r\n\r\n              incoming.splice(0)\r\n              //break\r\n            }\r\n            else {\r\n              const nextPattern = incomingI.patterns[incomingI.patternIndex]\r\n              incomingI.byteIndex = 0\r\n              try {\r\n                if(nextPattern instanceof Function) {\r\n                  incomingI.currentPattern = nextPattern(frame.slice(-incomingI.length))\r\n                }\r\n                else {\r\n                  incomingI.currentPattern = nextPattern\r\n                }\r\n                incomingIndex ++\r\n              } catch(err) {\r\n                this.emit('error', err)\r\n                incoming.splice(incomingIndex, 1)\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            incomingIndex ++\r\n          }\r\n        }\r\n        else {\r\n          incoming.splice(incomingIndex, 1)\r\n        }\r\n      }\r\n\r\n      if(!incoming.length && frame.length) {\r\n        this.emit('error', {\r\n          msg: 'Unparsed chunk',\r\n          data: frame.splice(0)\r\n        })\r\n        /*\r\n        if(!isChunkCorrupted) {\r\n          isChunkCorrupted = true\r\n          setImmediate(() => {\r\n            isChunkCorrupted = false\r\n            this.emit('error', {\r\n              msg: 'Unparsed chunk',\r\n              data: frame.splice(0)\r\n            })\r\n          })\r\n        }*/\r\n      }\r\n    }\r\n  }\r\n\r\n  cb()\r\n}\r\n\r\nfunction _write(chunk, encoding, cb) {\r\n  const highWaterMark = this.options.highWaterMark\r\n\r\n  if(chunk.length > highWaterMark) {\r\n    const chunks = []\r\n    let subchunkIndex = 0\r\n\r\n    for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\r\n      const subchunk = chunk.slice(offset, offset += highWaterMark)\r\n      chunks.push(next => _parse.call(this, subchunk, encoding, next))\r\n    }\r\n\r\n    series(chunks, cb)\r\n  }\r\n  else {\r\n    _parse.apply(this, arguments)\r\n  }\r\n}\r\n\r\nfunction _Bus(options = {}) {\r\n  Writable.call(this, Object.assign({}, options, {\r\n    write: _write\r\n  }))\r\n\r\n  this._setup = options.setup.bind(this)\r\n\r\n  this._busState = {\r\n    watching: [],\r\n    incoming: [],\r\n    frame: [],\r\n    configured: false\r\n  }\r\n}\r\n\r\n_Bus.prototype = {\r\n  setup (...args) {\r\n    return this.deferred(slots => {\r\n      if(this._busState.configured)\r\n        return Promise.reject('already configured')\r\n\r\n      this._busState.configured = true\r\n      return this._setup(slots, ...args)\r\n    })\r\n  },\r\n\r\n  watch (patterns, callback) {\r\n    const watcher = {\r\n      patterns,\r\n      callback\r\n    }\r\n\r\n    this._busState.watching.push(watcher)\r\n\r\n    return watcher\r\n  },\r\n\r\n  unwatch (watcher) {\r\n    if(watcher) {\r\n      const index = this._busState.watching.indexOf(watcher)\r\n\r\n      if(index >= 0)\r\n        this._busState.watching.splice(index, 1)\r\n    } else {\r\n      this._busState.watching.splice(0)\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  /**\r\n    * @TODO - Proper unwatch(): delete all previously RXed watchers\r\n    */\r\n  rx(patterns, cb) {\r\n    const watcher = this.watch(patterns, frame => {\r\n      //this.unwatch(watcher)\r\n      const index = this._busState.watching.indexOf(watcher)\r\n\r\n      if(index >= 0)\r\n        this._busState.watching.splice(0, index + 1)\r\n\r\n      cb(frame)\r\n    })\r\n\r\n    return this\r\n  },\r\n\r\n  tx(binary, options = {}) {\r\n    return this.deferred(() => {\r\n      console.log('tx')\r\n      if('timeout' in options) {\r\n        return new Promise((done, fail) => {\r\n          setTimeout(() => {\r\n            this.write(binary)\r\n            done()\r\n          }, options.timeout)\r\n        })\r\n      }\r\n\r\n      this.write(binary)\r\n\r\n      return Promise.resolve()\r\n    })\r\n  },\r\n\r\n  reset () {\r\n    this._busState.frame.splice(0)\r\n    this._busState.incoming.splice(0)\r\n    return this\r\n  }\r\n}\r\n\r\nconst Bus = _extend({\r\n  name: 'Bus',\r\n  super: [Writable, Schedule, _Bus],\r\n  apply: [_Bus, Schedule]\r\n})\r\n\r\nexport default Bus\r\n","let status = false\r\nconst defaultInterval = 20\r\n\r\nfunction blink(mode) {\r\n  if(mode === undefined)\r\n    mode = !status\r\n\r\n  !mode\r\n    ? blink.stop()\r\n    : blink.start()\r\n\r\n  return !!status\r\n}\r\n\r\nblink.start = () => {\r\n  if(!status) {\r\n    status = true\r\n\r\n    blink.once(LED2, 20, function cb() {\r\n      if(status) {\r\n        setTimeout(() => blink.once(LED2, 20, cb), 980)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nblink.stop = () => {\r\n  if(status) {\r\n    status = false\r\n  }\r\n}\r\n\r\nblink.once = (led, on = 20, cb) => {\r\n  led.write(true)\r\n  setTimeout(() => {\r\n    led.write(false)\r\n    cb && cb()\r\n  }, on)\r\n}\r\n\r\nexport default blink\r\n","import Bus from 'bus'\r\nimport blink from 'blink'\r\nimport { command, ack, nack, info, xinfo, err } from 'nfc'\r\nimport {\r\n  PN532_COMMAND_SAMCONFIGURATION,\r\n  PN532_SAM_NORMAL_MODE,\r\n  PN532_COMMAND_WRITEGPIO,\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  PN532_COMMAND_GETFIRMWAREVERSION,\r\n  PN532_WAKEUP,\r\n  MIFARE_CMD_READ,\r\n  MIFARE_CMD_AUTH_A,\r\n  MIFARE_CMD_AUTH_B,\r\n  MIFARE_CMD_WRITE_4,\r\n  MIFARE_CMD_WRITE_16\r\n} from 'nfc/constants'\r\n\r\nimport series from 'series'\r\n\r\nimport { encodeMessage, textRecord } from 'esp-ndef'\r\n\r\nblink()\r\n\r\nconst encoded = encodeMessage([\r\n  textRecord('2enhello world!')\r\n])\r\n\r\nconst wakeup = command([PN532_WAKEUP])\r\nconst sam = command([PN532_COMMAND_SAMCONFIGURATION, PN532_SAM_NORMAL_MODE, 20, 0])\r\n\r\n\r\n\r\n\r\nfunction setup(done) {\r\n  Serial1.setup(115200, {\r\n    rx: B7, tx: B6\r\n  })\r\n\r\n  Serial1.write(wakeup)\r\n  Serial1.write(sam)\r\n\r\n  setTimeout(() => {\r\n    Serial1.read()\r\n    Serial1.pipe(this)\r\n  }, 1500)\r\n\r\n  setTimeout(() => {\r\n    blink.once(LED1, 20, () => setTimeout(() => blink.once(LED1, 20), 200))\r\n\r\n    done()\r\n  }, 2000)\r\n}\r\n\r\nconst bus = new Bus({\r\n  setup, highWaterMark: 64\r\n})\r\n\r\nbus.on('error', console.error)\r\n\r\nbus.setup(Serial1)\r\n\r\nconst KEY = new Uint8ClampedArray([0xff, 0xff, 0xff, 0xff, 0xff, 0xff])\r\n\r\nlet afi = 0x00\r\n\r\n;(function poll() {\r\n  let uid,\r\n      block = 4,\r\n      data = null\r\n\r\n  bus.deferred(done => {\r\n    const LIST = command([\r\n      PN532_COMMAND_INLISTPASSIVETARGET,\r\n      1,\r\n      0\r\n    ])\r\n\r\n    bus.rx(ack, () => {\r\n      console.log('ACK')\r\n    })\r\n\r\n    bus.rx(info, frame => {\r\n      const body = frame.slice(7, 5 + frame[3]),\r\n            uidLength = body[5],\r\n            _uid = body.slice(6, 6 + uidLength)\r\n\r\n      console.log('FOUND', {\r\n        code: frame[6],\r\n        body,\r\n        count: body[0],\r\n        ATQA: body.slice(2, 4), // SENS_RES\r\n        SAK: body[4],\r\n        uidLength,\r\n        uid: _uid\r\n      }['ATQA'])\r\n\r\n      uid = _uid\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(LIST)\r\n  })\r\n\r\n  bus.deferred((done, fail) => {\r\n    const AUTH = command([\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_CMD_AUTH_A,\r\n      block\r\n    ].concat(KEY).concat(uid))\r\n\r\n    bus.rx(ack, ack => {})\r\n\r\n    bus.rx(err, fail)\r\n\r\n    bus.rx(info, frame => {\r\n      console.log('AUTH SUCCEED'/*, {\r\n        code: frame[6],\r\n        body: frame.slice(7, 5 + frame[3])\r\n      }*/)\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(AUTH)\r\n  })\r\n\r\n  bus.deferred((done, fail) => {\r\n    const WRITE = command([\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_CMD_WRITE_4,\r\n      block\r\n    ].concat(encoded))\r\n\r\n    bus.rx(ack, ack => {})\r\n\r\n    bus.rx(err, fail)\r\n\r\n    bus.rx(info, block => {\r\n      console.log('WRITE SUCCEED')\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(WRITE)\r\n  })\r\n\r\n  bus.deferred((done, fail) => {\r\n    const READ = command([\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_CMD_READ,\r\n      block\r\n    ])\r\n\r\n    bus.rx(ack, ack => {})\r\n\r\n    bus.rx(err, fail)\r\n\r\n    bus.rx(info, block => {\r\n      console.log(\"RED\", block)\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(READ)\r\n  })\r\n\r\n  bus.deferred(done => {\r\n    setTimeout(() => {\r\n      console.log(process.memory().free)\r\n      done()\r\n      poll()\r\n    }, 1000)\r\n  })\r\n})()\r\n","const PUSH_TO_QUEUE_IMMEDIATE = 0,\r\n      PUSH_AT_NEXT_STAGE = 1,\r\n      loop = [\r\n        // nextTick\r\n        { queue: [], immediatePush: true, tick: false },\r\n        // immediate\r\n        { queue: [], immediatePush: true, tick: false },\r\n        // timeout\r\n        { queue: [], immediatePush: false, tick: false }\r\n      ]\r\n\r\nlet tick = false,\r\n    timers = {}\r\n\r\nconst asyncFlush = () => {\r\n  for (let stage in loop) {\r\n    if(loop[stage].queue.length) {\r\n      if(loop[stage].immediatePush) {\r\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\r\n          loop[stage].queue[exec]()\r\n        }\r\n        loop[stage].queue.splice(0)\r\n      } else {\r\n        const queue = loop[stage].queue.splice(0)\r\n        for (let exec = 0; exec < queue.length; exec ++) {\r\n          queue[exec]()\r\n        }\r\n      }\r\n    }\r\n\r\n    loop[stage].tick = tick = false\r\n  }\r\n}\r\n\r\nconst asyncCall = stage => cb => {\r\n  loop[stage].queue.push(cb)\r\n\r\n  if (!tick && !loop[stage].tick) {\r\n    loop[stage].tick = tick = true\r\n\r\n    setTimeout(asyncFlush)\r\n  }\r\n}\r\n\r\nconst nextTick = asyncCall(/* .nextTick */0)\r\n\r\nconst setImmediate = asyncCall(/* .immediate */1)\r\n\r\nconst timeoutCall = asyncCall(/* .timeeout */2)\r\n\r\nexport const _setTimeout = (cb, timeout) => {\r\n  // let index = 0\r\n  // while(timers[index]) {\r\n  //   index++\r\n  // }\r\n  // timers[index] = setTimeout(() => {\r\n  //   if(timers[index]) {\r\n  //     delete timers[index]\r\n  //     timeoutCall(cb)\r\n  //   }\r\n  // }, timeout)\r\n  //\r\n  // return index\r\n\r\n  return setTimeout(() => {\r\n    timeoutCall(cb)\r\n  }, timeout)\r\n}\r\n\r\nexport const _setInterval = (cb, timeout) => {\r\n  return (function setTimer() {\r\n    return _setTimeout(() => {\r\n      setTimer()\r\n      cb()\r\n    }, timeout)\r\n  })()\r\n}\r\n\r\nexport {\r\n  nextTick,\r\n  setImmediate,\r\n  _setTimeout as setTimeout,\r\n  _setInterval as setInterval\r\n}\r\n","import { nextTick } from 'event-loop'\r\n\r\nconst _process = typeof process !== 'undefined' ? process : {}\r\n\r\n_process.nextTick = typeof _process.nextTick !== 'undefined' ? _process.nextTick : nextTick\r\n\r\nexport default _process\r\n","Object.assign = (target, ...args) => {\r\n  for(let obj of args) {\r\n    if(obj instanceof Object)\r\n      for(let key in obj) {\r\n        target[key] = obj[key]\r\n      }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\n//Object.freeze = obj => obj\r\n\r\nexport default Object\r\n","const defProp = (obj, prop, desc) => {\r\n  try {\r\n    Object.defineProperty(obj, prop, desc)\r\n    return obj\r\n  } catch(e) {\r\n    if(desc.get)\r\n      obj.value = desc.get()\r\n    else if(desc.value)\r\n      obj[prop] = desc.value\r\n\r\n    return obj\r\n  }\r\n}\r\n\r\nexport {\r\n  defProp\r\n}\r\n","export default (name, f) => {\r\n  defProp(f, 'name', { value: name })\r\n  //defProp(f, 'toString', { value: () => '[Function' + (f.name !== undefined ? ': ' + f.name : '') + ']' })\r\n\r\n  return f\r\n}\r\n","const SUPER_CHAIN_PROTO_PROP = '_super',\r\n  SUPER_CHAIN_APPLY_PROP = '_apply',\r\n  PROTOTYPE_IS_EXTENDED_PROP = '_isExtended'\r\n\r\nexport {\r\n  SUPER_CHAIN_PROTO_PROP,\r\n  SUPER_CHAIN_APPLY_PROP,\r\n  PROTOTYPE_IS_EXTENDED_PROP\r\n}\r\n","import {\r\n  SUPER_CHAIN_PROTO_PROP,\r\n  SUPER_CHAIN_APPLY_PROP,\r\n  PROTOTYPE_IS_EXTENDED_PROP\r\n} from './vars'\r\n\r\nconst _copyChain = (Extended, ProtoChain, chainPropName, ignoreExtended) => {\r\n  //if chain on [Extended] has not been created yet\r\n  if(!Extended.prototype[chainPropName])\r\n    defProp(Extended.prototype, chainPropName, { value: [] })\r\n\r\n  ProtoChain.forEach(Proto => {\r\n    //console.log(!!Proto.prototype['__extended__'], Proto)\r\n    //if [Proto] has been '__extended__' and has same-named proto chain, copy the Proto chain to Extended chain\r\n    const isExtended = !!Proto.prototype[PROTOTYPE_IS_EXTENDED_PROP],\r\n      hasSameChain = !!Proto.prototype[chainPropName]\r\n\r\n    const alreadyInChain = Extended.prototype[chainPropName].some(P => (P === Proto)),\r\n      shouldBePushed = (!isExtended || !ignoreExtended) && !alreadyInChain,\r\n      shouldCopyChain = isExtended && hasSameChain\r\n\r\n    if(shouldCopyChain)\r\n      Proto.prototype[chainPropName].forEach(Proto => {\r\n        //avoid pushing twice\r\n        if(!Extended.prototype[chainPropName].some(P => (P === Proto)) ) {\r\n          //console.log('pushed', Proto)\r\n          Extended.prototype[chainPropName].push(Proto)\r\n        }\r\n      })\r\n\r\n    if(shouldBePushed)\r\n      Extended.prototype[chainPropName].push(Proto)\r\n  })\r\n\r\n  //console.log(Extended.prototype[chainPropName])\r\n}\r\n\r\nconst _extend = (options = {}) => {\r\n  if(!options.apply)\r\n    options.apply = []\r\n  if(!options.super)\r\n    options.super = []\r\n  if(!options.static)\r\n    options.static = []\r\n\r\n  const Child = options.super[0]\r\n\r\n  if(!options.name)\r\n    options.name = Child.name\r\n\r\n  function Extended() {\r\n    Extended.prototype[SUPER_CHAIN_APPLY_PROP].forEach(Super => {\r\n      if(Super !== Extended) {\r\n        Super.apply(this, arguments)\r\n      }\r\n    })\r\n  }\r\n\r\n  _named(options.name, Extended)\r\n\r\n  for(let i in options.static) {\r\n    for(let prop in options.static[i]) {\r\n      if('prototype' != prop) {\r\n        defProp(Extended, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  defProp(Extended, 'prototype', { value: {} })\r\n  defProp(Extended.prototype, 'constructor', { value: Child })\r\n  defProp(Extended.prototype, PROTOTYPE_IS_EXTENDED_PROP, { value: true })\r\n\r\n  for(let i in options.super) {\r\n    function Proto() {}\r\n    Proto.prototype = options.super[i].prototype\r\n    const proto = new Proto()\r\n\r\n    for(let prop in proto) {\r\n      if(['constructor', PROTOTYPE_IS_EXTENDED_PROP, SUPER_CHAIN_PROTO_PROP, SUPER_CHAIN_APPLY_PROP].indexOf(prop) < 0) {\r\n        defProp(Extended.prototype, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  _copyChain(Extended, options.super, SUPER_CHAIN_PROTO_PROP, false)\r\n  _copyChain(Extended, options.apply, SUPER_CHAIN_APPLY_PROP, true)\r\n\r\n  return Extended\r\n}\r\n\r\nconst extend = (...args) => _extend({ super: args.slice(1), apply: args })\r\n\r\nexport { extend, _extend, _copyChain }\r\n","Array.prototype.concat = function () {\r\n  const concatenated = []\r\n\r\n  for(let i in this) {\r\n    concatenated.push(this[i])\r\n  }\r\n\r\n  for(let i in arguments) {\r\n    for(let j in arguments[i]) {\r\n      concatenated.push(arguments[i][j])\r\n    }\r\n  }\r\n\r\n  return concatenated\r\n}\r\n\r\nexport default Array\r\n","// var PENDING = 'pending'\r\n// var SEALED = 'sealed'\r\n// var FULFILLED = 'fulfilled'\r\n// var REJECTED = 'rejected'\r\n//\r\n// var NOOP = function() {}\r\n//\r\n// function invokeResolver(resolver, promise) {\r\n//   function resolvePromise(value) {\r\n//     resolve(promise, value)\r\n//   }\r\n//\r\n//   function rejectPromise(reason) {\r\n//     reject(promise, reason)\r\n//   }\r\n//\r\n//   try {\r\n//     resolver(resolvePromise, rejectPromise)\r\n//   } catch(e) {\r\n//     rejectPromise(e)\r\n//   }\r\n// }\r\n//\r\n// function invokeCallback(subscriber) {\r\n//   var owner = subscriber.owner\r\n//   var settled = owner.state_\r\n//   var value = owner.data_\r\n//   var callback = subscriber[settled]\r\n//   var promise = subscriber.then\r\n//\r\n//   if (typeof callback === 'function')\r\n//   {\r\n//     settled = FULFILLED\r\n//     try {\r\n//       value = callback(value)\r\n//     } catch(e) {\r\n//       reject(promise, e)\r\n//     }\r\n//   }\r\n//\r\n//   if (!handleThenable(promise, value))\r\n//   {\r\n//     if (settled === FULFILLED)\r\n//       resolve(promise, value)\r\n//\r\n//     if (settled === REJECTED)\r\n//       reject(promise, value)\r\n//   }\r\n// }\r\n//\r\n// function handleThenable(promise, value) {\r\n//   var resolved\r\n//\r\n//   try {\r\n//     if (promise === value)\r\n//       throw new TypeError('A promises callback cannot return that same promise.')\r\n//\r\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\r\n//     {\r\n//       var then = value.then  // then should be retrived only once\r\n//\r\n//       if (typeof then === 'function')\r\n//       {\r\n//         then.call(value, function(val){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             if (value !== val)\r\n//               resolve(promise, val)\r\n//             else\r\n//               fulfill(promise, val)\r\n//           }\r\n//         }, function(reason){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             reject(promise, reason)\r\n//           }\r\n//         })\r\n//\r\n//         return true\r\n//       }\r\n//     }\r\n//   } catch (e) {\r\n//     if (!resolved)\r\n//       reject(promise, e)\r\n//\r\n//     return true\r\n//   }\r\n//\r\n//   return false\r\n// }\r\n//\r\n// function resolve(promise, value){\r\n//   if (promise === value || !handleThenable(promise, value))\r\n//     fulfill(promise, value)\r\n// }\r\n//\r\n// function publish(promise) {\r\n//   var callbacks = promise.then_\r\n//   promise.then_ = undefined\r\n//\r\n//   for (var i = 0 i < callbacks.length i++) {\r\n//     invokeCallback(callbacks[i])\r\n//   }\r\n// }\r\n//\r\n// function fulfill(promise, value){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = value\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = FULFILLED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function reject(promise, reason){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = reason\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = REJECTED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function Promise(resolver) {\r\n//   if (typeof resolver !== 'function')\r\n//     throw new TypeError('Promise constructor takes a function argument')\r\n//\r\n//   if (this instanceof Promise === false)\r\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\r\n//\r\n//   this.then_ = []\r\n//\r\n//   invokeResolver(resolver, this)\r\n// }\r\n//\r\n// Promise.prototype = {\r\n//   constructor: Promise,\r\n//\r\n//   state_: PENDING,\r\n//   then_: null,\r\n//   data_: undefined,\r\n//\r\n//   then: function(onFulfillment, onRejection){\r\n//     var subscriber = {\r\n//       owner: this,\r\n//       then: new this.constructor(NOOP),\r\n//       fulfilled: onFulfillment,\r\n//       rejected: onRejection\r\n//     }\r\n//\r\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\r\n//     {\r\n//       // already resolved, call callback async\r\n//       setImmediate(() => {invokeCallback(subscriber)})\r\n//     }\r\n//     else\r\n//     {\r\n//       // subscribe\r\n//       this.then_.push(subscriber)\r\n//     }\r\n//\r\n//     return subscriber.then\r\n//   },\r\n//\r\n//   'catch': function(onRejection) {\r\n//     return this.then(null, onRejection)\r\n//   }\r\n// }\r\n//\r\n// Promise.all = function(promises){\r\n//   var Class = this\r\n//\r\n//   if (!(promises instanceof Array))\r\n//     throw new TypeError('You must pass an array to Promise.all().')\r\n//\r\n//   return new Class((resolve, reject) => {\r\n//     var results = []\r\n//     var remaining = 0\r\n//\r\n//     function resolver(index){\r\n//       remaining++\r\n//       return function(value){\r\n//         results[index] = value\r\n//         if (!--remaining)\r\n//           resolve(results)\r\n//       }\r\n//     }\r\n//\r\n//     for (var i = 0, promise i < promises.length i++)\r\n//     {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function')\r\n//         promise.then(resolver(i), reject)\r\n//       else\r\n//         results[i] = promise\r\n//     }\r\n//\r\n//     if (!remaining)\r\n//       resolve(results)\r\n//   })\r\n// }\r\n//\r\n// Promise.race = function(promises){\r\n//   var Class = this\r\n//\r\n//   if (!(promises instanceof Array))\r\n//     throw new TypeError('You must pass an array to Promise.race().')\r\n//\r\n//   return new Class((resolve, reject) => {\r\n//     for (var i = 0, promise i < promises.length i++)\r\n//     {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function')\r\n//         promise.then(resolve, reject)\r\n//       else\r\n//         resolve(promise)\r\n//     }\r\n//   })\r\n// }\r\n//\r\n// Promise.resolve = function(value) {\r\n//   var Class = this\r\n//\r\n//   if (value && typeof value === 'object' && value.constructor === Class)\r\n//     return value\r\n//\r\n//   return new Class(function(resolve){\r\n//     resolve(value)\r\n//   })\r\n// }\r\n//\r\n// Promise.reject = function(reason){\r\n//   var Class = this\r\n//\r\n//   return new Class(function(resolve, reject){\r\n//     reject(reason)\r\n//   })\r\n// }\r\n//\r\nif(!Promise.race) {\r\n  Promise.race = promises => {\r\n    if (!(promises instanceof Array))\r\n      throw new TypeError('You must pass an array to Promise.race().')\r\n\r\n    return new Promise((resolve, reject) => {\r\n      for (let i = 0, promise; i < promises.length; i ++) {\r\n        promise = promises[i]\r\n\r\n        promise && typeof promise.then === 'function'\r\n          ? promise.then(resolve, reject)\r\n          : resolve(promise)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport default Promise\r\n","import {\r\n  PN532_PREAMBLE,\r\n  PN532_STARTCODE1,\r\n  PN532_STARTCODE2,\r\n  PN532_HOST_TO_PN532,\r\n  PN532_PN532_TO_HOST,\r\n  PN532_POSTAMBLE\r\n} from './constants'\r\n\r\nconst check = values => 0x00 == 0xff & values.reduce((sum, value) => sum += value, 0x00)\r\n\r\nconst LCS_std = (byte, length, frame) => check(frame.slice(-2))\r\n\r\nconst LCS_ext = (byte, length, frame) => check([frame[5] * 256 + frame[6], frame[7]])\r\n\r\nconst CHECKSUM_std = (byte, length, frame) => check(frame.slice(5))\r\n\r\nconst CHECKSUM_ext = (byte, length, frame) => check(frame.slice(8))\r\n\r\nconst BODY_std = frame => {\r\n  const arr = []\r\n  for(let i = 0; i < frame[3] - 1; i ++)\r\n    arr.push(undefined)\r\n  return arr\r\n}\r\n\r\nconst BODY_ext = frame => {\r\n  const arr = [], length = frame[5] * 256 + frame[6]\r\n  for(let i = 0; i < length - 1; i ++)\r\n    arr.push(undefined)\r\n  return arr\r\n}\r\n\r\nexport const info = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, undefined, LCS_std, PN532_PN532_TO_HOST],\r\n  BODY_std,\r\n  [CHECKSUM_std, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const xinfo = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0xff, undefined, undefined, LCS_ext, PN532_PN532_TO_HOST],\r\n  BODY_ext,\r\n  [CHECKSUM_ext, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const err = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1 , PN532_STARTCODE2, 0x01, 0xff, undefined, CHECKSUM_std, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const ack = [\r\n  new Uint8ClampedArray([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x00, 0xff, PN532_POSTAMBLE])\r\n]\r\n\r\nexport const nack = [\r\n  new Uint8ClampedArray([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0x00, PN532_POSTAMBLE])\r\n]\r\n\r\n\r\nexport const command = command =>\r\n  new Uint8ClampedArray([\r\n    PN532_PREAMBLE,\r\n    PN532_STARTCODE1,\r\n    PN532_STARTCODE2,\r\n    0xff & (command.length + 1),\r\n    0xff & (~command.length),\r\n    PN532_HOST_TO_PN532,\r\n    ...command,\r\n    // checksum\r\n    ~(0xff & command.reduce((checksum, byte) => checksum += byte, 1 /** include PN532_HOST_TO_PN532 1 byte to length */)),\r\n    PN532_POSTAMBLE\r\n  ])\r\n","var data = { TNF_EMPTY: 0,\r\n  TNF_WELL_KNOWN: 1,\r\n  TNF_MIME_MEDIA: 2,\r\n  TNF_ABSOLUTE_URI: 3,\r\n  TNF_EXTERNAL_TYPE: 4,\r\n  TNF_UNKNOWN: 5,\r\n  TNF_UNCHANGED: 6,\r\n  TNF_RESERVED: 7,\r\n  RTD_TEXT: \"T\",\r\n  RTD_URI: \"U\",\r\n  RTD_SMART_POSTER: \"Sp\",\r\n  RTD_ALTERNATIVE_CARRIER: \"ac\",\r\n  RTD_HANDOVER_CARRIER: \"Hc\",\r\n  RTD_HANDOVER_REQUEST: \"Hr\",\r\n  RTD_HANDOVER_SELECT: \"Hs\",\r\n  BLOCK_SIZE: 16,\r\n  TLV_START: 64,\r\n  TL_LENGTH: 4 };\r\n\r\n/**\r\n  * decode text bytes from ndef record payload\r\n  *\r\n  * @returns a string\r\n  */\r\nvar decode = function decode(data) {\r\n    var languageCodeLength = data[0] & 0x3F,\r\n        // 6 LSBs\r\n    languageCode = data.slice(1, 1 + languageCodeLength),\r\n        utf16 = (data[0] & 0x80) !== 0; // assuming UTF-16BE\r\n\r\n    // TODO need to deal with UTF in the future\r\n    // console.log(\"lang \" + languageCode + (utf16 ? \" utf16\" : \" utf8\"))\r\n\r\n    return Buffer.from(data.slice(languageCodeLength + 1)).toString();\r\n};\r\n\r\n/**\r\n  * Encode text payload\r\n  *\r\n  * @returns an array of bytes\r\n  */\r\nvar encode = function encode(text, lang, encoding) {\r\n    // ISO/IANA language code, but we're not enforcing\r\n    if (!lang) {\r\n        lang = 'en';\r\n    }\r\n\r\n    var encoded = Buffer.from([lang.length].concat([].slice.call(Buffer.from(lang + text))));\r\n\r\n    return encoded;\r\n};\r\n\r\n// URI identifier codes from URI Record Type Definition NFCForum-TS-RTD_URI_1.0 2006-07-24\r\n// index in array matches code in the spec\r\nvar protocols = [\"\", \"http://www.\", \"https://www.\", \"http://\", \"https://\", \"tel:\", \"mailto:\", \"ftp://anonymous:anonymous@\", \"ftp://ftp.\", \"ftps://\", \"sftp://\", \"smb://\", \"nfs://\", \"ftp://\", \"dav://\", \"news:\", \"telnet://\", \"imap:\", \"rtsp://\", \"urn:\", \"pop:\", \"sip:\", \"sips:\", \"tftp:\", \"btspp://\", \"btl2cap://\", \"btgoep://\", \"tcpobex://\", \"irdaobex://\", \"file://\", \"urn:epc:id:\", \"urn:epc:tag:\", \"urn:epc:pat:\", \"urn:epc:raw:\", \"urn:epc:\", \"urn:nfc:\"];\r\n\r\n/**\r\n  * @returns a string\r\n  */\r\nvar decode$1 = function decode(data) {\r\n    var prefix = protocols[data[0]];\r\n    if (!prefix) {\r\n        // 36 to 255 should be \"\"\r\n        prefix = \"\";\r\n    }\r\n    return prefix + Buffer.from(data.slice(1)).toString();\r\n};\r\n\r\n/**\r\n  * shorten a URI with standard prefix\r\n  *\r\n  * @returns an array of bytes\r\n  */\r\nvar encode$1 = function encode(uri) {\r\n    var prefix, protocolCode, encoded;\r\n\r\n    // check each protocol, unless we've found a match\r\n    // \"urn:\" is the one exception where we need to keep checking\r\n    // slice so we don't check \"\"\r\n    protocols.slice(1).forEach(function (protocol) {\r\n        if ((!prefix || prefix === \"urn:\") && uri.indexOf(protocol) === 0) {\r\n            prefix = protocol;\r\n        }\r\n    });\r\n\r\n    if (!prefix) {\r\n        prefix = \"\";\r\n    }\r\n\r\n    protocolCode = protocols.indexOf(prefix);\r\n    encoded = Buffer.from([protocolCode].concat([].slice.call(Buffer.from(uri.slice(prefix.length)))));\r\n\r\n    return encoded;\r\n};\r\n\r\n// ndef.js\r\n// Copyright 2013 Don Coleman\r\n//\r\n// This code is from phonegap-nfc.js https://github.com/don/phonegap-nfc\r\n\r\n// see android.nfc.NdefRecord for documentation about constants\r\n// http://developer.android.com/reference/android/nfc/NdefRecord.html\r\n\r\n// convert bytes to a String\r\nvar s = function s(bytes) {\r\n  return Buffer.from(bytes).toString();\r\n};\r\n\r\n/**\r\n * Creates a JSON representation of a NDEF Record.\r\n *\r\n * @tnf 3-bit TNF (Type Name Format) - use one of the constants.TNF_* constants\r\n * @type byte array, containing zero to 255 bytes, must not be null\r\n * @id byte array, containing zero to 255 bytes, must not be null\r\n * @payload byte array, containing zero to (2 ** 32 - 1) bytes, must not be null\r\n *\r\n * @returns JSON representation of a NDEF record\r\n *\r\n * @see Ndef.textRecord, Ndef.uriRecord and Ndef.mimeMediaRecord for examples\r\n */\r\n\r\nvar record = function record(tnf, type, id, payload, value) {\r\n  if (!tnf) {\r\n    tnf = data.TNF_EMPTY;\r\n  }\r\n  if (!type) {\r\n    type = [];\r\n  }\r\n  if (!id) {\r\n    id = [];\r\n  }\r\n  if (!payload) {\r\n    payload = [];\r\n  }\r\n  // store type as String so it's easier to compare\r\n  if (type instanceof Array) {\r\n    type = Buffer.from(type).toString();\r\n  }\r\n\r\n  // in the future, id could be a String\r\n  if (!(id instanceof Array)) {\r\n    id = Buffer.from(id);\r\n  }\r\n\r\n  // Payload must be binary\r\n  if (!(payload instanceof Array)) {\r\n    payload = Buffer.from(payload);\r\n  }\r\n\r\n  // Experimental feature\r\n  // Convert payload to text for Text and URI records\r\n  if (tnf == data.TNF_WELL_KNOWN) {\r\n    if (type == data.RTD_TEXT) {\r\n      value = decode(payload);\r\n    } else if (type == data.RTD_URI) {\r\n      value = decode$1(payload);\r\n    }\r\n  }\r\n\r\n  return {\r\n    tnf: tnf,\r\n    type: type,\r\n    id: id,\r\n    payload: payload,\r\n    value: value\r\n  };\r\n};\r\n\r\n/**\r\n * Helper that creates an NDEF record containing plain text.\r\n *\r\n * @text String of text to encode\r\n * @languageCode ISO/IANA language code. Examples: fi, en-US, fr-CA, jp. (optional)\r\n * @id byte[] (optional)\r\n */\r\nvar textRecord = function textRecord(text, languageCode, id) {\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_TEXT, id || [], encode(text, languageCode));\r\n};\r\n\r\n/**\r\n * Helper that creates a NDEF record containing a URI.\r\n *\r\n * @uri String\r\n * @id byte[] (optional)\r\n */\r\nvar uriRecord = function uriRecord(uri, id) {\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_URI, id || [], encode$1(uri));\r\n};\r\n\r\n/**\r\n * Helper that creates a NDEF record containing an absolute URI.\r\n *\r\n * An Absolute URI record means the URI describes the payload of the record.\r\n *\r\n * For example a SOAP message could use \"http://schemas.xmlsoap.org/soap/envelope/\"\r\n * as the type and XML content for the payload.\r\n *\r\n * Absolute URI can also be used to write LaunchApp records for Windows.\r\n *\r\n * See 2.4.2 Payload Type of the NDEF Specification\r\n * http://www.nfc-forum.org/specs/spec_list#ndefts\r\n *\r\n * Note that by default, Android will open the URI defined in the type\r\n * field of an Absolute URI record (TNF=3) and ignore the payload.\r\n * BlackBerry and Windows do not open the browser for TNF=3.\r\n *\r\n * To write a URI as the payload use ndef.uriRecord(uri)\r\n *\r\n * @uri String\r\n * @payload byte[] or String\r\n * @id byte[] (optional)\r\n */\r\nvar absoluteUriRecord = function absoluteUriRecord(uri, payload, id) {\r\n  return record(data.TNF_ABSOLUTE_URI, uri, id || [], payload || []);\r\n};\r\n\r\n/**\r\n* Helper that creates a NDEF record containing an mimeMediaRecord.\r\n*\r\n* @mimeType String\r\n* @payload byte[]\r\n* @id byte[] (optional)\r\n*/\r\nvar mimeMediaRecord = function mimeMediaRecord(mimeType, payload, id) {\r\n  return record(data.TNF_MIME_MEDIA, mimeType, id || [], payload || []);\r\n};\r\n\r\n/**\r\n* Helper that creates an NDEF record containing an Smart Poster.\r\n*\r\n* @ndefRecords array of NDEF Records\r\n* @id byte[] (optional)\r\n*/\r\nvar smartPoster = function smartPoster(ndefRecords, id) {\r\n  var payload = [];\r\n\r\n  if (ndefRecords) {\r\n    // make sure we have an array of something like NDEF records before encoding\r\n    if (ndefRecords[0] instanceof Object && ndefRecords[0].hasOwnProperty('tnf')) {\r\n      payload = encodeMessage(ndefRecords);\r\n    } else {\r\n      // assume the caller has already encoded the NDEF records into a byte array\r\n      payload = ndefRecords;\r\n    }\r\n  } else {\r\n    //console.warn(\"WARNING: Expecting an array of NDEF records\")\r\n    throw new Error('Expecting an array of NDEF records');\r\n  }\r\n\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_SMART_POSTER, id, payload);\r\n};\r\n\r\n/**\r\n* Helper that creates an empty NDEF record.\r\n*\r\n*/\r\nvar emptyRecord = function emptyRecord() {\r\n  return record(data.TNF_EMPTY, [], [], []);\r\n};\r\n\r\n/**\r\n* Helper that creates an Android Application Record (AAR).\r\n* http://developer.android.com/guide/topics/connectivity/nfc/nfc.html#aar\r\n*\r\n*/\r\nvar androidApplicationRecord = function androidApplicationRecord(packageName) {\r\n  return record(data.TNF_EXTERNAL_TYPE, 'android.com:pkg', [], packageName);\r\n};\r\n\r\n/**\r\n* Encodes an NDEF Message into bytes that can be written to a NFC tag.\r\n*\r\n* @ndefRecords an Array of NDEF Records\r\n*\r\n* @returns byte array\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\r\nvar encodeMessage = function encodeMessage(ndefRecords) {\r\n  var encoded = [],\r\n      tnf_byte = void 0,\r\n      record_type = void 0,\r\n      payload_length = void 0,\r\n      id_length = void 0,\r\n      i = void 0,\r\n      mb = void 0,\r\n      me = void 0,\r\n      // messageBegin, messageEnd\r\n  cf = false,\r\n      // chunkFlag TODO implement\r\n  sr = void 0,\r\n      // boolean shortRecord\r\n  il = void 0; // boolean idLengthFieldIsPresent\r\n\r\n  for (i = 0; i < ndefRecords.length; i++) {\r\n    mb = i === 0;\r\n    me = i === ndefRecords.length - 1;\r\n    sr = ndefRecords[i].payload.length < 0xFF;\r\n    il = ndefRecords[i].id.length > 0;\r\n    tnf_byte = encodeTnf(mb, me, cf, sr, il, ndefRecords[i].tnf);\r\n    encoded.push(tnf_byte);\r\n\r\n    // type is stored as String, converting to bytes for storage\r\n    record_type = [].slice.call(Buffer.from(ndefRecords[i].type));\r\n    encoded.push(record_type.length);\r\n\r\n    if (sr) {\r\n      payload_length = ndefRecords[i].payload.length;\r\n      encoded.push(payload_length);\r\n    } else {\r\n      payload_length = ndefRecords[i].payload.length;\r\n      // 4 bytes\r\n      encoded.push(payload_length >> 24);\r\n      encoded.push(payload_length >> 16);\r\n      encoded.push(payload_length >> 8);\r\n      encoded.push(payload_length & 0xFF);\r\n    }\r\n\r\n    if (il) {\r\n      id_length = ndefRecords[i].id.length;\r\n      encoded.push(id_length);\r\n    }\r\n\r\n    encoded = encoded.concat(record_type);\r\n\r\n    if (il) {\r\n      encoded = encoded.concat(ndefRecords[i].id);\r\n    }\r\n\r\n    encoded = encoded.concat([].slice.call(ndefRecords[i].payload));\r\n  }\r\n\r\n  return encoded;\r\n};\r\n\r\n/**\r\n* Decodes an array bytes into an NDEF Message\r\n*\r\n* @bytes an array bytes read from a NFC tag\r\n*\r\n* @returns array of NDEF Records\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\r\nvar decodeMessage = function decodeMessage(_bytes) {\r\n  var bytes = _bytes.slice(0),\r\n      // clone since parsing is destructive\r\n  ndef_message = [],\r\n      tnf_byte = void 0,\r\n      header = void 0,\r\n      type_length = 0,\r\n      payload_length = 0,\r\n      id_length = 0,\r\n      record_type = [],\r\n      id = [],\r\n      payload = [];\r\n\r\n  while (bytes.length) {\r\n    tnf_byte = bytes.shift();\r\n    header = decodeTnf(tnf_byte);\r\n\r\n    type_length = bytes.shift();\r\n\r\n    if (header.sr) {\r\n      payload_length = bytes.shift();\r\n    } else {\r\n      // next 4 bytes are length\r\n      payload_length = (0xFF & bytes.shift()) << 24 | (0xFF & bytes.shift()) << 16 | (0xFF & bytes.shift()) << 8 | 0xFF & bytes.shift();\r\n    }\r\n\r\n    if (header.il) {\r\n      id_length = bytes.shift();\r\n    }\r\n\r\n    record_type = bytes.splice(0, type_length);\r\n    id = bytes.splice(0, id_length);\r\n    payload = bytes.splice(0, payload_length);\r\n\r\n    ndef_message.push(record(header.tnf, record_type, id, payload));\r\n\r\n    if (header.me) {\r\n      // last message\r\n      break;\r\n    }\r\n  }\r\n\r\n  return ndef_message;\r\n};\r\n\r\n/**\r\n* Decode the bit flags from a TNF Byte.\r\n*\r\n* @returns object with decoded data\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\r\nvar decodeTnf = function decodeTnf(tnf_byte) {\r\n  return {\r\n    mb: (tnf_byte & 0x80) !== 0,\r\n    me: (tnf_byte & 0x40) !== 0,\r\n    cf: (tnf_byte & 0x20) !== 0,\r\n    sr: (tnf_byte & 0x10) !== 0,\r\n    il: (tnf_byte & 0x8) !== 0,\r\n    tnf: tnf_byte & 0x7\r\n  };\r\n};\r\n\r\n/**\r\n* Encode NDEF bit flags into a TNF Byte.\r\n*\r\n* @returns tnf byte\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\r\nvar encodeTnf = function encodeTnf(mb, me, cf, sr, il, tnf, value) {\r\n  if (!value) {\r\n    value = tnf;\r\n  }\r\n\r\n  if (mb) {\r\n    value = value | 0x80;\r\n  }\r\n\r\n  if (me) {\r\n    value = value | 0x40;\r\n  }\r\n\r\n  // note if cf: me, mb, li must be false and tnf must be 0x6\r\n  if (cf) {\r\n    value = value | 0x20;\r\n  }\r\n\r\n  if (sr) {\r\n    value = value | 0x10;\r\n  }\r\n\r\n  if (il) {\r\n    value = value | 0x8;\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\n// TODO test with byte[] and string\r\nvar isType = function isType(record, tnf, type) {\r\n  return record.tnf === tnf ? s(record) === s(type) : false;\r\n};\r\n\r\n// export const tnfToString = (tnf, value = tnf) => {\r\n//   if(tnf == constants.TNF_EMPTY) {\r\n//     value = \"Empty\"\r\n//   }\r\n//   else if(constants.TNF_WELL_KNOWN) {\r\n//     value = \"Well Known\"\r\n//   }\r\n//   else if(constants.TNF_MIME_MEDIA) {\r\n//     value = \"Mime Media\"\r\n//   }\r\n//   else if(constants.TNF_ABSOLUTE_URI) {\r\n//     value = \"Absolute URI\"\r\n//   }\r\n//   else if(constants.TNF_EXTERNAL_TYPE) {\r\n//     value = \"External\"\r\n//   }\r\n//   else if(constants.TNF_UNKNOWN) {\r\n//     value = \"Unknown\"\r\n//   }\r\n//   else if(constants.TNF_UNCHANGED) {\r\n//     value = \"Unchanged\"\r\n//   }\r\n//   else if(constants.TNF_RESERVED) {\r\n//     value = \"Reserved\"\r\n//   }\r\n//   return value\r\n// }\r\n\r\n// Convert NDEF records and messages to strings\r\n// This works OK for demos, but real code proably needs\r\n// a custom implementation. It would be nice to make\r\n// smarter record objects that can print themselves\r\n// var stringifier = {\r\n//     stringify: function (data, separator) {\r\n//       if (Array.isArray(data)) {\r\n//         if (typeof data[0] === 'number') {\r\n//           // guessing this message bytes\r\n//           data = decodeMessage(data)\r\n//         }\r\n//\r\n//         return stringifier.printRecords(data, separator)\r\n//       } else {\r\n//         return stringifier.printRecord(data, separator)\r\n//       }\r\n//     },\r\n//\r\n//     // @message - NDEF Message (array of NDEF Records)\r\n//     // @separator - line separator, optional, defaults to \\n\r\n//     // @returns string with NDEF Message\r\n//     printRecords: function (message, separator) {\r\n//\r\n//         if(!separator) { separator = \"\\n\" }\r\n//         result = \"\"\r\n//\r\n//         // Print out the payload for each record\r\n//         message.forEach(function(record) {\r\n//             result += stringifier.printRecord(record, separator)\r\n//             result += separator\r\n//         })\r\n//\r\n//         return result.slice(0, (-1 * separator.length))\r\n//     },\r\n//\r\n//     // @record - NDEF Record\r\n//     // @separator - line separator, optional, defaults to \\n\r\n//     // @returns string with NDEF Record\r\n//     printRecord: function (record, separator) {\r\n//\r\n//         var result = \"\"\r\n//\r\n//         if(!separator) { separator = \"\\n\" }\r\n//\r\n//         switch(record.tnf) {\r\n//             case ndef.constants.TNF_EMPTY:\r\n//                 result += \"Empty Record\"\r\n//                 result += separator\r\n//                 break\r\n//             case ndef.constants.TNF_WELL_KNOWN:\r\n//                 result += stringifier.printWellKnown(record, separator)\r\n//                 break\r\n//             case ndef.constants.TNF_MIME_MEDIA:\r\n//                 result += \"MIME Media\"\r\n//                 result += separator\r\n//                 result += s(record.type)\r\n//                 result += separator\r\n//                 result += s(record.payload) // might be binary\r\n//                 break\r\n//             case ndef.constants.TNF_ABSOLUTE_URI:\r\n//                 result += \"Absolute URI\"\r\n//                 result += separator\r\n//                 result += s(record.type)    // the URI is the type\r\n//                 result += separator\r\n//                 result += s(record.payload) // might be binary\r\n//                 break\r\n//             case ndef.constants.TNF_EXTERNAL_TYPE:\r\n//                 // AAR contains strings, other types could\r\n//                 // contain binary data\r\n//                 result += \"External\"\r\n//                 result += separator\r\n//                 result += s(record.type)\r\n//                 result += separator\r\n//                 result += s(record.payload)\r\n//                 break\r\n//             default:\r\n//                 result += s(\"Can't process TNF \" + record.tnf)\r\n//         }\r\n//\r\n//         result += separator\r\n//         return result\r\n//     },\r\n//\r\n//     printWellKnown: function (record, separator) {\r\n//\r\n//         var result = \"\"\r\n//\r\n//         if (record.tnf !== ndef.constants.TNF_WELL_KNOWN) {\r\n//             return \"ERROR expecting TNF Well Known\"\r\n//         }\r\n//\r\n//         switch(record.type) {\r\n//             case ndef.constants.RTD_TEXT:\r\n//                 result += \"Text Record\"\r\n//                 result += separator\r\n//                 result += (ndef.text.decodePayload(record.payload))\r\n//                 break\r\n//             case ndef.constants.RTD_URI:\r\n//                 result += \"URI Record\"\r\n//                 result += separator\r\n//                 result += (ndef.uri.decodePayload(record.payload))\r\n//                 break\r\n//             case ndef.constants.RTD_SMART_POSTER:\r\n//                 result += \"Smart Poster\"\r\n//                 result += separator\r\n//                 // the payload of a smartposter is a NDEF message\r\n//                 result += stringifier.printRecords(ndef.decodeMessage(record.payload))\r\n//                 break\r\n//             default:\r\n//                 // attempt to display other types\r\n//                 result += record.type + \" Record\"\r\n//                 result += separator\r\n//                 result += s(record.payload)\r\n//         }\r\n//\r\n//         return result\r\n//     }\r\n// }\r\n//\r\n// export const stringify = { stringifier }\r\n\r\nexport { data as constants, record, textRecord, uriRecord, absoluteUriRecord, mimeMediaRecord, smartPoster, emptyRecord, androidApplicationRecord, encodeMessage, decodeMessage, decodeTnf, encodeTnf, isType };\r\n"],"names":["time","label","Date","now","timeEnd","timers","log","toFixed","EventEmitter","this","_events","_maxListeners","undefined","isFunction","arg","isNumber","isObject","isUndefined","_Stream","options","highWaterMark","Buffer","Error","BufferState","assign","toString","binary","str","i","length","String","fromCharCode","_flow","_readableState","flowing","chunk","read","nextTick","_this","defaultEncoding","encodings","UTF8","emit","_end","ended","_Readable","BINARY","pipes","_read","bind","TypeError","Function","_readFromInternalBuffer","spliced","_writableState","nodes","needDrain","_flush","corked","cb","err","consumed","call","_writev","node","_write","encoding","_Writable","write","_this2","_buffer","_Duplex","size","_Transform","Object","transform","_transform","data","push","_PassThrough","_Schedule","pending","Promise","resolve","series","arr","done","next","res","_parse","_busState","incoming","watching","frame","currentChunkIndex","incomingIndex","isEqual","watchingIndex","patterns","callback","incomingI","expected","currentPattern","byteIndex","Array","arrayOffset","slice","patternIndex","splice","pattern","nextPattern","chunks","bytesLeft","offset","subchunk","apply","arguments","_Bus","_setup","setup","blink","mode","status","start","stop","B7","tx","B6","wakeup","sam","pipe","once","LED1","setTimeout","loop","queue","immediatePush","tick","asyncFlush","stage","exec","asyncCall","setImmediate","timeoutCall","_setTimeout","timeout","_process","process","console","error","target","args","obj","key","defProp","prop","desc","defineProperty","e","get","value","name","f","SUPER_CHAIN_PROTO_PROP","SUPER_CHAIN_APPLY_PROP","PROTOTYPE_IS_EXTENDED_PROP","_copyChain","Extended","ProtoChain","chainPropName","ignoreExtended","prototype","forEach","isExtended","Proto","hasSameChain","alreadyInChain","some","P","shouldBePushed","_extend","Super","super","static","Child","proto","indexOf","concat","concatenated","j","race","promises","reject","promise","then","defaultMaxListeners","setMaxListeners","n","isNaN","type","er","handler","len","listeners","context","addListener","listener","m","newListener","warned","trace","on","g","removeListener","fired","list","position","removeAllListeners","listenerCount","evlistener","emitter","Stream","_named","event","from","iterable","c","charCodeAt","array","totalLength","reduce","buffer","set","buf","unshift","count","index","nodeIndex","to","at","shift","overflow","writable","stopped","pause","resume","find","Readable","Writable","Duplex","Transform","PassThrough","task","all","fail","catch","Schedule","deferred","configured","slots","watcher","watch","_this3","Bus","LED2","led","check","values","sum","LCS_std","byte","CHECKSUM_std","BODY_std","info","PN532_PREAMBLE","PN532_STARTCODE1","PN532_STARTCODE2","PN532_PN532_TO_HOST","PN532_POSTAMBLE","ack","Uint8ClampedArray","command","PN532_HOST_TO_PN532","checksum","TNF_EMPTY","TNF_WELL_KNOWN","TNF_MIME_MEDIA","TNF_ABSOLUTE_URI","TNF_EXTERNAL_TYPE","TNF_UNKNOWN","TNF_UNCHANGED","TNF_RESERVED","RTD_TEXT","RTD_URI","RTD_SMART_POSTER","RTD_ALTERNATIVE_CARRIER","RTD_HANDOVER_CARRIER","RTD_HANDOVER_REQUEST","RTD_HANDOVER_SELECT","BLOCK_SIZE","TLV_START","TL_LENGTH","decode","languageCodeLength","encode","text","lang","protocols","decode$1","prefix","record","tnf","id","payload","textRecord","languageCode","encodeMessage","ndefRecords","encoded","tnf_byte","record_type","payload_length","id_length","mb","me","sr","il","encodeTnf","cf","PN532_WAKEUP","PN532_COMMAND_SAMCONFIGURATION","PN532_SAM_NORMAL_MODE","bus","Serial1","KEY","poll","uid","block","LIST","PN532_COMMAND_INLISTPASSIVETARGET","rx","body","uidLength","_uid","AUTH","PN532_COMMAND_INDATAEXCHANGE","MIFARE_CMD_AUTH_A","WRITE","MIFARE_CMD_WRITE_4","READ","MIFARE_CMD_READ","memory","free"],"mappings":"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"}