{"version":3,"file":"index.esp.min.js","sources":["../globals/buffer.js","../lib/stream/bufferState.js","../lib/bus.js","../globals/console.js","../globals/array.js","../globals/promise.js","../lib/Blink.js","../lib/nfc/index.js","../globals/object.js","../globals/event-loop.js","../lib/nfc/bus.js","../helpers/series.js","../node_modules/esp-ndef/dist/index.esm.js","../src/index.js"],"sourcesContent":["// import Uint8Array from './Uint8Array'\r\n// import { toBuffer } from './utils/to'\r\n\r\n// function copy(target) {\r\n// \tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\r\n// \t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\r\n// \t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\r\n//\r\n// \tlet copied = 0\r\n//\r\n// \tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\r\n// \t\ttarget.set([ this[sourceIndex] ], targetIndex)\r\n//\r\n// \treturn copied\r\n// }\r\n//\r\nfunction Buffer() {\r\n\tthrow new Error()\r\n}\r\n\r\n//Buffer.from = (iterable, offset, length) => E.toUint8Array(iterable)\r\n\r\nBuffer.from = (_iterable, _offset, _length) => {\r\n\tlet iterable = []\r\n\tif(typeof _iterable == 'string') {\r\n    for(let c in _iterable) {\r\n\t\t\titerable[c] = _iterable.charCodeAt(c)\r\n\t\t}\r\n  } else if(_iterable instanceof Uint8Array || _iterable instanceof Array) {\r\n\t\titerable = _iterable\r\n\t}\r\n\r\n\tconst offset = _offset !== undefined ? _offset : 0\r\n\tconst length = _length !== undefined ? _length : iterable.length\r\n\r\n\treturn new Uint8Array([...[].fill(0, 0, offset), ...[].slice.call(iterable, 0), ...[].fill(0, iterable.length + offset, length)])\r\n}\r\n\r\nBuffer.concat = (_list, _totalLength) => {\r\n\tconst list = _list || [],\r\n\t\t\t\ttotalLength = _totalLength !== undefined ? _totalLength : list.reduce((totalLength, array) => totalLength + array.length, 0),\r\n\t\t\t\tbuffer = Buffer.from([], 0, totalLength)\r\n\r\n\tlist.reduce((offset, buf) => {\r\n\t\tbuffer.set(buf, offset)\r\n\t\treturn offset + buf.length\r\n\t}, 0)\r\n\r\n\treturn buffer\r\n}\r\n\r\nexport default Buffer\r\n","function BufferState(options = {}) {\r\n  Object.assign(this, {\r\n\t\t_buffer: [],\r\n\t\tlength: 0\r\n\t}, options)\r\n}\r\n\r\nBufferState.prototype = {\r\n  push(chunk) {\r\n    if(chunk.length) {\r\n      const node = {\r\n    \t\tchunk: Buffer.from(chunk),\r\n        encoding: 'binary',\r\n    \t\tnext: null\r\n    \t}\r\n\r\n      if(this._buffer.length) {\r\n        this._buffer[this._buffer.length - 1].next = node\r\n      }\r\n\r\n      this._buffer.push(node)\r\n      this.length += node.chunk.length\r\n    }\r\n\r\n    return this.length\r\n  },\r\n\r\n  unshift(chunk) {\r\n    const node = {\r\n  \t\tchunk: Buffer.from(chunk),\r\n      encoding: 'binary',\r\n  \t\tnext: null\r\n  \t}\r\n\r\n    if(this._buffer.length) {\r\n      node.next = this._buffer[0]\r\n    }\r\n\r\n    this._buffer.unshift(node)\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  nodes(count) {\r\n    const nodes = this._buffer.splice(0, count)\r\n    nodes.forEach(node => this.length -= node.chunk.length)\r\n\r\n    return nodes\r\n  },\r\n\r\n  at(index) {\r\n    if(index >= this.length || index < 0) {\r\n      return\r\n    }\r\n\r\n    for(let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex ++) {\r\n      const chunk = this._buffer[nodeIndex].chunk\r\n      if(index < chunk.length) {\r\n        return {\r\n          index,\r\n          nodeIndex,\r\n          value: chunk[index]\r\n        }\r\n      }\r\n\r\n      index -= chunk.length\r\n    }\r\n  },\r\n\r\n  for(from, to, callee) {\r\n    const firstNode = this._buffer[from.nodeIndex]\r\n    for(let index = from.nodeIndex; index < firstNode.chunk.length; index ++) {\r\n      callee.call(this, firstNode.chunk[index])\r\n    }\r\n\r\n    for(let nodeIndex = 1 + from.nodeIndex; nodeIndex < to.nodeIndex; nodeIndex ++) {\r\n      const node = this._buffer[nodeIndex]\r\n      for(let index = 0; index < node.chunk.length; index ++) {\r\n        callee.call(this, node.chunk[index])\r\n      }\r\n    }\r\n\r\n    if(from.nodeIndex < to.nodeIndex) {\r\n      const lastNode = this._buffer[to.nodeIndex]\r\n      for(let index = 0; index <= to.index; index ++) {\r\n        callee.call(this, lastNode.chunk[index])\r\n      }\r\n    }\r\n  },\r\n\r\n  slice(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      to = this.at(length)\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n\r\n    const buffer = Buffer.from([], 0, length)\r\n\r\n    const offset = this._buffer.slice(0, to.nodeIndex).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset + node.chunk.length\r\n    }, 0)\r\n\r\n    if(offset < length) {\r\n      const node = this._buffer[to.nodeIndex]\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n    }\r\n\r\n    return buffer\r\n  },\r\n\r\n  buffer(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      // console.time('at')\r\n      to = this.at(length)\r\n      // console.timeEnd('at')\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n    // console.time('from')\r\n    const buffer = Buffer.from([], 0, length)\r\n    // console.timeEnd('from')\r\n    // console.time('offset')\r\n\r\n    // console.timeEnd('buffer')\r\n    const offset = this.nodes(to.nodeIndex).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset + node.chunk.length\r\n    }, 0)\r\n    // console.timeEnd('offset')\r\n    if(offset < length) {\r\n      const node = this.nodes(1)[0]\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n      node.chunk = node.chunk.slice(length - offset)\r\n\r\n      this.unshift(node.chunk)\r\n    }\r\n\r\n    return buffer\r\n\r\n    // return from.nodeIndex == to.nodeIndex\r\n    //   ? this._buffer[from.nodeIndex].chunk.slice(from.index, to.index)\r\n    //   : Buffer.concat([\r\n    //       this._buffer[from.nodeIndex].chunk.slice(from.index),\r\n    //       ...this._buffer.slice(1 + from.nodeIndex, to.nodeIndex).map(node => node.chunk),\r\n    //       this._buffer[to.nodeIndex].chunk.slice(0, to.index)\r\n    //     ])\r\n  }\r\n}\r\n\r\nexport default BufferState\r\n","//import { Writable } from 'stream'\r\nimport BufferState from 'stream/bufferState'\r\n//import Schedule from 'schedule'\r\nimport series from 'series'\r\n\r\nconst DEFAULT_HIGHWATERMARK = 64\r\n// const defaultWatcher = {\r\n//   cache: {},\r\n//   currentPattern: null,\r\n//   arrayOffset: 0,\r\n//   patternIndex: 0,\r\n//   byteIndex: 0,\r\n//   length: 0,\r\n//   active: false\r\n// }\r\n\r\nfunction _resetWatcher( watcher ) {\r\n  watcher.currentPattern = null\r\n  watcher.arrayOffset =\r\n    watcher.patternIndex =\r\n    watcher.byteIndex =\r\n    watcher.length = 0\r\n  watcher.active = false\r\n  return watcher\r\n\r\n  // return Object.assign(watcher, defaultWatcher)\r\n}\r\n\r\nfunction _parse() {\r\n  const {\r\n    watching,\r\n    frame,\r\n    _buffer\r\n  } = this._busState\r\n\r\n  if ( !watching.length ) {\r\n    this.emit( 'error', {\r\n      msg: 'Unexpected watching data',\r\n      data: this._busState.buffer()\r\n    } )\r\n    return\r\n  }\r\n\r\n  if ( this._busState.nodeIndex < 0 ) {\r\n    this._busState.nodeIndex = 0\r\n  }\r\n\r\n  for ( ; this._busState.nodeIndex < _buffer.length; this._busState.nodeIndex++ ) {\r\n    const {\r\n      chunk\r\n    } = _buffer[ this._busState.nodeIndex ]\r\n    let currentChunkIndex = currentIncomingWatcherIndex = watcherIndex = 0,\r\n      isEqual = isChunkCorrupted = false\r\n\r\n    for ( ; currentChunkIndex < chunk.length; currentChunkIndex++ ) {\r\n      if ( !this._busState.active ) {\r\n        this._busState.active = this._busState.watching.reduce( ( active, watcher ) => {\r\n          const {\r\n            patterns\r\n          } = watcher\r\n          try {\r\n            watcher.currentPattern = typeof patterns[ 0 ] == 'function' ? patterns[ 0 ]( Buffer.from( [] ) ) : patterns[ 0 ],\r\n              watcher.active = true\r\n            return active + 1\r\n          } catch ( err ) {\r\n            this.emit( 'error', err )\r\n            return active\r\n          }\r\n        }, 0 )\r\n      }\r\n\r\n      const byte = chunk[ currentChunkIndex ]\r\n\r\n      for ( watcherIndex = 0; watcherIndex < watching.length; watcherIndex++, isEqual = false ) {\r\n        const watcher = watching[ watcherIndex ]\r\n\r\n        if ( !watcher.active ) {\r\n          continue\r\n        }\r\n\r\n        const expected = watcher.currentPattern[ watcher.byteIndex ]\r\n\r\n        // console.log('current watching:', watcher.currentPattern)\r\n        // console.log('current chunk:', chunk)\r\n        // console.log('byte:', byte)\r\n        // console.log('expected:', expected)\r\n\r\n        if ( expected === undefined || expected === byte ) {\r\n          isEqual = true\r\n        } else if ( Array.isArray( expected ) ) {\r\n          if ( watcher.arrayOffset <= 0 && expected[ 0 ] > 0 ) {\r\n            watcher.arrayOffset = expected[ 0 ]\r\n          }\r\n\r\n          if ( --watcher.arrayOffset > 0 ) {\r\n            watcher.length++\r\n              continue\r\n          }\r\n\r\n          isEqual = true\r\n        } else if ( typeof expected == 'function' ) {\r\n          try {\r\n            isEqual = !!expected.call( this, byte, watcher.length, this._busState.slice( 1 + watcher.length ) )\r\n          } catch ( err ) {\r\n            isEqual = false\r\n            this.emit( 'error', err )\r\n          }\r\n        }\r\n\r\n        if ( isEqual ) {\r\n          watcher.length++\r\n\r\n            if ( ++watcher.byteIndex >= watcher.currentPattern.length ) {\r\n              if ( ++watcher.patternIndex >= watcher.patterns.length ) {\r\n                console.time( 'buffer' )\r\n                // console.log(watcher.callback)\r\n                const chunk = this._busState.buffer( watcher.length )\r\n                console.timeEnd( 'buffer' )\r\n                this._busState.nodeIndex = -1\r\n                try {\r\n                  console.time( 'cb' )\r\n                  watcher.callback(\r\n                    chunk,\r\n                    // frame.splice(-watcher.length),\r\n                    watcher.pattern\r\n                  )\r\n                  console.timeEnd( 'cb' )\r\n                } catch ( err ) {\r\n                  this.emit( 'error', err )\r\n                }\r\n                // this._busState.watching = []\r\n                console.time( 'reset' )\r\n                watching.forEach( _resetWatcher )\r\n                this._busState.active = 0\r\n                console.timeEnd( 'reset' )\r\n              } else {\r\n                // console.time('next pattern')\r\n                const nextPattern = watcher.patterns[ watcher.patternIndex ]\r\n                watcher.byteIndex = 0\r\n\r\n                try {\r\n                  if ( typeof nextPattern == 'function' ) {\r\n                    watcher.currentPattern = nextPattern.call( this, this._busState.slice( watcher.length ) )\r\n                  } else {\r\n                    watcher.currentPattern = nextPattern\r\n                  }\r\n                } catch ( err ) {\r\n                  _resetWatcher( watcher )\r\n                  this._busState.active--\r\n\r\n                    this.emit( 'error', err )\r\n                }\r\n                // console.timeEnd('next pattern')\r\n              }\r\n            }\r\n        } else {\r\n          _resetWatcher( watcher )\r\n          this._busState.active--\r\n\r\n            if ( !watching.length && this._busState.length ) {\r\n              this.emit( 'error', {\r\n                msg: 'Unparsed chunk',\r\n                data: this._busState.buffer() // frame.splice(0)\r\n              } )\r\n              /*\r\n              if(!isChunkCorrupted) {\r\n                isChunkCorrupted = true\r\n                setImmediate(() => {\r\n                  isChunkCorrupted = false\r\n                  this.emit('error', {\r\n                    msg: 'Unparsed chunk',\r\n                    data: frame.splice(0)\r\n                  })\r\n                })\r\n              }*/\r\n            }\r\n        }\r\n\r\n        // console.timeEnd('isEqual')\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction _Bus( options = {} ) {\r\n  this._setup = options.setup.bind( this )\r\n  this._read = options.read.bind( this )\r\n  this._write = options.write.bind( this )\r\n\r\n  this.options = {\r\n    highWaterMark: options.highWaterMark || DEFAULT_HIGHWATERMARK\r\n  }\r\n\r\n  this._busState = new BufferState( {\r\n    watching: [],\r\n    active: 0,\r\n    nodeIndex: 0,\r\n    configured: false,\r\n    ticker: false\r\n  } )\r\n}\r\n\r\n_Bus.prototype = {\r\n  setup() {\r\n    if ( this._busState.configured ) {\r\n      return Promise.reject( 'already configured' )\r\n    }\r\n\r\n    this._busState.configured = true\r\n    return this._setup.apply( this, arguments )\r\n  },\r\n\r\n  parse( chunk ) {\r\n    this._busState.push( chunk )\r\n\r\n    if ( !this._busState.ticker ) {\r\n      this._busState.ticker = true\r\n      setImmediate( () => {\r\n        this._busState.ticker = false\r\n        _parse.call( this )\r\n      } )\r\n    }\r\n    // const highWaterMark = this.options.highWaterMark,\r\n    //       parse = _parse.bind(this)\r\n    //\r\n    // if(chunk.length > highWaterMark) {\r\n    //   const chunks = []\r\n    //   let subchunkIndex = 0\r\n    //\r\n    //   for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\r\n    //     const subchunk = chunk.slice(offset, offset += highWaterMark)\r\n    //     chunks.push(subchunk)\r\n    //   }\r\n    //\r\n    //   series(chunks, (next, subchunk) => {\r\n    //     parse(subchunk)\r\n    //     next()\r\n    //   })\r\n    // }\r\n    // else {\r\n    //   parse(chunk)\r\n    // }\r\n  },\r\n\r\n  watch( patterns, cb ) {\r\n    const watcher = _resetWatcher( {\r\n      patterns,\r\n      callback: cb.bind( this )\r\n    } )\r\n\r\n    this._busState.watching.push( watcher )\r\n\r\n    return watcher\r\n  },\r\n\r\n  unwatch( watcher ) {\r\n    if ( watcher ) {\r\n      const index = this._busState.watching.indexOf( watcher )\r\n\r\n      if ( index >= 0 ) {\r\n        this._busState.watching.splice( index, 1 )\r\n      }\r\n    } else {\r\n      this._busState.watching.splice( 0 )\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  /**\r\n    @TODO Promise interface\r\n  */\r\n\r\n  rx( patterns, cb ) {\r\n    const watcher = this.watch( patterns, cb )\r\n    this._read()\r\n    return watcher\r\n  },\r\n\r\n  tx( binary, options = {} ) {\r\n    if ( 'timeout' in options ) {\r\n      setTimeout( () => {\r\n        this._write( binary )\r\n      }, options.timeout )\r\n    } else {\r\n      this._write( binary )\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  reset() {\r\n    this._busState.watching.splice( 0 )\r\n    return this\r\n  }\r\n}\r\n\r\nexport default _Bus","if(typeof console.time !== 'function') {\r\n  const timers = {}\r\n\r\n  console.time = label => {\r\n    timers[label] = Date.now()\r\n  }\r\n\r\n  console.timeEnd = label => {\r\n    if(label in timers) {\r\n      console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\r\n      delete timers[label]\r\n    }\r\n  }\r\n}\r\n\r\nif(typeof console.error !== 'function') {\r\n  console.error = console.log\r\n}\r\n\r\nexport default console\r\n","Array.prototype.concat = function () {\r\n  const concatenated = []\r\n\r\n  for(let i in this) {\r\n    concatenated.push(this[i])\r\n  }\r\n\r\n  for(let i in arguments) {\r\n    for(let j in arguments[i]) {\r\n      concatenated.push(arguments[i][j])\r\n    }\r\n  }\r\n\r\n  return concatenated\r\n}\r\n\r\nexport default Array\r\n","// var PENDING = 'pending'\r\n// var SEALED = 'sealed'\r\n// var FULFILLED = 'fulfilled'\r\n// var REJECTED = 'rejected'\r\n//\r\n// var NOOP = function() {}\r\n//\r\n// function invokeResolver(resolver, promise) {\r\n//   function resolvePromise(value) {\r\n//     resolve(promise, value)\r\n//   }\r\n//\r\n//   function rejectPromise(reason) {\r\n//     reject(promise, reason)\r\n//   }\r\n//\r\n//   try {\r\n//     resolver(resolvePromise, rejectPromise)\r\n//   } catch(e) {\r\n//     rejectPromise(e)\r\n//   }\r\n// }\r\n//\r\n// function invokeCallback(subscriber) {\r\n//   var owner = subscriber.owner\r\n//   var settled = owner.state_\r\n//   var value = owner.data_\r\n//   var callback = subscriber[settled]\r\n//   var promise = subscriber.then\r\n//\r\n//   if (typeof callback === 'function')\r\n//   {\r\n//     settled = FULFILLED\r\n//     try {\r\n//       value = callback(value)\r\n//     } catch(e) {\r\n//       reject(promise, e)\r\n//     }\r\n//   }\r\n//\r\n//   if (!handleThenable(promise, value))\r\n//   {\r\n//     if (settled === FULFILLED)\r\n//       resolve(promise, value)\r\n//\r\n//     if (settled === REJECTED)\r\n//       reject(promise, value)\r\n//   }\r\n// }\r\n//\r\n// function handleThenable(promise, value) {\r\n//   var resolved\r\n//\r\n//   try {\r\n//     if (promise === value)\r\n//       throw new TypeError('A promises callback cannot return that same promise.')\r\n//\r\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\r\n//     {\r\n//       var then = value.then  // then should be retrived only once\r\n//\r\n//       if (typeof then === 'function')\r\n//       {\r\n//         then.call(value, function(val){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             if (value !== val)\r\n//               resolve(promise, val)\r\n//             else\r\n//               fulfill(promise, val)\r\n//           }\r\n//         }, function(reason){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             reject(promise, reason)\r\n//           }\r\n//         })\r\n//\r\n//         return true\r\n//       }\r\n//     }\r\n//   } catch (e) {\r\n//     if (!resolved)\r\n//       reject(promise, e)\r\n//\r\n//     return true\r\n//   }\r\n//\r\n//   return false\r\n// }\r\n//\r\n// function resolve(promise, value){\r\n//   if (promise === value || !handleThenable(promise, value))\r\n//     fulfill(promise, value)\r\n// }\r\n//\r\n// function publish(promise) {\r\n//   var callbacks = promise.then_\r\n//   promise.then_ = undefined\r\n//\r\n//   for (var i = 0 i < callbacks.length i++) {\r\n//     invokeCallback(callbacks[i])\r\n//   }\r\n// }\r\n//\r\n// function fulfill(promise, value){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = value\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = FULFILLED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function reject(promise, reason){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = reason\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = REJECTED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function Promise(resolver) {\r\n//   if (typeof resolver !== 'function')\r\n//     throw new TypeError('Promise constructor takes a function argument')\r\n//\r\n//   if (this instanceof Promise === false)\r\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\r\n//\r\n//   this.then_ = []\r\n//\r\n//   invokeResolver(resolver, this)\r\n// }\r\n//\r\n// Promise.prototype = {\r\n//   constructor: Promise,\r\n//\r\n//   state_: PENDING,\r\n//   then_: null,\r\n//   data_: undefined,\r\n//\r\n//   then: function(onFulfillment, onRejection){\r\n//     var subscriber = {\r\n//       owner: this,\r\n//       then: new this.constructor(NOOP),\r\n//       fulfilled: onFulfillment,\r\n//       rejected: onRejection\r\n//     }\r\n//\r\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\r\n//     {\r\n//       // already resolved, call callback async\r\n//       setImmediate(() => {invokeCallback(subscriber)})\r\n//     }\r\n//     else\r\n//     {\r\n//       // subscribe\r\n//       this.then_.push(subscriber)\r\n//     }\r\n//\r\n//     return subscriber.then\r\n//   },\r\n//\r\n//   'catch': function(onRejection) {\r\n//     return this.then(null, onRejection)\r\n//   }\r\n// }\r\n\r\n// Promise.all = function(promises) {\r\n//   if (!(promises instanceof Array)) {\r\n//     throw new TypeError('You must pass an array to Promise.all().')\r\n//   }\r\n//\r\n//   return new Promise((resolve, reject) => {\r\n//     var results = []\r\n//     var remaining = 0\r\n//\r\n//     function resolver(index) {\r\n//       remaining++\r\n//       return function(value) {\r\n//         results[index] = value\r\n//         if (!--remaining) {\r\n//           resolve(results)\r\n//         }\r\n//       }\r\n//     }\r\n//\r\n//     for (var i = 0, promise; i < promises.length; i++) {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function') {\r\n//         promise.then(resolver(i), reject)\r\n//       }\r\n//       else {\r\n//         results[i] = promise\r\n//       }\r\n//     }\r\n//\r\n//     if (!remaining) {\r\n//       resolve(results)\r\n//     }\r\n//   })\r\n// }\r\n\r\nPromise.race = function(promises){\r\n  var Class = this\r\n\r\n  if (!(promises instanceof Array))\r\n    throw new TypeError('You must pass an array to Promise.race().')\r\n\r\n  return new Class((resolve, reject) => {\r\n    for (var i = 0, promise; i < promises.length; i++)\r\n    {\r\n      promise = promises[i]\r\n\r\n      if (promise && typeof promise.then === 'function')\r\n        promise.then(resolve, reject)\r\n      else\r\n        resolve(promise)\r\n    }\r\n  })\r\n}\r\n\r\n// Promise.resolve = function(value) {\r\n//   var Class = this\r\n//\r\n//   if (value && typeof value === 'object' && value.constructor === Class)\r\n//     return value\r\n//\r\n//   return new Class(function(resolve){\r\n//     resolve(value)\r\n//   })\r\n// }\r\n//\r\n// Promise.reject = function(reason){\r\n//   var Class = this\r\n//\r\n//   return new Class(function(resolve, reject){\r\n//     reject(reason)\r\n//   })\r\n// }\r\n//\r\n\r\nexport default Promise\r\n","let status = false\r\nconst defaultInterval = 20\r\nconst defaultLed = LED2\r\n\r\nexport const once = ( led, on, cb ) => {\r\n  led.write( 1 )\r\n  setTimeout( () => {\r\n    led.write( 0 )\r\n    cb && cb()\r\n  }, on || defaultInterval )\r\n}\r\n\r\nexport const start = led => {\r\n  if ( !led ) {\r\n    led = defaultLed\r\n  }\r\n  if ( !status ) {\r\n    status = true\r\n\r\n    once( led, defaultInterval, function cb() {\r\n      if ( status ) {\r\n        setTimeout( () => once( led, defaultInterval, cb ), 1000 - defaultInterval )\r\n      }\r\n    } )\r\n  }\r\n}\r\n\r\nexport const stop = () => {\r\n  if ( status ) {\r\n    status = false\r\n  }\r\n}\r\n","import {\r\n  PN532_PREAMBLE,\r\n  PN532_STARTCODE1,\r\n  PN532_STARTCODE2,\r\n  PN532_HOST_TO_PN532,\r\n  PN532_PN532_TO_HOST,\r\n  PN532_POSTAMBLE\r\n} from './constants'\r\n\r\nconst check = values => !(0xff & (-values.reduce((sum, value) => sum + value, 0)))\r\n\r\nconst LCS_std = (byte, length, frame) => check(frame.slice(-2))\r\n\r\nconst LCS_ext = (byte, length, frame) => check([frame[5] * 256 + frame[6], frame[7]])\r\n\r\nconst CHECKSUM_std = (byte, length, frame) => check(frame.slice(5))\r\n\r\nconst CHECKSUM_ext = (byte, length, frame) => check(frame.slice(8))\r\n\r\nconst BODY_std = frame => {\r\n  return [[frame[3] - 1]]\r\n}\r\n\r\nconst BODY_ext = frame => {\r\n  return [[256 * frame[5] + frame[6]]]\r\n}\r\n\r\nexport const INFO = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, undefined, LCS_std, PN532_PN532_TO_HOST],\r\n  BODY_std,\r\n  [CHECKSUM_std, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const XINFO = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0xff, undefined, undefined, LCS_ext, PN532_PN532_TO_HOST],\r\n  BODY_ext,\r\n  [CHECKSUM_ext, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const ERR = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1 , PN532_STARTCODE2, 0x01, 0xff, undefined, CHECKSUM_std, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const ACK = [\r\n  new Uint8ClampedArray([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x00, 0xff, PN532_POSTAMBLE])\r\n]\r\n\r\nexport const NACK = [\r\n  new Uint8ClampedArray([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0x00, PN532_POSTAMBLE])\r\n]\r\n\r\nexport const command = command =>\r\n  new Uint8ClampedArray([\r\n    PN532_PREAMBLE,\r\n    PN532_STARTCODE1,\r\n    PN532_STARTCODE2,\r\n    0xff & (command.length + 1),\r\n    0xff & (~command.length),\r\n    PN532_HOST_TO_PN532,\r\n    ...command,\r\n    // checksum\r\n    0xff & (-command.reduce((checksum, byte) => checksum + byte, PN532_HOST_TO_PN532)),\r\n    PN532_POSTAMBLE\r\n  ])\r\n","Object.assign = (target, ...args) => {\r\n  for(let i in args) {\r\n    const obj = args[i]\r\n    if(obj instanceof Object) {\r\n      for(let key in obj) {\r\n        target[key] = obj[key]\r\n      }\r\n    }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\nexport default Object\r\n","const PUSH_TO_QUEUE_IMMEDIATE = 0,\r\n      PUSH_AT_NEXT_STAGE = 1,\r\n      loop = [\r\n        // nextTick\r\n        { queue: [], immediatePush: true, tick: false },\r\n        // immediate\r\n        { queue: [], immediatePush: true, tick: false },\r\n        // timeout\r\n        { queue: [], immediatePush: false, tick: false }\r\n      ]\r\n\r\nlet tick = false,\r\n    timers = {}\r\n\r\nconst asyncFlush = () => {\r\n  for (let stage in loop) {\r\n    if(loop[stage].queue.length) {\r\n      if(loop[stage].immediatePush) {\r\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\r\n          loop[stage].queue[exec]()\r\n        }\r\n        loop[stage].queue.splice(0)\r\n      } else {\r\n        const queue = loop[stage].queue.splice(0)\r\n        for (let exec = 0; exec < queue.length; exec ++) {\r\n          queue[exec]()\r\n        }\r\n      }\r\n    }\r\n\r\n    loop[stage].tick = tick = false\r\n  }\r\n}\r\n\r\nconst asyncCall = stage => cb => {\r\n  loop[stage].queue.push(cb)\r\n\r\n  if (!tick && !loop[stage].tick) {\r\n    loop[stage].tick = tick = true\r\n\r\n    setTimeout(asyncFlush)\r\n  }\r\n}\r\n\r\nconst nextTick = asyncCall(/* .nextTick */0)\r\n\r\nconst setImmediate = asyncCall(/* .immediate */1)\r\n\r\nconst timeoutCall = asyncCall(/* .timeeout */2)\r\n\r\nexport const _setTimeout = (cb, timeout) => {\r\n  // let index = 0\r\n  // while(timers[index]) {\r\n  //   index++\r\n  // }\r\n  // timers[index] = setTimeout(() => {\r\n  //   if(timers[index]) {\r\n  //     delete timers[index]\r\n  //     timeoutCall(cb)\r\n  //   }\r\n  // }, timeout)\r\n  //\r\n  // return index\r\n\r\n  return setTimeout(() => {\r\n    timeoutCall(cb)\r\n  }, timeout)\r\n}\r\n\r\nexport const _setInterval = (cb, timeout) => {\r\n  return (function setTimer() {\r\n    return _setTimeout(() => {\r\n      setTimer()\r\n      cb()\r\n    }, timeout)\r\n  })()\r\n}\r\n\r\nexport {\r\n  nextTick,\r\n  setImmediate,\r\n  _setTimeout as setTimeout,\r\n  _setInterval as setInterval\r\n}\r\n","import Bus from 'bus'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  ERR,\r\n  INFO\r\n} from './'\r\nimport {\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_WRITE_16,\r\n  PN532_BRTY_ISO14443A,\r\n  PN532_BRTY_ISO14443B\r\n} from './constants'\r\n\r\nimport series from 'series'\r\n\r\nconst sliceAck = chunk => chunk.slice( ACK.length )\r\n\r\nconst parseInfo = chunk => {\r\n  return {\r\n    raw: chunk,\r\n    code: chunk[ 6 ],\r\n    body: Buffer.from( chunk.slice( 7, 5 + chunk[ 3 ] ) )\r\n  }\r\n}\r\n\r\nconst parseBlockData = data => {\r\n  if ( data.body.length == 1 ) {\r\n    throw {\r\n      cmd: data.code,\r\n      errCode: data.body[ 0 ]\r\n    }\r\n  } else {\r\n    return {\r\n      chunk: data.body.slice( 1 )\r\n    }\r\n  }\r\n}\r\n\r\nconst NfcBus = {\r\n  makeTransaction( cmd, info, parsers ) {\r\n    return new Promise( ( done, fail ) => {\r\n        // Don't be silly again - info frame refers to index from beginning, i.e. to ACK\r\n        // this.rx([...ACK, ...info], chunk => done((parsers || [sliceAck, parseInfo]).reduce((data, parse) => parse(data), chunk)))\r\n        this.rx( ACK, () => {\r\n          this.rx( info, chunk => done( ( parsers || [ parseInfo ] )\r\n            .reduce( ( data, parse ) => parse( data ), chunk ) ) )\r\n        } )\r\n\r\n        this.rx( NACK, fail )\r\n        this.rx( ERR, fail )\r\n\r\n        this.tx( command( cmd ) )\r\n      } )\r\n      .catch( err => {\r\n        this.unwatch()\r\n        throw err\r\n      } )\r\n      .then( data => {\r\n        this.unwatch()\r\n        return data\r\n      } )\r\n  },\r\n\r\n  findTargets( count, type ) {\r\n    if ( type == 'A' ) {\r\n      type = PN532_BRTY_ISO14443A\r\n    } else if ( type == 'B' ) {\r\n      type = PN532_BRTY_ISO14443B\r\n    } else {\r\n      throw new Error( 'Unknown ISO14443 type:', type )\r\n    }\r\n\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INLISTPASSIVETARGET,\r\n      count,\r\n      type\r\n    ], INFO, [ chunk => {\r\n      const body = chunk.slice( 7, 5 + chunk[ 3 ] )\r\n      const uid = body.slice( 6, 6 + body[ 5 ] )\r\n      return {\r\n        code: chunk[ 6 ],\r\n        body,\r\n        count: body[ 0 ],\r\n        atqa: body.slice( 2, 4 ), // SENS_RES\r\n        sak: body[ 4 ],\r\n        uid\r\n      }\r\n    } ] )\r\n  },\r\n\r\n  authenticate( block, uid, key ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_AUTH_A,\r\n      block,\r\n      ...[].slice.call( key ),\r\n      ...[].slice.call( uid )\r\n    ], INFO )\r\n  },\r\n\r\n  readBlock( block ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_READ_16,\r\n      block\r\n    ], INFO, [ parseInfo, parseBlockData ] )\r\n  },\r\n\r\n  writeBlock( block, chunk ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_WRITE_16,\r\n      block,\r\n      ...[].slice.call( chunk )\r\n    ], INFO )\r\n  },\r\n\r\n  readSector( sector ) {\r\n    return new Promise( ( done, fail ) => {\r\n      const readBlocksArr = []\r\n      for ( let block = sector * 4; block < sector * 4 + 3; block++ ) {\r\n        readBlocksArr.push( block )\r\n      }\r\n\r\n      series( readBlocksArr, ( next, block, index ) => {\r\n        this.readBlock( block )\r\n          .then( data => {\r\n            readBlocksArr[ index ] = data\r\n            next()\r\n          } )\r\n          .catch( err => {\r\n            console.log( '!!!' )\r\n            next( err )\r\n          } )\r\n      }, err => err ? fail( err ) : done( readBlocksArr ) )\r\n    } )\r\n  },\r\n\r\n  writeSector( start, chunk ) {\r\n\r\n  }\r\n}\r\n\r\nexport default options => Object.assign( new Bus( options ), NfcBus )","export default function series( arr, cb, done ) {\r\n  let i = 0\r\n  let aborted = false;\r\n  ( function next( res ) {\r\n    if ( !aborted ) {\r\n      if ( typeof res !== 'undefined' || i >= arr.length ) {\r\n        done && done( res )\r\n      } else {\r\n        setImmediate( () => {\r\n          try {\r\n            cb( next, arr[ i ], i++, arr )\r\n          } catch ( err ) {\r\n            next( err )\r\n            aborted = true\r\n          }\r\n        } )\r\n      }\r\n    }\r\n  } )()\r\n}\r\n","var data = { TNF_EMPTY: 0,\r\n  TNF_WELL_KNOWN: 1,\r\n  TNF_MIME_MEDIA: 2,\r\n  TNF_ABSOLUTE_URI: 3,\r\n  TNF_EXTERNAL_TYPE: 4,\r\n  TNF_UNKNOWN: 5,\r\n  TNF_UNCHANGED: 6,\r\n  TNF_RESERVED: 7,\r\n  RTD_TEXT: \"T\",\r\n  RTD_URI: \"U\",\r\n  RTD_SMART_POSTER: \"Sp\",\r\n  RTD_ALTERNATIVE_CARRIER: \"ac\",\r\n  RTD_HANDOVER_CARRIER: \"Hc\",\r\n  RTD_HANDOVER_REQUEST: \"Hr\",\r\n  RTD_HANDOVER_SELECT: \"Hs\",\r\n  BLOCK_SIZE: 16,\r\n  TLV_START: 64,\r\n  TL_LENGTH: 4 };\r\n\r\n/**\r\n  * decode text bytes from ndef record payload\r\n  *\r\n  * @returns a string\r\n  */\r\nvar decode = function decode(data) {\r\n    var languageCodeLength = data[0] & 0x3F,\r\n        // 6 LSBs\r\n    languageCode = data.slice(1, 1 + languageCodeLength),\r\n        utf16 = (data[0] & 0x80) !== 0; // assuming UTF-16BE\r\n\r\n    // TODO need to deal with UTF in the future\r\n    // console.log(\"lang \" + languageCode + (utf16 ? \" utf16\" : \" utf8\"))\r\n\r\n    return Buffer.from(data.slice(languageCodeLength + 1)).toString();\r\n};\r\n\r\n/**\r\n  * Encode text payload\r\n  *\r\n  * @returns an array of bytes\r\n  */\r\nvar encode = function encode(text, lang, encoding) {\r\n    // ISO/IANA language code, but we're not enforcing\r\n    if (!lang) {\r\n        lang = 'en';\r\n    }\r\n\r\n    var encoded = Buffer.from([lang.length].concat([].slice.call(Buffer.from(lang + text))));\r\n\r\n    return encoded;\r\n};\r\n\r\n// URI identifier codes from URI Record Type Definition NFCForum-TS-RTD_URI_1.0 2006-07-24\r\n// index in array matches code in the spec\r\nvar protocols = [\"\", \"http://www.\", \"https://www.\", \"http://\", \"https://\", \"tel:\", \"mailto:\", \"ftp://anonymous:anonymous@\", \"ftp://ftp.\", \"ftps://\", \"sftp://\", \"smb://\", \"nfs://\", \"ftp://\", \"dav://\", \"news:\", \"telnet://\", \"imap:\", \"rtsp://\", \"urn:\", \"pop:\", \"sip:\", \"sips:\", \"tftp:\", \"btspp://\", \"btl2cap://\", \"btgoep://\", \"tcpobex://\", \"irdaobex://\", \"file://\", \"urn:epc:id:\", \"urn:epc:tag:\", \"urn:epc:pat:\", \"urn:epc:raw:\", \"urn:epc:\", \"urn:nfc:\"];\r\n\r\n/**\r\n  * @returns a string\r\n  */\r\nvar decode$1 = function decode(data) {\r\n    var prefix = protocols[data[0]];\r\n    if (!prefix) {\r\n        // 36 to 255 should be \"\"\r\n        prefix = \"\";\r\n    }\r\n    return prefix + Buffer.from(data.slice(1)).toString();\r\n};\r\n\r\n/**\r\n  * shorten a URI with standard prefix\r\n  *\r\n  * @returns an array of bytes\r\n  */\r\nvar encode$1 = function encode(uri) {\r\n    var prefix, protocolCode, encoded;\r\n\r\n    // check each protocol, unless we've found a match\r\n    // \"urn:\" is the one exception where we need to keep checking\r\n    // slice so we don't check \"\"\r\n    protocols.slice(1).forEach(function (protocol) {\r\n        if ((!prefix || prefix === \"urn:\") && uri.indexOf(protocol) === 0) {\r\n            prefix = protocol;\r\n        }\r\n    });\r\n\r\n    if (!prefix) {\r\n        prefix = \"\";\r\n    }\r\n\r\n    protocolCode = protocols.indexOf(prefix);\r\n    encoded = Buffer.from([protocolCode].concat([].slice.call(Buffer.from(uri.slice(prefix.length)))));\r\n\r\n    return encoded;\r\n};\r\n\r\n// ndef.js\r\n// Copyright 2013 Don Coleman\r\n//\r\n// This code is from phonegap-nfc.js https://github.com/don/phonegap-nfc\r\n\r\n// see android.nfc.NdefRecord for documentation about constants\r\n// http://developer.android.com/reference/android/nfc/NdefRecord.html\r\n\r\n// convert bytes to a String\r\nvar s = function s(bytes) {\r\n  return Buffer.from(bytes).toString();\r\n};\r\n\r\n/**\r\n * Creates a JSON representation of a NDEF Record.\r\n *\r\n * @tnf 3-bit TNF (Type Name Format) - use one of the constants.TNF_* constants\r\n * @type byte array, containing zero to 255 bytes, must not be null\r\n * @id byte array, containing zero to 255 bytes, must not be null\r\n * @payload byte array, containing zero to (2 ** 32 - 1) bytes, must not be null\r\n *\r\n * @returns JSON representation of a NDEF record\r\n *\r\n * @see Ndef.textRecord, Ndef.uriRecord and Ndef.mimeMediaRecord for examples\r\n */\r\n\r\nvar record = function record(tnf, type, id, payload, value) {\r\n  if (!tnf) {\r\n    tnf = data.TNF_EMPTY;\r\n  }\r\n  if (!type) {\r\n    type = [];\r\n  }\r\n  if (!id) {\r\n    id = [];\r\n  }\r\n  if (!payload) {\r\n    payload = [];\r\n  }\r\n  // store type as String so it's easier to compare\r\n  if (type instanceof Array) {\r\n    type = Buffer.from(type).toString();\r\n  }\r\n\r\n  // in the future, id could be a String\r\n  if (!(id instanceof Array)) {\r\n    id = Buffer.from(id);\r\n  }\r\n\r\n  // Payload must be binary\r\n  if (!(payload instanceof Array)) {\r\n    payload = Buffer.from(payload);\r\n  }\r\n\r\n  // Experimental feature\r\n  // Convert payload to text for Text and URI records\r\n  if (tnf == data.TNF_WELL_KNOWN) {\r\n    if (type == data.RTD_TEXT) {\r\n      value = decode(payload);\r\n    } else if (type == data.RTD_URI) {\r\n      value = decode$1(payload);\r\n    }\r\n  }\r\n\r\n  return {\r\n    tnf: tnf,\r\n    type: type,\r\n    id: id,\r\n    payload: payload,\r\n    value: value\r\n  };\r\n};\r\n\r\n/**\r\n * Helper that creates an NDEF record containing plain text.\r\n *\r\n * @text String of text to encode\r\n * @languageCode ISO/IANA language code. Examples: “fi”, “en-US”, “fr-CA”, “jp”. (optional)\r\n * @id byte[] (optional)\r\n */\r\nvar textRecord = function textRecord(text, languageCode, id) {\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_TEXT, id || [], encode(text, languageCode));\r\n};\r\n\r\n/**\r\n * Helper that creates a NDEF record containing a URI.\r\n *\r\n * @uri String\r\n * @id byte[] (optional)\r\n */\r\nvar uriRecord = function uriRecord(uri, id) {\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_URI, id || [], encode$1(uri));\r\n};\r\n\r\n/**\r\n * Helper that creates a NDEF record containing an absolute URI.\r\n *\r\n * An Absolute URI record means the URI describes the payload of the record.\r\n *\r\n * For example a SOAP message could use \"http://schemas.xmlsoap.org/soap/envelope/\"\r\n * as the type and XML content for the payload.\r\n *\r\n * Absolute URI can also be used to write LaunchApp records for Windows.\r\n *\r\n * See 2.4.2 Payload Type of the NDEF Specification\r\n * http://www.nfc-forum.org/specs/spec_list#ndefts\r\n *\r\n * Note that by default, Android will open the URI defined in the type\r\n * field of an Absolute URI record (TNF=3) and ignore the payload.\r\n * BlackBerry and Windows do not open the browser for TNF=3.\r\n *\r\n * To write a URI as the payload use ndef.uriRecord(uri)\r\n *\r\n * @uri String\r\n * @payload byte[] or String\r\n * @id byte[] (optional)\r\n */\r\nvar absoluteUriRecord = function absoluteUriRecord(uri, payload, id) {\r\n  return record(data.TNF_ABSOLUTE_URI, uri, id || [], payload || []);\r\n};\r\n\r\n/**\r\n* Helper that creates a NDEF record containing an mimeMediaRecord.\r\n*\r\n* @mimeType String\r\n* @payload byte[]\r\n* @id byte[] (optional)\r\n*/\r\nvar mimeMediaRecord = function mimeMediaRecord(mimeType, payload, id) {\r\n  return record(data.TNF_MIME_MEDIA, mimeType, id || [], payload || []);\r\n};\r\n\r\n/**\r\n* Helper that creates an NDEF record containing an Smart Poster.\r\n*\r\n* @ndefRecords array of NDEF Records\r\n* @id byte[] (optional)\r\n*/\r\nvar smartPoster = function smartPoster(ndefRecords, id) {\r\n  var payload = [];\r\n\r\n  if (ndefRecords) {\r\n    // make sure we have an array of something like NDEF records before encoding\r\n    if (ndefRecords[0] instanceof Object && ndefRecords[0].hasOwnProperty('tnf')) {\r\n      payload = encodeMessage(ndefRecords);\r\n    } else {\r\n      // assume the caller has already encoded the NDEF records into a byte array\r\n      payload = ndefRecords;\r\n    }\r\n  } else {\r\n    //console.warn(\"WARNING: Expecting an array of NDEF records\")\r\n    throw new Error('Expecting an array of NDEF records');\r\n  }\r\n\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_SMART_POSTER, id, payload);\r\n};\r\n\r\n/**\r\n* Helper that creates an empty NDEF record.\r\n*\r\n*/\r\nvar emptyRecord = function emptyRecord() {\r\n  return record(data.TNF_EMPTY, [], [], []);\r\n};\r\n\r\n/**\r\n* Helper that creates an Android Application Record (AAR).\r\n* http://developer.android.com/guide/topics/connectivity/nfc/nfc.html#aar\r\n*\r\n*/\r\nvar androidApplicationRecord = function androidApplicationRecord(packageName) {\r\n  return record(data.TNF_EXTERNAL_TYPE, 'android.com:pkg', [], packageName);\r\n};\r\n\r\n/**\r\n* Encodes an NDEF Message into bytes that can be written to a NFC tag.\r\n*\r\n* @ndefRecords an Array of NDEF Records\r\n*\r\n* @returns byte array\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\r\nvar encodeMessage = function encodeMessage(ndefRecords) {\r\n  var encoded = [],\r\n      tnf_byte = void 0,\r\n      record_type = void 0,\r\n      payload_length = void 0,\r\n      id_length = void 0,\r\n      i = void 0,\r\n      mb = void 0,\r\n      me = void 0,\r\n      // messageBegin, messageEnd\r\n  cf = false,\r\n      // chunkFlag TODO implement\r\n  sr = void 0,\r\n      // boolean shortRecord\r\n  il = void 0; // boolean idLengthFieldIsPresent\r\n\r\n  for (i = 0; i < ndefRecords.length; i++) {\r\n    mb = i === 0;\r\n    me = i === ndefRecords.length - 1;\r\n    sr = ndefRecords[i].payload.length < 0xFF;\r\n    il = ndefRecords[i].id.length > 0;\r\n    tnf_byte = encodeTnf(mb, me, cf, sr, il, ndefRecords[i].tnf);\r\n    encoded.push(tnf_byte);\r\n\r\n    // type is stored as String, converting to bytes for storage\r\n    record_type = [].slice.call(Buffer.from(ndefRecords[i].type));\r\n    encoded.push(record_type.length);\r\n\r\n    if (sr) {\r\n      payload_length = ndefRecords[i].payload.length;\r\n      encoded.push(payload_length);\r\n    } else {\r\n      payload_length = ndefRecords[i].payload.length;\r\n      // 4 bytes\r\n      encoded.push(payload_length >> 24);\r\n      encoded.push(payload_length >> 16);\r\n      encoded.push(payload_length >> 8);\r\n      encoded.push(payload_length & 0xFF);\r\n    }\r\n\r\n    if (il) {\r\n      id_length = ndefRecords[i].id.length;\r\n      encoded.push(id_length);\r\n    }\r\n\r\n    encoded = encoded.concat(record_type);\r\n\r\n    if (il) {\r\n      encoded = encoded.concat(ndefRecords[i].id);\r\n    }\r\n\r\n    encoded = encoded.concat([].slice.call(ndefRecords[i].payload));\r\n  }\r\n\r\n  return encoded;\r\n};\r\n\r\n/**\r\n* Decodes an array bytes into an NDEF Message\r\n*\r\n* @bytes an array bytes read from a NFC tag\r\n*\r\n* @returns array of NDEF Records\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\r\nvar decodeMessage = function decodeMessage(_bytes) {\r\n  var bytes = _bytes.slice(0),\r\n      // clone since parsing is destructive\r\n  ndef_message = [],\r\n      tnf_byte = void 0,\r\n      header = void 0,\r\n      type_length = 0,\r\n      payload_length = 0,\r\n      id_length = 0,\r\n      record_type = [],\r\n      id = [],\r\n      payload = [];\r\n\r\n  while (bytes.length) {\r\n    tnf_byte = bytes.shift();\r\n    header = decodeTnf(tnf_byte);\r\n\r\n    type_length = bytes.shift();\r\n\r\n    if (header.sr) {\r\n      payload_length = bytes.shift();\r\n    } else {\r\n      // next 4 bytes are length\r\n      payload_length = (0xFF & bytes.shift()) << 24 | (0xFF & bytes.shift()) << 16 | (0xFF & bytes.shift()) << 8 | 0xFF & bytes.shift();\r\n    }\r\n\r\n    if (header.il) {\r\n      id_length = bytes.shift();\r\n    }\r\n\r\n    record_type = bytes.splice(0, type_length);\r\n    id = bytes.splice(0, id_length);\r\n    payload = bytes.splice(0, payload_length);\r\n\r\n    ndef_message.push(record(header.tnf, record_type, id, payload));\r\n\r\n    if (header.me) {\r\n      // last message\r\n      break;\r\n    }\r\n  }\r\n\r\n  return ndef_message;\r\n};\r\n\r\n/**\r\n* Decode the bit flags from a TNF Byte.\r\n*\r\n* @returns object with decoded data\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\r\nvar decodeTnf = function decodeTnf(tnf_byte) {\r\n  return {\r\n    mb: (tnf_byte & 0x80) !== 0,\r\n    me: (tnf_byte & 0x40) !== 0,\r\n    cf: (tnf_byte & 0x20) !== 0,\r\n    sr: (tnf_byte & 0x10) !== 0,\r\n    il: (tnf_byte & 0x8) !== 0,\r\n    tnf: tnf_byte & 0x7\r\n  };\r\n};\r\n\r\n/**\r\n* Encode NDEF bit flags into a TNF Byte.\r\n*\r\n* @returns tnf byte\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\r\nvar encodeTnf = function encodeTnf(mb, me, cf, sr, il, tnf, value) {\r\n  if (!value) {\r\n    value = tnf;\r\n  }\r\n\r\n  if (mb) {\r\n    value = value | 0x80;\r\n  }\r\n\r\n  if (me) {\r\n    value = value | 0x40;\r\n  }\r\n\r\n  // note if cf: me, mb, li must be false and tnf must be 0x6\r\n  if (cf) {\r\n    value = value | 0x20;\r\n  }\r\n\r\n  if (sr) {\r\n    value = value | 0x10;\r\n  }\r\n\r\n  if (il) {\r\n    value = value | 0x8;\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\n// TODO test with byte[] and string\r\nvar isType = function isType(record, tnf, type) {\r\n  return record.tnf === tnf ? s(record) === s(type) : false;\r\n};\r\n\r\n// export const tnfToString = (tnf, value = tnf) => {\r\n//   if(tnf == constants.TNF_EMPTY) {\r\n//     value = \"Empty\"\r\n//   }\r\n//   else if(constants.TNF_WELL_KNOWN) {\r\n//     value = \"Well Known\"\r\n//   }\r\n//   else if(constants.TNF_MIME_MEDIA) {\r\n//     value = \"Mime Media\"\r\n//   }\r\n//   else if(constants.TNF_ABSOLUTE_URI) {\r\n//     value = \"Absolute URI\"\r\n//   }\r\n//   else if(constants.TNF_EXTERNAL_TYPE) {\r\n//     value = \"External\"\r\n//   }\r\n//   else if(constants.TNF_UNKNOWN) {\r\n//     value = \"Unknown\"\r\n//   }\r\n//   else if(constants.TNF_UNCHANGED) {\r\n//     value = \"Unchanged\"\r\n//   }\r\n//   else if(constants.TNF_RESERVED) {\r\n//     value = \"Reserved\"\r\n//   }\r\n//   return value\r\n// }\r\n\r\n// Convert NDEF records and messages to strings\r\n// This works OK for demos, but real code proably needs\r\n// a custom implementation. It would be nice to make\r\n// smarter record objects that can print themselves\r\n// var stringifier = {\r\n//     stringify: function (data, separator) {\r\n//       if (Array.isArray(data)) {\r\n//         if (typeof data[0] === 'number') {\r\n//           // guessing this message bytes\r\n//           data = decodeMessage(data)\r\n//         }\r\n//\r\n//         return stringifier.printRecords(data, separator)\r\n//       } else {\r\n//         return stringifier.printRecord(data, separator)\r\n//       }\r\n//     },\r\n//\r\n//     // @message - NDEF Message (array of NDEF Records)\r\n//     // @separator - line separator, optional, defaults to \\n\r\n//     // @returns string with NDEF Message\r\n//     printRecords: function (message, separator) {\r\n//\r\n//         if(!separator) { separator = \"\\n\" }\r\n//         result = \"\"\r\n//\r\n//         // Print out the payload for each record\r\n//         message.forEach(function(record) {\r\n//             result += stringifier.printRecord(record, separator)\r\n//             result += separator\r\n//         })\r\n//\r\n//         return result.slice(0, (-1 * separator.length))\r\n//     },\r\n//\r\n//     // @record - NDEF Record\r\n//     // @separator - line separator, optional, defaults to \\n\r\n//     // @returns string with NDEF Record\r\n//     printRecord: function (record, separator) {\r\n//\r\n//         var result = \"\"\r\n//\r\n//         if(!separator) { separator = \"\\n\" }\r\n//\r\n//         switch(record.tnf) {\r\n//             case ndef.constants.TNF_EMPTY:\r\n//                 result += \"Empty Record\"\r\n//                 result += separator\r\n//                 break\r\n//             case ndef.constants.TNF_WELL_KNOWN:\r\n//                 result += stringifier.printWellKnown(record, separator)\r\n//                 break\r\n//             case ndef.constants.TNF_MIME_MEDIA:\r\n//                 result += \"MIME Media\"\r\n//                 result += separator\r\n//                 result += s(record.type)\r\n//                 result += separator\r\n//                 result += s(record.payload) // might be binary\r\n//                 break\r\n//             case ndef.constants.TNF_ABSOLUTE_URI:\r\n//                 result += \"Absolute URI\"\r\n//                 result += separator\r\n//                 result += s(record.type)    // the URI is the type\r\n//                 result += separator\r\n//                 result += s(record.payload) // might be binary\r\n//                 break\r\n//             case ndef.constants.TNF_EXTERNAL_TYPE:\r\n//                 // AAR contains strings, other types could\r\n//                 // contain binary data\r\n//                 result += \"External\"\r\n//                 result += separator\r\n//                 result += s(record.type)\r\n//                 result += separator\r\n//                 result += s(record.payload)\r\n//                 break\r\n//             default:\r\n//                 result += s(\"Can't process TNF \" + record.tnf)\r\n//         }\r\n//\r\n//         result += separator\r\n//         return result\r\n//     },\r\n//\r\n//     printWellKnown: function (record, separator) {\r\n//\r\n//         var result = \"\"\r\n//\r\n//         if (record.tnf !== ndef.constants.TNF_WELL_KNOWN) {\r\n//             return \"ERROR expecting TNF Well Known\"\r\n//         }\r\n//\r\n//         switch(record.type) {\r\n//             case ndef.constants.RTD_TEXT:\r\n//                 result += \"Text Record\"\r\n//                 result += separator\r\n//                 result += (ndef.text.decodePayload(record.payload))\r\n//                 break\r\n//             case ndef.constants.RTD_URI:\r\n//                 result += \"URI Record\"\r\n//                 result += separator\r\n//                 result += (ndef.uri.decodePayload(record.payload))\r\n//                 break\r\n//             case ndef.constants.RTD_SMART_POSTER:\r\n//                 result += \"Smart Poster\"\r\n//                 result += separator\r\n//                 // the payload of a smartposter is a NDEF message\r\n//                 result += stringifier.printRecords(ndef.decodeMessage(record.payload))\r\n//                 break\r\n//             default:\r\n//                 // attempt to display other types\r\n//                 result += record.type + \" Record\"\r\n//                 result += separator\r\n//                 result += s(record.payload)\r\n//         }\r\n//\r\n//         return result\r\n//     }\r\n// }\r\n//\r\n// export const stringify = { stringifier }\r\n\r\nexport { data as constants, record, textRecord, uriRecord, absoluteUriRecord, mimeMediaRecord, smartPoster, emptyRecord, androidApplicationRecord, encodeMessage, decodeMessage, decodeTnf, encodeTnf, isType };\r\n","// import Bus from 'bus'\r\n// import Schedule from 'schedule'\r\nimport * as Blink from 'Blink'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  INFO,\r\n  XINFO\r\n} from 'nfc'\r\nimport Bus from 'nfc/bus'\r\nimport {\r\n  PN532_COMMAND_SAMCONFIGURATION,\r\n  PN532_SAM_NORMAL_MODE,\r\n  PN532_COMMAND_WRITEGPIO,\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  PN532_COMMAND_GETFIRMWAREVERSION,\r\n  PN532_COMMAND_WAKEUP,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_AUTH_B,\r\n  MIFARE_COMMAND_WRITE_4,\r\n  MIFARE_COMMAND_WRITE_16\r\n} from 'nfc/constants'\r\n\r\nimport {\r\n  encodeMessage,\r\n  decodeMessage,\r\n  textRecord\r\n} from 'esp-ndef'\r\n\r\nlet usbConsole = true\r\nlet consoleBus = null\r\nlet log = ''\r\n\r\nfunction toggleConsole() {\r\n  usbConsole = !usbConsole\r\n  if ( usbConsole ) {\r\n    consoleBus = null\r\n    USB.removeAllListeners()\r\n  } else {\r\n    consoleBus = new Bus( {\r\n      setup() {\r\n        USB.on( 'data', this.parse.bind( this ) )\r\n      },\r\n      read() {},\r\n      write() {}\r\n    } )\r\n\r\n    consoleBus.watch( [ Buffer.from( '/on' ) ], () => {\r\n      LED1.write( 1 )\r\n      USB.write( '/on\\r\\n' )\r\n    } )\r\n\r\n    consoleBus.watch( [ Buffer.from( '/off' ) ], () => {\r\n      LED1.write( 0 )\r\n      USB.write( '/off\\r\\n' )\r\n    } )\r\n\r\n    consoleBus.on( 'error', err => {\r\n      Blink.once( LED1, 200 )\r\n    } )\r\n\r\n    consoleBus.setup()\r\n  }\r\n\r\n  usbConsole ?\r\n    USB.setConsole( false ) :\r\n    LoopbackA.setConsole( false )\r\n}\r\n\r\nsetWatch( toggleConsole, BTN1, {\r\n  repeat: true,\r\n  edge: 'rising',\r\n  debounce: 50\r\n} )\r\n\r\nBlink.start( LED2 )\r\n\r\nconst encoded = encodeMessage( [\r\n  textRecord( '2enhello world!' )\r\n] )\r\n\r\nconst wakeup = command( [ PN532_COMMAND_WAKEUP ] )\r\nconst sam = command( [ PN532_COMMAND_SAMCONFIGURATION, PN532_SAM_NORMAL_MODE, 20, 0 ] )\r\n\r\nfunction setup( done ) {\r\n  Serial1.setup( 115200, {\r\n    rx: B7,\r\n    tx: B6\r\n  } )\r\n\r\n  Serial1.write( wakeup )\r\n  Serial1.write( sam )\r\n\r\n  setTimeout( () => {\r\n    Serial1.read()\r\n    Serial1.on( 'data', data => bus.parse( data ) )\r\n    Blink.once( LED1, 20, () => setTimeout( () => Blink.once( LED1, 20 ), 200 ) )\r\n  }, 50 )\r\n}\r\n\r\nconst bus = new Bus( {\r\n  setup,\r\n  read() {},\r\n  write( chunk ) {\r\n    Serial1.write( chunk )\r\n  },\r\n  highWaterMark: 64\r\n} )\r\n\r\nbus.on( 'error', err => {\r\n  console.error( 'BusError:', err )\r\n} )\r\n\r\nbus.setup()\r\n\r\nconst key = new Uint8Array( [].fill( 0xff, 0, 6 ) )\r\n\r\nsetTimeout( () => {\r\n  ( function poll() {\r\n    // console.log(process.memory().free)\r\n    // console.log(bus._busState.watching.length)\r\n    Promise.resolve()\r\n      .then( () => bus.findTargets( 1, 'A' ) ) // .then(data => { console.log('found card', data.uid); return data })\r\n      .then( data => {\r\n        LED1.write( true )\r\n        return data\r\n      } )\r\n      // .then(data => bus.authenticate(4, data.uid, key).then(data => { console.log('auth op 4:', data) }).then(() => bus.authenticate(3, data.uid, key).then(data => { console.log('auth op:', data) })))\r\n      .then( data => bus.authenticate( 1 * 4, data.uid, key ) ) // .then(data => { console.log('auth', data) })\r\n      // .then(data => bus.writeBlock(4, [1, 3, 6, 4])).then(data => { console.log('write op:', data) })\r\n      // .then(data => { console.time('reading 2 sector'); return data })\r\n      .then( data => bus.readSector( 1 ) )\r\n      .then( data => {\r\n        LED1.write( false )\r\n        return data\r\n      } ) // .then(data => { console.log('sector 2:', data); return data })\r\n      .then( data => data.reduce( ( buffer, data ) => [ ...buffer, ...[].slice.call( data.chunk, 0 ) ], [] ) )\r\n      .then( console.log )\r\n      // .then(data => { console.timeEnd('reading 2 sector'); return data })\r\n      // .then(data => bus.readBlock(4)).then(data => { console.log('block 4:', data) })\r\n      // .then(data => bus.readBlock(5)).then(data => { console.log('block 5:', data) })\r\n      // .then(data => bus.readBlock(6)).then(data => { console.log('block 6:', data) })\r\n      // .then(data => bus.readBlock(7)).then(data => { console.log('block 7:', data) })\r\n      .catch( err => {\r\n        LED1.write( false )\r\n        console.error( 'Error:', err )\r\n      } )\r\n      .then( () => {\r\n        setTimeout( () => {\r\n          poll()\r\n        }, 500 )\r\n      } )\r\n  } )()\r\n}, 1000 )\r\n"],"names":["Buffer","Error","BufferState","options","assign","this","_resetWatcher","watcher","currentPattern","arrayOffset","patternIndex","byteIndex","length","active","_Bus","_setup","setup","bind","_read","read","_write","write","highWaterMark","DEFAULT_HIGHWATERMARK","_busState","console","time","timers","label","Date","now","timeEnd","log","toFixed","error","concat","concatenated","i","push","arguments","j","Promise","race","promises","Array","TypeError","resolve","reject","promise","then","from","_iterable","_offset","_length","iterable","c","charCodeAt","Uint8Array","offset","undefined","fill","slice","call","_list","_totalLength","list","totalLength","reduce","array","buffer","buf","set","status","defaultLed","LED2","once","led","on","cb","check","values","sum","value","CHECKSUM_std","byte","frame","INFO","PN532_PREAMBLE","PN532_STARTCODE1","PN532_STARTCODE2","ERR","ACK","Uint8ClampedArray","NACK","command","PN532_HOST_TO_PN532","checksum","Object","target","args","obj","key","loop","queue","immediatePush","tick","asyncFlush","stage","exec","splice","asyncCall","setImmediate","prototype","chunk","node","_buffer","next","unshift","count","nodes","forEach","_this","index","nodeIndex","to","callee","firstNode","lastNode","at","configured","apply","ticker","watching","currentChunkIndex","currentIncomingWatcherIndex","watcherIndex","isEqual","isChunkCorrupted","patterns","err","emit","expected","isArray","callback","pattern","nextPattern","indexOf","watch","binary","timeout","parseInfo","parseBlockData","data","body","code","NfcBus","cmd","info","parsers","done","fail","rx","parse","tx","catch","unwatch","type","makeTransaction","uid","block","PN532_COMMAND_INDATAEXCHANGE","MIFARE_COMMAND_AUTH_A","MIFARE_COMMAND_WRITE_16","sector","readBlocksArr","arr","aborted","res","readBlock","start","Bus","protocols","encodeTnf","mb","me","cf","sr","il","tnf","usbConsole","consoleBus","setWatch","removeAllListeners","LED1","USB","setConsole","LoopbackA","BTN1","Blink","ndefRecords","encoded","tnf_byte","record_type","payload_length","id_length","payload","id","encodeMessage","languageCodeLength","decode","prefix","decode$1","record","text","lang","encoding","encode","textRecord","wakeup","sam","bus","B7","B6","setTimeout","poll","findTargets","authenticate","readSector"],"mappings":"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"}