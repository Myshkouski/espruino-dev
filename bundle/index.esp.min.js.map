{"version":3,"file":"index.esp.min.js","sources":["../lib/events.js","../lib/buffer/index.js","../lib/stream/bufferState.js","../lib/stream/readable.js","../lib/stream/writable.js","../lib/stream/transform.js","../lib/stream/passthrough.js","../lib/schedule.js","../lib/bus/index.js","../lib/blink.js","../src/index.js","../polyfill/event-loop.js","../polyfill/process.js","../polyfill/console.js","../polyfill/object.js","../helpers/def.js","../helpers/namedFunc.js","../lib/vars.js","../lib/extend.js","../polyfill/array.js","../lib/stream/stream.js","../lib/stream/duplex.js","../lib/stream/Duplex.js","../lib/nfc/index.js","../lib/ndef/dist/index.esm.js"],"sourcesContent":["function EventEmitter() { }\r\n\r\n_named('EventEmitter', EventEmitter)\r\n\r\nEventEmitter.prototype.on = function on() {\r\n  Object.prototype.on.apply(this, arguments)\r\n\r\n  return this\r\n}\r\n\r\nEventEmitter.prototype.once = function once(event, listener) {\r\n  function _listener() {\r\n    this.removeListener(event, _listener)\r\n    return listener.apply(this, arguments)\r\n  }\r\n\r\n  return this.on(event, _listener)\r\n}\r\n\r\nexport default EventEmitter\r\n","import Proto from './proto'\r\nimport { toBuffer } from './utils/to'\r\n\r\nfunction copy(target) {\r\n\tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\r\n\t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\r\n\t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\r\n\r\n\tlet copied = 0\r\n\r\n\tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\r\n\t\ttarget.set([ this[sourceIndex] ], targetIndex)\r\n\r\n\treturn copied\r\n}\r\n\r\nfunction Buffer() {\r\n\tthrow new Error('Buffer constructor is deprecated. Use Buffer.from() instead.')\r\n}\r\n\r\nBuffer.from = function _createBuffer() {\r\n\t//console.log(arguments)\r\n\tlet iterable = []\r\n\tif(typeof arguments[0] === 'string') {\r\n    for(let c in arguments[0])\r\n  \t\titerable[c] = arguments[0].charCodeAt(c)\r\n\r\n  \titerable = new Proto(iterable)\r\n  }\r\n\r\n  else if(arguments[0] instanceof Proto || arguments[0] instanceof Array)\r\n\t\titerable = new Proto(arguments[0])\r\n\r\n\tconst offset = arguments[1] !== undefined ? arguments[1] : 0,\r\n\t\tlength = arguments[2] !== undefined ? arguments[2] : iterable.length\r\n\r\n\tconst array = []\r\n\r\n\tfor(let i = offset;i--;)\r\n\t\tarray[i] = 0\r\n\r\n\tfor(let i = 0; (i < iterable.length) && (i < length); i++)\r\n\t\tarray[offset + i] = iterable[i]\r\n\r\n\tfor(let i = array.length; i < length; i++)\r\n\t\tarray[i] = 0\r\n\r\n\tconst buffer = new Proto(array)\r\n\r\n\treturn buffer\r\n}\r\n\r\nBuffer.concat = function concat() {\r\n\tconst list = arguments[0] || [],\r\n\t\t\t\ttotalLength = arguments[1] !== undefined ? arguments[1] : list.reduce((totalLength, array) => (totalLength + array.length), 0),\r\n\t\t\t\tbuffer = Buffer.from([], 0, totalLength)\r\n\r\n\tlet offset = 0\r\n\r\n\tlist.forEach(buf => {\r\n\t\tbuffer.set(buf, offset)\r\n\t\toffset += buf.length\r\n\t})\r\n\r\n\treturn buffer\r\n}\r\n\r\nexport default Buffer\r\n","function BufferState(options = {}) {\r\n  Object.assign(this, {\r\n\t\t_buffer: [],\r\n\t\tlength: 0\r\n\t}, options)\r\n}\r\n\r\nBufferState.prototype = {\r\n  push(chunk) {\r\n    const node = {\r\n  \t\tchunk: Buffer.from(chunk),\r\n  \t\tnext: null\r\n  \t}\r\n\r\n    if(this._buffer.length) {\r\n      this._buffer[this._buffer.length - 1].next = node\r\n    }\r\n\r\n    this._buffer.push(node)\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  unshift(chunk) {\r\n    const node = {\r\n  \t\tchunk: Buffer.from(chunk),\r\n      encoding: 'binary',\r\n  \t\tnext: null\r\n  \t}\r\n\r\n    if(this._buffer.length) {\r\n      node.next = this._buffer[0]\r\n    }\r\n\r\n    this._buffer.unshift(node)\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  nodes(count) {\r\n    const nodes = this._buffer.splice(0, count)\r\n    nodes.forEach(node => this.length -= node.chunk.length)\r\n\r\n    return nodes\r\n  },\r\n\r\n  at(index) {\r\n    if(index >= this.length || index < 0) {\r\n      return\r\n    }\r\n\r\n    for(let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex ++) {\r\n      if(index < this._buffer[nodeIndex].chunk.length) {\r\n        return {\r\n          index,\r\n          nodeIndex\r\n        }\r\n      }\r\n\r\n      index -= this._buffer[nodeIndex].chunk.length\r\n    }\r\n  },\r\n\r\n  buffer(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!this.length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      to = this.at(length)\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n\r\n    const buffer = Buffer.from([], 0, length)\r\n\r\n    const offset = this.nodes(to.nodeIndex).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset += node.chunk.length\r\n    }, 0)\r\n\r\n    if(offset < length) {\r\n      const node = this.nodes(1).shift()\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n      node.chunk = node.chunk.slice(length - offset)\r\n\r\n      this.unshift(node)\r\n    }\r\n\r\n    return buffer\r\n\r\n    // return from.nodeIndex == to.nodeIndex\r\n    //   ? this._buffer[from.nodeIndex].chunk.slice(from.index, to.index)\r\n    //   : Buffer.concat([\r\n    //       this._buffer[from.nodeIndex].chunk.slice(from.index),\r\n    //       ...this._buffer.slice(1 + from.nodeIndex, to.nodeIndex).map(node => node.chunk),\r\n    //       this._buffer[to.nodeIndex].chunk.slice(0, to.index)\r\n    //     ])\r\n  }\r\n}\r\n\r\nexport default BufferState\r\n","import Stream from './stream'\r\nimport BufferState from './bufferState'\r\n\r\nconst encodings = {\r\n\tBINARY: 'binary',\r\n\tUTF8: 'utf8'\r\n}\r\n\r\nfunction toString(binary) {\r\n\tlet str = ''\r\n\tfor(let i = 0; i < binary.length; i++)\r\n\t\tstr += String.fromCharCode(binary[i])\r\n\treturn str\r\n}\r\n\r\nfunction _broadcast() {\r\n\tlet chunk = this.read()\r\n\tif(chunk && chunk.length) {\r\n\t\tprocess.nextTick(() => {\r\n\t\t\tif(this._readableState.defaultEncoding == encodings.UTF8) {\r\n\t\t\t\tchunk = toString(chunk)\r\n\t\t\t}\r\n\t\t\tthis.emit('data', chunk, this._readableState.defaultEncoding)\r\n\t\t})\r\n\t}\r\n}\r\n\r\nfunction _flow() {\r\n\tif(this._readableState.flowing)\r\n\t\t _broadcast.call(this)\r\n}\r\n\r\nfunction _end() {\r\n\tthis._readableState.flowing = null\r\n\tthis._readableState.ended = true\r\n\r\n}\r\n\r\nfunction _Readable(options = {}) {\r\n\tthis._readableState = new BufferState({\r\n\t\tflowing: null,\r\n\t\tended: false,\r\n\t\tdefaultEncoding: encodings.BINARY\r\n\t})\r\n\r\n\tthis.pipes = []\r\n\r\n\tthis._read = options.read.bind(this)\r\n\r\n\tif(!this._read)\r\n\t\tthrow new TypeError('_read() is not implemented')\r\n\tif(!this._read instanceof Function)\r\n\t\tthrow new TypeError('\\'options.read\\' should be a function, passed', typeof options.read)\r\n}\r\n\r\n_Readable.prototype = {\r\n\tpause() {\r\n\t\t//console.log('pause()')\r\n\t\tif(this._readableState.flowing !== false) {\r\n\t\t\tthis._readableState.flowing = false\r\n\t\t\tthis.emit('pause')\r\n\t\t}\r\n\r\n\t\treturn this\r\n\t},\r\n\r\n\tresume() {\r\n\t\tif(!this._readableState.flowing) {\r\n\t\t\tthis._readableState.flowing = true\r\n\t\t\tthis.emit('resume')\r\n\t\t\t_flow.call(this)\r\n\t\t}\r\n\r\n\t\treturn this\r\n\t},\r\n\r\n\tread(length) {\r\n\t\tif(length < 0) {\r\n\t\t\tthrow new Error('\"length\" must be more than 0')\r\n\t\t}\r\n\r\n\t\tif(!this._readableState.ended) {\r\n\t\t\tif(length === undefined) {\r\n\t\t\t\tif(this._readableState.length < this.options.highWaterMark) {\r\n\t\t\t\t\tthis._read(this.options.highWaterMark - this._readableState.length)\r\n\t\t\t\t}\r\n\t\t\t} else if(length > this._readableState.length) {\r\n\t\t \t\tthis._read(length - this._readableState.length)\r\n\t\t \t}\r\n\t\t}\r\n\r\n\t\tif(this._readableState.ended) {\r\n\t\t\tif(this._readableState.length) {\r\n\t\t\t\treturn this._readableState.buffer()\r\n\t\t\t}\r\n\r\n\t\t\treturn null\r\n\t\t}\r\n\r\n\t\tif(length !== undefined && this._readableState.length < length) {\r\n\t\t\treturn null\r\n\t\t}\r\n\r\n\t\treturn this._readableState.buffer(length)\r\n\t},\r\n\r\n\tpush(chunk) {\r\n\t\t//console.log('push(' + chunk + ')')\r\n\t\tif(chunk === null) {\r\n\t\t\t_end.call(this)\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\tconst overflow = this._readableState.push(chunk) > this.options.highWaterMark\r\n\r\n\t\tif(!overflow)\r\n\t\t\t_flow.call(this)\r\n\r\n\t\treturn !overflow\r\n\t},\r\n\r\n\tpipe(writable) {\r\n\t\tif(!this.pipes.some(pipe => { pipe.writable === writable }) ) {\r\n\t\t\tconst listener = (data, pipe) => {\r\n\t\t\t\tif(!writable.write(data)) {\r\n\t\t\t\t\tpipe.stopped = true\r\n\t\t\t\t\tthis.pause()\r\n\r\n\t\t\t\t\twritable.once('drain', () => { this.resume() })\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tconst pipe = { writable, listener, stopped: undefined }\r\n\r\n\t\t\tthis\r\n\t\t\t\t.on('data', data => { listener(data, pipe) })\r\n\t\t\t\t.pipes.push(pipe)\r\n\r\n\t\t\tif(writable instanceof Stream)\r\n\t\t\t\twritable.emit('pipe')\r\n\t\t}\r\n\r\n\t\treturn writable\r\n\t},\r\n\r\n\tunpipe(writable) {\r\n\t  if(writable) {\r\n\t    const pipe = this.pipes.find(pipe => { pipe.writable === writable })\r\n\r\n\t    if(pipe)\r\n\t      this.removeListener('data', pipe.listener)\r\n\t  }\r\n\r\n\t  else {\r\n\t    for(let { listener } of this.pipes)\r\n\t      this.removeListener(listener)\r\n\t    this.pipes.splice(0)\r\n\t  }\r\n\t},\r\n\r\n\ton(event, listener) {\r\n\t\tif(event == 'data')\r\n\t\t\tthis.resume()\r\n\r\n\t\treturn Stream.prototype.on.apply(this, arguments)\r\n\t},\r\n\r\n\tremoveListener(event, listener) {\r\n\t\tif(event == 'data') {\r\n\t\t\t//@TODO !!! this._listeners should be implemented\r\n\t\t\t//console.log(this.listeners)\r\n\t\t\tthis.pause()\r\n\t\t}\r\n\r\n\t\treturn Stream.prototype.removeListener.apply(this, arguments)\r\n\t},\r\n\r\n\tisPaused() {\r\n\t\treturn !this._readableState.flowing\r\n\t}\r\n}\r\n\r\nconst Readable = _extend({\r\n\tname: 'Readable',\r\n\tsuper: [Stream, _Readable],\r\n\tapply: [Stream, _named('Readable', _Readable)]\r\n})\r\n\r\nexport default Readable\r\n","import Stream from './stream'\r\nimport BufferState from './bufferState'\r\n\r\nfunction _readFromInternalBuffer(...args) {\r\n  const spliced = this._writableState.nodes(...args)\r\n\r\n  if(this._writableState.needDrain && (this._writableState.length < this.options.highWaterMark)) {\r\n    this._writableState.needDrain = false\r\n    this.emit('drain')\r\n  }\r\n\r\n  return spliced\r\n}\r\n\r\nfunction _flush() {\r\n  const { _writableState } = this\r\n\r\n  if(_writableState.corked)\r\n    return\r\n\r\n  if(!_writableState.length) {\r\n    if(_writableState.ended)\r\n      this.emit('finish')\r\n\r\n    return\r\n  }\r\n\r\n  const cb = err => {\r\n    if(err)\r\n      this.emit('error', err)\r\n\r\n    _writableState.consumed = true\r\n\r\n    process.nextTick(() => {\r\n      _flush.call(this)\r\n    })\r\n  }\r\n\r\n  if(!_writableState.corked && _writableState.consumed) {\r\n    _writableState.consumed = false\r\n\r\n    if(this._writev) {\r\n      const nodes = _readFromInternalBuffer.call(this)\r\n\r\n      this._writev(nodes, cb)\r\n    } else {\r\n      const node = _readFromInternalBuffer.call(this, 1)[0]\r\n\r\n      this._write(node.chunk, node.encoding, cb)\r\n    }\r\n  }\r\n}\r\n\r\nfunction _Writable(options = {}) {\r\n\tthis._write = options.write.bind(this)\r\n\r\n  this._writableState = new BufferState({\r\n    getBuffer: () => this._writableState._buffer,\r\n\r\n    corked: 0,\r\n    consumed: true,\r\n    needDrain: false,\r\n    ended: false,\r\n    decodeStrings: true\r\n  })\r\n}\r\n\r\n_Writable.prototype = {\r\n  write(chunk/*, encoding*/) {\r\n    const { _writableState } = this,\r\n          { buffer } = _writableState\r\n\r\n    if(_writableState.ended)\r\n      throw new Error('Write after end')\r\n\r\n    this._writableState.push(chunk)\r\n\r\n    _flush.call(this)\r\n\r\n    return _writableState.length < this.options.highWaterMark\r\n  },\r\n\r\n  end() {\r\n    this.write.apply(this, arguments)\r\n    this._writableState.ended = true\r\n    return this\r\n  },\r\n\r\n  cork() {\r\n    this._writableState.corked++\r\n  },\r\n\r\n  uncork() {\r\n    if(this._writableState.corked > 0) {\r\n      this._writableState.corked--\r\n      _flush.call(this)\r\n    }\r\n  }\r\n}\r\n\r\nconst Writable = _extend({\r\n\tname: 'Writable',\r\n  super: [Stream, _Writable],\r\n  apply: [Stream, _named('Writable', _Writable)]\r\n})\r\n\r\nexport default Writable\r\n","import Duplex from './Duplex'\r\n\r\nfunction _read(size) {\r\n  //console.log('_read()')\r\n  //dumb function\r\n}\r\n\r\nfunction _Transform(options = {}) {\r\n  Duplex.call(this, Object.assign({}, options, {\r\n    read: _read,\r\n    write: options.transform\r\n  }))\r\n}\r\n\r\nconst Transform = _extend({\r\n\tname: 'Transform',\r\n  super: [Duplex],\r\n  apply: [_named('Transform', _Transform)]\r\n})\r\n\r\nexport default Transform\r\n","import Transform from './transform'\r\n\r\nfunction _transform(data, encoding, cb) {\r\n  this.push(data, encoding)\r\n  cb()\r\n}\r\n\r\nfunction _PassThrough(options = {}) {\r\n  Transform.call(this, Object.assign({}, options, {\n    transform: _transform\n  }))\r\n}\r\n\r\nconst PassThrough = _extend({\r\n  name: 'PassThrough',\r\n  super: [Transform],\r\n  apply: [_PassThrough]\r\n})\r\n\r\nexport default PassThrough\r\n","import EventEmitter from 'events'\r\n\r\nfunction _Schedule() {\r\n  this.pending = Promise.resolve(null)\r\n}\r\n\r\n_Schedule.prototype = {\r\n  immediate(task) {\r\n    this.pending = Promise.all([\r\n      this.pending,\r\n      new Promise((done, fail) => {\r\n        task(done, fail)\r\n      }).catch(err => this.emit('error', err))\r\n    ])\r\n\r\n    return this\r\n  },\r\n\r\n  deferred(task) {\r\n    this.pending = this.pending\r\n      .then(r => new Promise((done, fail) => {\r\n        task(done, fail)\r\n      }))\r\n      .catch(err => this.emit('error', err))\r\n\r\n    return this\r\n  }\r\n}\r\n\r\nconst Schedule = _extend({\r\n  name: 'Schedule',\r\n  super: [EventEmitter, _named('Schedule', _Schedule)],\r\n  apply: [EventEmitter, _named('Schedule', _Schedule)]\r\n})\r\n\r\nexport default Schedule\r\n","import { Writable } from 'stream'\r\nimport Schedule from 'schedule'\r\n\r\nfunction _parse(chunk, encoding, cb) {\r\n  const { incoming, watching, frame } = this._busState\r\n\r\n  let currentChunkIndex = 0,\r\n      currentIncomingWatcherIndex = 0,\r\n      incomingIndex = 0,\r\n      isEqual = false,\r\n      isChunkCorrupted = false\r\n\r\n  if(!watching.length) {\r\n    this.emit('error', new Error({\r\n      msg: 'Unexpected incoming data',\r\n      data: chunk\r\n    }))\r\n  }\r\n  else {\r\n    for(;currentChunkIndex < chunk.length; currentChunkIndex ++) {\r\n      frame.push(chunk[currentChunkIndex])\r\n\r\n      if(!incoming.length) {\r\n        for(let watchingIndex in watching) {\r\n          try {\r\n            incoming.push({\r\n              patterns: watching[watchingIndex].patterns,\r\n              callback: watching[watchingIndex].callback,\r\n              currentPattern: watching[watchingIndex].patterns[0] instanceof Function ? watching[watchingIndex].patterns[0]([]) : watching[watchingIndex].patterns[0],\r\n              arrayOffset: 0,\r\n              patternIndex: 0,\r\n              byteIndex: 0,\r\n              length: 0\r\n            })\r\n          } catch(err) {\r\n            this.emit('error', err)\r\n          }\r\n        }\r\n      }\r\n\r\n      for(incomingIndex = 0; incomingIndex < incoming.length;) {\r\n        const incomingI = incoming[incomingIndex],\r\n              expected = incomingI.currentPattern[incomingI.byteIndex]\r\n\r\n        if(expected === undefined || expected === chunk[currentChunkIndex]) {\r\n          isEqual = true\r\n\r\n          incomingI.byteIndex ++\r\n        }\r\n        else if(expected instanceof Array) {\r\n          isEqual = true\r\n\r\n          if(incomingI.arrayOffset <= 0 && expected[0] > 0) {\r\n            incomingI.arrayOffset = expected[0]\r\n          }\r\n\r\n          if(--incomingI.arrayOffset > 0) {\r\n            continue\r\n          }\r\n          else {\r\n            incomingI.byteIndex ++\r\n          }\r\n        }\r\n        else if(expected instanceof Function) {\r\n          try {\r\n            isEqual = !!expected.call(this, chunk[currentChunkIndex], incomingI.length, frame.slice(-incomingI.length - 1))\r\n            incomingI.byteIndex ++\r\n          } catch(err) {\r\n            this.emit('error', err)\r\n            isEqual = false\r\n          }\r\n        }\r\n        else {\r\n          isEqual = false\r\n        }\r\n\r\n        if(isEqual) {\r\n          incomingI.length ++\r\n\r\n          if(incomingI.byteIndex >= incomingI.currentPattern.length) {\r\n            if(++ incomingI.patternIndex >= incomingI.patterns.length) {\r\n              try {\r\n                incomingI.callback.call(\r\n                  this,\r\n                  frame.splice(-incomingI.length),\r\n                  incomingI.pattern\r\n                )\r\n              } catch(err) {\r\n                this.emit('error', err)\r\n              }\r\n\r\n              incoming.splice(0)\r\n              //break\r\n            }\r\n            else {\r\n              const nextPattern = incomingI.patterns[incomingI.patternIndex]\r\n              incomingI.byteIndex = 0\r\n              try {\r\n                if(nextPattern instanceof Function) {\r\n                  incomingI.currentPattern = nextPattern(frame.slice(-incomingI.length))\r\n                }\r\n                else {\r\n                  incomingI.currentPattern = nextPattern\r\n                }\r\n                incomingIndex ++\r\n              } catch(err) {\r\n                this.emit('error', err)\r\n                incoming.splice(incomingIndex, 1)\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            incomingIndex ++\r\n          }\r\n        }\r\n        else {\r\n          incoming.splice(incomingIndex, 1)\r\n        }\r\n      }\r\n\r\n      if(!incoming.length && frame.length) {\r\n        this.emit('error', {\r\n          msg: 'Unparsed chunk',\r\n          data: frame.splice(0)\r\n        })\r\n        /*\r\n        if(!isChunkCorrupted) {\r\n          isChunkCorrupted = !0\r\n          setImmediate(() => {\r\n            isChunkCorrupted = !1\r\n            this.emit('error', {\r\n              msg: 'Unparsed chunk',\r\n              data: frame.splice(0)\r\n            })\r\n          })\r\n        }*/\r\n      }\r\n    }\r\n  }\r\n\r\n  cb()\r\n}\r\n\r\nfunction series(arr,done) {\r\n  let i = 0;\r\n  (function next(err) {\r\n    if (err !== undefined || i >= arr.length) {\r\n      done(err)\r\n    }\r\n    else {\r\n      setImmediate(() => arr[i++](next))\r\n    }\r\n  })();\r\n}\r\n\r\nfunction _write(chunk, encoding, cb) {\r\n  const highWaterMark = this.options.highWaterMark\r\n\r\n  if(chunk.length > highWaterMark) {\r\n    const chunks = []\r\n    let subchunkIndex = 0\r\n\r\n    for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\r\n      const subchunk = chunk.slice(offset, offset += highWaterMark)\r\n      chunks.push(next => _parse.call(this, subchunk, encoding, next))\r\n    }\r\n\r\n    series(chunks, cb)\r\n  }\r\n  else {\r\n    _parse.apply(this, arguments)\r\n  }\r\n}\r\n\r\nfunction _Bus(options = {}) {\r\n  Writable.call(this, Object.assign({}, options, {\r\n    write: _write\r\n  }))\r\n\r\n  this._setup = options.setup.bind(this)\r\n\r\n  this._busState = {\r\n    watching: [],\r\n    incoming: [],\r\n    frame: [],\r\n    configured: false\r\n  }\r\n}\r\n\r\n_Bus.prototype = {\r\n  setup (...args) {\r\n    return this.deferred(slots => {\r\n      if(this._busState.configured)\r\n        return Promise.reject('already configured')\r\n\r\n      this._busState.configured = true\r\n      return this._setup(slots, ...args)\r\n    })\r\n  },\r\n\r\n  watch (patterns, callback) {\r\n    const watcher = {\r\n      patterns,\r\n      callback\r\n    }\r\n\r\n    this._busState.watching.push(watcher)\r\n\r\n    return watcher\r\n  },\r\n\r\n  unwatch (watcher) {\r\n    if(watcher) {\r\n      const index = this._busState.watching.indexOf(watcher)\r\n\r\n      if(index >= 0)\r\n        this._busState.watching.splice(index, 1)\r\n    } else {\r\n      this._busState.watching.splice(0)\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  /**\r\n    * @TODO - Proper unwatch(): delete all previously RXed watchers\r\n    */\r\n  rx(patterns, cb) {\r\n    const watcher = this.watch(patterns, frame => {\r\n      //this.unwatch(watcher)\r\n      const index = this._busState.watching.indexOf(watcher)\r\n\r\n      if(index >= 0)\r\n        this._busState.watching.splice(0, index + 1)\r\n\r\n      cb(frame)\r\n    })\r\n\r\n    return this\r\n  },\r\n\r\n  tx(binary, options = {}) {\r\n    return this.deferred(() => {\r\n      console.log('tx')\r\n      if('timeout' in options) {\r\n        return new Promise((done, fail) => {\r\n          setTimeout(() => {\r\n            this.write(binary)\r\n            done()\r\n          }, options.timeout)\r\n        })\r\n      }\r\n\r\n      this.write(binary)\r\n\r\n      return Promise.resolve()\r\n    })\r\n  },\r\n\r\n  reset () {\r\n    this._busState.frame.splice(0)\r\n    this._busState.incoming.splice(0)\r\n    return this\r\n  }\r\n}\r\n\r\nconst Bus = _extend({\r\n  name: 'Bus',\r\n  super: [Writable, Schedule, _Bus],\r\n  apply: [_Bus, Schedule]\r\n})\r\n\r\nexport default Bus\r\n","let status = false\r\nconst defaultInterval = 20\r\n\r\nfunction blink(mode) {\r\n  if(mode === undefined)\r\n    mode = !status\r\n\r\n  !mode\r\n    ? blink.stop()\r\n    : blink.start()\r\n\r\n  return !!status\r\n}\r\n\r\nblink.start = () => {\r\n  if(!status) {\r\n    status = true\r\n\r\n    blink.once(LED2, 20, function cb() {\r\n      if(status) {\r\n        setTimeout(() => blink.once(LED2, 20, cb), 980)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nblink.stop = () => {\r\n  if(status) {\r\n    status = false\r\n  }\r\n}\r\n\r\nblink.once = (led, on = 20, cb) => {\r\n  led.write(true)\r\n  setTimeout(() => {\r\n    led.write(false)\r\n    cb && cb()\r\n  }, on)\r\n}\r\n\r\nexport default blink\r\n","import Bus from 'bus'\r\nimport blink from 'blink'\r\nimport { cmd } from 'nfc'\r\nimport {\r\n  PN532_COMMAND_SAMCONFIGURATION,\r\n  PN532_SAM_NORMAL_MODE,\r\n  PN532_COMMAND_WRITEGPIO,\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  PN532_COMMAND_GETFIRMWAREVERSION,\r\n  PN532_WAKEUP,\r\n  MIFARE_CMD_READ,\r\n  MIFARE_CMD_AUTH_A,\r\n  MIFARE_CMD_AUTH_B,\r\n  MIFARE_CMD_WRITE_4,\r\n  MIFARE_CMD_WRITE_16\r\n} from 'nfc/constants'\r\n\r\nimport series from 'series'\r\n\r\nimport { encodeMessage, textRecord } from 'ndef'\r\n\r\nblink()\r\n\r\nconst encoded = encodeMessage([\r\n  textRecord('2enhello world!')\r\n])\r\n\r\nfunction shrinkToUint8 (values) {\r\n  return values.reduce((sum, value) => {\r\n    sum += value\r\n\r\n    while(sum > 0xff) {\r\n      const remainder = sum & 0xff\r\n      sum = sum >> 8\r\n      sum += remainder - 1\r\n    }\r\n    return sum\r\n  }, 0x00)\r\n}\r\n\r\nfunction LCS_std(byte, length, frame) {\r\n  return 0x00 === shrinkToUint8(frame.slice(-2))\r\n}\r\n\r\nfunction LCS_ext(byte, length, frame) {\r\n  return 0x00 === shrinkToUint8([frame[5] * 256 + frame[6], frame[7]])\r\n}\r\n\r\nfunction CHECKSUM_std(byte, length, frame) {\r\n  return 0x00 === shrinkToUint8(frame.slice(5))\r\n}\r\n\r\nfunction CHECKSUM_ext(byte, length, frame) {\r\n  return 0x00 === shrinkToUint8(frame.slice(8))\r\n}\r\n\r\nfunction BODY_std (frame) {\r\n  const arr = []\r\n  for(let i = 0; i < frame[3] - 1; i ++)\r\n    arr.push(undefined)\r\n  return arr\r\n}\r\n\r\nfunction BODY_ext (frame) {\r\n  const arr = [], length = frame[5] * 256 + frame[6]\r\n  for(let i = 0; i < length - 1; i ++)\r\n    arr.push(undefined)\r\n  return arr\r\n}\r\n\r\nconst INFO_FRAME_std = [\r\n  [0, 0, 0xff, undefined, LCS_std, 0xd5],\r\n  BODY_std,\r\n  [CHECKSUM_std, 0x00]\r\n]\r\n\r\nfunction createResponseNormalFrame (code) {\r\n  return [\r\n    [0, 0, 0xff, undefined, LCS_std, 0xd5, code],\r\n    frame => BODY_std(frame).slice(1),\r\n    [CHECKSUM_std, 0x00]\r\n  ]\r\n}\r\n\r\nconst INFO_FRAME_ext = [\r\n  [0, 0, 0xff, 0xff, 0xff, undefined, undefined, LCS_ext, 0xd5],\r\n  BODY_ext,\r\n  [CHECKSUM_ext, 0x00]\r\n]\r\n\r\nconst ERR_FRAME = [\r\n  [0, 0 , 0xff, 0x01, 0xff, undefined, CHECKSUM_std, 0x00]\r\n]\r\n\r\nconst ACK_FRAME = [\r\n  new Uint8ClampedArray([0, 0, 255, 0, 255, 0])\r\n]\r\n\r\nconst wakeup = cmd([PN532_WAKEUP])\r\nconst sam = cmd([PN532_COMMAND_SAMCONFIGURATION, PN532_SAM_NORMAL_MODE, 20, 0])\r\n\r\n\r\n\r\n\r\nfunction setup(done) {\r\n  Serial1.setup(115200, {\r\n    rx: B7, tx: B6\r\n  })\r\n\r\n  Serial1.write(wakeup)\r\n  Serial1.write(sam)\r\n\r\n  setTimeout(() => {\r\n    Serial1.read()\r\n    Serial1.pipe(this)\r\n  }, 1500)\r\n\r\n  setTimeout(() => {\r\n    blink.once(LED1, 20, () => setTimeout(() => blink.once(LED1, 20), 200))\r\n\r\n    done()\r\n  }, 2000)\r\n}\r\n\r\nconst bus = new Bus({\r\n  setup, highWaterMark: 64\r\n})\r\n\r\nbus.on('error', console.error)\r\n\r\nbus.setup(Serial1)\r\n\r\nconst KEY = new Uint8ClampedArray([0xff, 0xff, 0xff, 0xff, 0xff, 0xff])\r\n\r\nlet afi = 0x00\r\n\r\n\r\n;(function poll() {\r\n  let uid,\r\n      block = 4,\r\n      data = null\r\n\r\n  bus.deferred(done => {\r\n    const LIST = cmd([\r\n      PN532_COMMAND_INLISTPASSIVETARGET,\r\n      1,\r\n      0\r\n    ])\r\n\r\n    bus.rx(ACK_FRAME, ack => {\r\n      console.log('ACK')\r\n    })\r\n\r\n    bus.rx(INFO_FRAME_std, frame => {\r\n      const body = frame.slice(7, 5 + frame[3]),\r\n            uidLength = body[5],\r\n            _uid = body.slice(6, 6 + uidLength)\r\n\r\n      console.log('FOUND', {\r\n        code: frame[6],\r\n        body,\r\n        count: body[0],\r\n        ATQA: body.slice(2, 4), // SENS_RES\r\n        SAK: body[4],\r\n        uidLength,\r\n        uid: _uid\r\n      }['ATQA'])\r\n\r\n      uid = _uid\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(LIST)\r\n  })\r\n\r\n  bus.deferred((done, fail) => {\r\n    const AUTH = cmd([\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_CMD_AUTH_A,\r\n      block\r\n    ].concat(KEY).concat(uid))\r\n\r\n    bus.rx(ACK_FRAME, ack => {})\r\n\r\n    bus.rx(ERR_FRAME, fail)\r\n\r\n    bus.rx(INFO_FRAME_std, frame => {\r\n      console.log('AUTH SUCCEED'/*, {\r\n        code: frame[6],\r\n        body: frame.slice(7, 5 + frame[3])\r\n      }*/)\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(AUTH)\r\n  })\r\n\r\n  bus.deferred((done, fail) => {\r\n    const WRITE = cmd([\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_CMD_WRITE_4,\r\n      block\r\n    ].concat(encoded))\r\n\r\n    bus.rx(ACK_FRAME, ack => {})\r\n\r\n    bus.rx(ERR_FRAME, fail)\r\n\r\n    bus.rx(INFO_FRAME_std, block => {\r\n      console.log('WRITE SUCCEED')\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(WRITE)\r\n  })\r\n\r\n  bus.deferred((done, fail) => {\r\n    console.log('READ')\r\n    const READ = cmd([\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_CMD_READ,\r\n      block\r\n    ])\r\n\r\n    bus.rx(ACK_FRAME, ack => {})\r\n\r\n    //bus.rx(ERR_FRAME, fail)\r\n\r\n    bus.rx(INFO_FRAME_std, block => {\r\n      console.log(\"RED\", block)\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(READ)\r\n  })\r\n\r\n  bus.deferred(done => {\r\n    setTimeout(() => {\r\n      console.log(process.memory())\r\n      done()\r\n      poll()\r\n    }, 1000)\r\n  })\r\n})()\r\n","const PUSH_TO_QUEUE_IMMEDIATE = !0,\r\n      PUSH_AT_NEXT_STAGE = !1,\r\n      loop = [\r\n        // nextTick\r\n        { queue: [], handle: PUSH_TO_QUEUE_IMMEDIATE, tick: false },\r\n        // immediate\r\n        { queue: [], handle: PUSH_TO_QUEUE_IMMEDIATE, tick: false },\r\n        // timeout\r\n        { queue: [], handle: PUSH_AT_NEXT_STAGE, tick: false }\r\n      ]\r\n\r\nlet tick = false,\r\n    timers = {}\r\n\r\nconst asyncFlush = () => {\r\n  for (let stage in loop) {\r\n    if(loop[stage].queue.length) {\r\n      if(loop[stage].handle == PUSH_TO_QUEUE_IMMEDIATE) {\r\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\r\n          loop[stage].queue[exec]()\r\n        }\r\n        loop[stage].queue.splice(0)\r\n      } else /*if(loop[stage].handle == PUSH_AT_NEXT_STAGE)*/ {\r\n        const queue = loop[stage].queue.splice(0)\r\n        for (let exec = 0; exec < queue.length; exec ++) {\r\n          queue[exec]()\r\n        }\r\n      }\r\n    }\r\n\r\n    loop[stage].tick = tick = false\r\n  }\r\n}\r\n\r\nconst asyncCall = stage => cb => {\r\n  loop[stage].queue.push(cb)\r\n\r\n  if (!tick && !loop[stage].tick) {\r\n    loop[stage].tick = tick = true\r\n\r\n    setTimeout(asyncFlush)\r\n  }\r\n}\r\n\r\nconst nextTick = asyncCall(/* .nextTick */0)\r\n\r\nconst setImmediate = asyncCall(/* .immediate */1)\r\n\r\nconst timeoutCall = asyncCall(/* .timeeout */2)\r\n\r\nconst _setTimeout = (cb, timeout) => {\r\n  let index = 0\r\n  while(timers[index]) {\r\n    index++\r\n  }\r\n  timers[index] = setTimeout(() => {\r\n    if(timers[index]) {\r\n      delete timers[index]\r\n      timeoutCall(cb)\r\n    }\r\n  }, timeout)\r\n\r\n  return index\r\n}\r\n\r\nconst setInterval = (cb, timeout) => {\r\n  return (function setTimer() {\r\n    return _setTimeout(() => {\r\n      cb()\r\n      setTimer()\r\n    }, timeout)\r\n  })()\r\n}\r\n\r\nexport {\r\n  nextTick,\r\n  setImmediate,\r\n  _setTimeout as setTimeout,\r\n  setInterval\r\n}\r\n","import { nextTick } from 'event-loop'\r\n\r\nconst _process = typeof process !== 'undefined' ? process : {}\r\n\r\n_process.nextTick = typeof _process.nextTick !== 'undefined' ? _process.nextTick : nextTick\r\n\r\nexport default _process\r\n","const timers = {}\r\n\r\nfunction time(label) {\r\n  timers[label] = Date.now()\r\n}\r\n\r\nfunction timeEnd(label) {\r\n  if(label in timers) {\r\n    console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\r\n    delete timers[label]\r\n  }\r\n}\r\n\r\nif(typeof console.time !== 'function') {\r\n  console.time = time\r\n  console.timeEnd = timeEnd\r\n}\r\n\r\nif(typeof console.error !== 'function') {\r\n  console.error = console.log\r\n}\r\n\r\nexport default console\r\n","Object.assign = (target, ...args) => {\r\n  for(let obj of args) {\r\n    if(obj instanceof Object)\r\n      for(let key in obj) {\r\n        target[key] = obj[key]\r\n      }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\n//Object.freeze = obj => obj\r\n\r\nexport default Object\r\n","const defProp = (obj, prop, desc) => {\r\n  try {\r\n    Object.defineProperty(obj, prop, desc)\r\n    return obj\r\n  } catch(e) {\r\n    if(desc.get)\r\n      obj.value = desc.get()\r\n    else if(desc.value)\r\n      obj[prop] = desc.value\r\n\r\n    return obj\r\n  }\r\n}\r\n\r\nexport {\r\n  defProp\r\n}\r\n","export default (name, f) => {\r\n  defProp(f, 'name', { value: name })\r\n  //defProp(f, 'toString', { value: () => '[Function' + (f.name !== undefined ? ': ' + f.name : '') + ']' })\r\n\r\n  return f\r\n}\r\n","const SUPER_CHAIN_PROTO_PROP = '_super',\r\n  SUPER_CHAIN_APPLY_PROP = '_apply',\r\n  PROTOTYPE_IS_EXTENDED_PROP = '_isExtended'\r\n\r\nexport {\r\n  SUPER_CHAIN_PROTO_PROP,\r\n  SUPER_CHAIN_APPLY_PROP,\r\n  PROTOTYPE_IS_EXTENDED_PROP\r\n}\r\n","import {\r\n  SUPER_CHAIN_PROTO_PROP,\r\n  SUPER_CHAIN_APPLY_PROP,\r\n  PROTOTYPE_IS_EXTENDED_PROP\r\n} from './vars'\r\n\r\nconst _copyChain = (Extended, ProtoChain, chainPropName, ignoreExtended) => {\r\n  //if chain on [Extended] has not been created yet\r\n  if(!Extended.prototype[chainPropName])\r\n    defProp(Extended.prototype, chainPropName, { value: [] })\r\n\r\n  ProtoChain.forEach(Proto => {\r\n    //console.log(!!Proto.prototype['__extended__'], Proto)\r\n    //if [Proto] has been '__extended__' and has same-named proto chain, copy the Proto chain to Extended chain\r\n    const isExtended = !!Proto.prototype[PROTOTYPE_IS_EXTENDED_PROP],\r\n      hasSameChain = !!Proto.prototype[chainPropName]\r\n\r\n    const alreadyInChain = Extended.prototype[chainPropName].some(P => (P === Proto)),\r\n      shouldBePushed = (!isExtended || !ignoreExtended) && !alreadyInChain,\r\n      shouldCopyChain = isExtended && hasSameChain\r\n\r\n    if(shouldCopyChain)\r\n      Proto.prototype[chainPropName].forEach(Proto => {\r\n        //avoid pushing twice\r\n        if(!Extended.prototype[chainPropName].some(P => (P === Proto)) ) {\r\n          //console.log('pushed', Proto)\r\n          Extended.prototype[chainPropName].push(Proto)\r\n        }\r\n      })\r\n\r\n    if(shouldBePushed)\r\n      Extended.prototype[chainPropName].push(Proto)\r\n  })\r\n\r\n  //console.log(Extended.prototype[chainPropName])\r\n}\r\n\r\nconst _extend = (options = {}) => {\r\n  if(!options.apply)\r\n    options.apply = []\r\n  if(!options.super)\r\n    options.super = []\r\n  if(!options.static)\r\n    options.static = []\r\n\r\n  const Child = options.super[0]\r\n\r\n  if(!options.name)\r\n    options.name = Child.name\r\n\r\n  function Extended() {\r\n    Extended.prototype[SUPER_CHAIN_APPLY_PROP].forEach(Super => {\r\n      if(Super !== Extended) {\r\n        Super.apply(this, arguments)\r\n      }\r\n    })\r\n  }\r\n\r\n  _named(options.name, Extended)\r\n\r\n  for(let i in options.static) {\r\n    for(let prop in options.static[i]) {\r\n      if('prototype' != prop) {\r\n        defProp(Extended, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  defProp(Extended, 'prototype', { value: {} })\r\n  defProp(Extended.prototype, 'constructor', { value: Child })\r\n  defProp(Extended.prototype, PROTOTYPE_IS_EXTENDED_PROP, { value: true })\r\n\r\n  for(let i in options.super) {\r\n    function Proto() {}\r\n    Proto.prototype = options.super[i].prototype\r\n    const proto = new Proto()\r\n\r\n    for(let prop in proto) {\r\n      if(['constructor', PROTOTYPE_IS_EXTENDED_PROP, SUPER_CHAIN_PROTO_PROP, SUPER_CHAIN_APPLY_PROP].indexOf(prop) < 0) {\r\n        defProp(Extended.prototype, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  _copyChain(Extended, options.super, SUPER_CHAIN_PROTO_PROP, false)\r\n  _copyChain(Extended, options.apply, SUPER_CHAIN_APPLY_PROP, true)\r\n\r\n  return Extended\r\n}\r\n\r\nconst extend = (...args) => _extend({ super: args.slice(1), apply: args })\r\n\r\nexport { extend, _extend, _copyChain }\r\n","Array.prototype.concat = function () {\r\n  const concatenated = []\r\n\r\n  for(let i in this) {\r\n    concatenated.push(this[i])\r\n  }\r\n\r\n  for(let i in arguments) {\r\n    for(let j in arguments[i]) {\r\n      concatenated.push(arguments[i][j])\r\n    }\r\n  }\r\n\r\n  return concatenated\r\n}\r\n\r\nexport default Array\r\n","import EventEmitter from 'events'\r\n\r\nfunction _Stream(options = {}) {\r\n\tthis.options = {\r\n\t\thighWaterMark: options.highWaterMark || 128\r\n\t}\r\n}\r\n\r\nconst Stream = _extend({\r\n\tname: 'Stream',\r\n\tsuper: [EventEmitter],\r\n\tapply: [EventEmitter, _named('Stream', _Stream)]\r\n})\r\n\r\nStream.prototype.emit = function (event, err) {\r\n\tif(event === 'error' && !(this['#onerror'] || this._events['error']))\r\n\t\tthrow new Error(err)\r\n\r\n\treturn EventEmitter.prototype.emit.apply(this, arguments)\r\n}\r\n\r\nexport default Stream\r\n","import Readable from './readable'\r\nimport Writable from './writable'\r\n\r\nfunction _Duplex(options = {}) {}\r\n\r\nconst Duplex = _extend({\r\n\tname: 'Duplex',\r\n  super: [Readable, Writable],\r\n  apply: [Readable, Writable, _named('Duplex', _Duplex)]\r\n})\r\n\r\nDuplex.prototype.on = function on() {\r\n  Readable.prototype.on.apply(this, arguments)\r\n  //Writable.prototype.on.apply(this, arguments)\r\n\r\n  return this\r\n}\r\n\r\nexport default Duplex\r\n","import Readable from './readable'\r\nimport Writable from './writable'\r\n\r\nfunction _Duplex(options = {}) {}\r\n\r\nconst Duplex = _extend({\r\n\tname: 'Duplex',\r\n  super: [Readable, Writable],\r\n  apply: [Readable, Writable, _named('Duplex', _Duplex)]\r\n})\r\n\r\nDuplex.prototype.on = function on() {\r\n  Readable.prototype.on.apply(this, arguments)\r\n  //Writable.prototype.on.apply(this, arguments)\r\n\r\n  return this\r\n}\r\n\r\nexport default Duplex\r\n","import {\r\n  PN532_PREAMBLE,\r\n  PN532_STARTCODE1,\r\n  PN532_STARTCODE2,\r\n  PN532_HOSTTOPN532,\r\n  PN532_POSTAMBLE\r\n} from './constants'\r\n\r\nexport const cmd = command => {\r\n  let i, arr = [\r\n    PN532_PREAMBLE,\r\n    PN532_STARTCODE1,\r\n    PN532_STARTCODE2,\r\n    command.length + 1,\r\n    (~command.length) & 0xff,\r\n    PN532_HOSTTOPN532\r\n  ].concat(command)\r\n\r\n  let checksum = -arr[0]\r\n  for (i in arr)\r\n    checksum+=arr[i]\r\n  arr.push((~checksum) & 0xFF)\r\n  checksum=0\r\n  for (i in arr)\r\n    checksum+=arr[i]\r\n  arr.push(PN532_POSTAMBLE)\r\n  return new Uint8ClampedArray(arr)\r\n}\r\n","var data = { TNF_EMPTY: 0,\n  TNF_WELL_KNOWN: 1,\n  TNF_MIME_MEDIA: 2,\n  TNF_ABSOLUTE_URI: 3,\n  TNF_EXTERNAL_TYPE: 4,\n  TNF_UNKNOWN: 5,\n  TNF_UNCHANGED: 6,\n  TNF_RESERVED: 7,\n  RTD_TEXT: \"T\",\n  RTD_URI: \"U\",\n  RTD_SMART_POSTER: \"Sp\",\n  RTD_ALTERNATIVE_CARRIER: \"ac\",\n  RTD_HANDOVER_CARRIER: \"Hc\",\n  RTD_HANDOVER_REQUEST: \"Hr\",\n  RTD_HANDOVER_SELECT: \"Hs\",\n  BLOCK_SIZE: 16,\n  TLV_START: 64,\n  TL_LENGTH: 4 };\n\n/**\r\n  * decode text bytes from ndef record payload\r\n  *\r\n  * @returns a string\r\n  */\nvar decode = function decode(data) {\n    var languageCodeLength = data[0] & 0x3F,\n        // 6 LSBs\n    languageCode = data.slice(1, 1 + languageCodeLength),\n        utf16 = (data[0] & 0x80) !== 0; // assuming UTF-16BE\n\n    // TODO need to deal with UTF in the future\n    // console.log(\"lang \" + languageCode + (utf16 ? \" utf16\" : \" utf8\"))\n\n    return Buffer.from(data.slice(languageCodeLength + 1)).toString();\n};\n\n/**\r\n  * Encode text payload\r\n  *\r\n  * @returns an array of bytes\r\n  */\nvar encode = function encode(text, lang, encoding) {\n    // ISO/IANA language code, but we're not enforcing\n    if (!lang) {\n        lang = 'en';\n    }\n\n    var encoded = Buffer.from([lang.length].concat([].slice.call(Buffer.from(lang + text))));\n\n    return encoded;\n};\n\n// URI identifier codes from URI Record Type Definition NFCForum-TS-RTD_URI_1.0 2006-07-24\n// index in array matches code in the spec\nvar protocols = [\"\", \"http://www.\", \"https://www.\", \"http://\", \"https://\", \"tel:\", \"mailto:\", \"ftp://anonymous:anonymous@\", \"ftp://ftp.\", \"ftps://\", \"sftp://\", \"smb://\", \"nfs://\", \"ftp://\", \"dav://\", \"news:\", \"telnet://\", \"imap:\", \"rtsp://\", \"urn:\", \"pop:\", \"sip:\", \"sips:\", \"tftp:\", \"btspp://\", \"btl2cap://\", \"btgoep://\", \"tcpobex://\", \"irdaobex://\", \"file://\", \"urn:epc:id:\", \"urn:epc:tag:\", \"urn:epc:pat:\", \"urn:epc:raw:\", \"urn:epc:\", \"urn:nfc:\"];\n\n/**\r\n  * @returns a string\r\n  */\nvar decode$1 = function decode(data) {\n    var prefix = protocols[data[0]];\n    if (!prefix) {\n        // 36 to 255 should be \"\"\n        prefix = \"\";\n    }\n    return prefix + Buffer.from(data.slice(1)).toString();\n};\n\n/**\r\n  * shorten a URI with standard prefix\r\n  *\r\n  * @returns an array of bytes\r\n  */\nvar encode$1 = function encode(uri) {\n    var prefix, protocolCode, encoded;\n\n    // check each protocol, unless we've found a match\n    // \"urn:\" is the one exception where we need to keep checking\n    // slice so we don't check \"\"\n    protocols.slice(1).forEach(function (protocol) {\n        if ((!prefix || prefix === \"urn:\") && uri.indexOf(protocol) === 0) {\n            prefix = protocol;\n        }\n    });\n\n    if (!prefix) {\n        prefix = \"\";\n    }\n\n    protocolCode = protocols.indexOf(prefix);\n    encoded = Buffer.from([protocolCode].concat([].slice.call(Buffer.from(uri.slice(prefix.length)))));\n\n    return encoded;\n};\n\n// ndef.js\n// Copyright 2013 Don Coleman\n//\n// This code is from phonegap-nfc.js https://github.com/don/phonegap-nfc\n\n// see android.nfc.NdefRecord for documentation about constants\n// http://developer.android.com/reference/android/nfc/NdefRecord.html\n\n// convert bytes to a String\nvar s = function s(bytes) {\n  return Buffer.from(bytes).toString();\n};\n\n/**\r\n * Creates a JSON representation of a NDEF Record.\r\n *\r\n * @tnf 3-bit TNF (Type Name Format) - use one of the constants.TNF_* constants\r\n * @type byte array, containing zero to 255 bytes, must not be null\r\n * @id byte array, containing zero to 255 bytes, must not be null\r\n * @payload byte array, containing zero to (2 ** 32 - 1) bytes, must not be null\r\n *\r\n * @returns JSON representation of a NDEF record\r\n *\r\n * @see Ndef.textRecord, Ndef.uriRecord and Ndef.mimeMediaRecord for examples\r\n */\n\nvar record = function record(tnf, type, id, payload, value) {\n  if (!tnf) {\n    tnf = data.TNF_EMPTY;\n  }\n  if (!type) {\n    type = [];\n  }\n  if (!id) {\n    id = [];\n  }\n  if (!payload) {\n    payload = [];\n  }\n  // store type as String so it's easier to compare\n  if (type instanceof Array) {\n    type = Buffer.from(type).toString();\n  }\n\n  // in the future, id could be a String\n  if (!(id instanceof Array)) {\n    id = Buffer.from(id);\n  }\n\n  // Payload must be binary\n  if (!(payload instanceof Array)) {\n    payload = Buffer.from(payload);\n  }\n\n  // Experimental feature\n  // Convert payload to text for Text and URI records\n  if (tnf == data.TNF_WELL_KNOWN) {\n    if (type == data.RTD_TEXT) {\n      value = decode(payload);\n    } else if (type == data.RTD_URI) {\n      value = decode$1(payload);\n    }\n  }\n\n  return {\n    tnf: tnf,\n    type: type,\n    id: id,\n    payload: payload,\n    value: value\n  };\n};\n\n/**\r\n * Helper that creates an NDEF record containing plain text.\r\n *\r\n * @text String of text to encode\r\n * @languageCode ISO/IANA language code. Examples: “fi”, “en-US”, “fr-CA”, “jp”. (optional)\r\n * @id byte[] (optional)\r\n */\nvar textRecord = function textRecord(text, languageCode, id) {\n  return record(data.TNF_WELL_KNOWN, data.RTD_TEXT, id || [], encode(text, languageCode));\n};\n\n/**\r\n * Helper that creates a NDEF record containing a URI.\r\n *\r\n * @uri String\r\n * @id byte[] (optional)\r\n */\nvar uriRecord = function uriRecord(uri, id) {\n  return record(data.TNF_WELL_KNOWN, data.RTD_URI, id || [], encode$1(uri));\n};\n\n/**\r\n * Helper that creates a NDEF record containing an absolute URI.\r\n *\r\n * An Absolute URI record means the URI describes the payload of the record.\r\n *\r\n * For example a SOAP message could use \"http://schemas.xmlsoap.org/soap/envelope/\"\r\n * as the type and XML content for the payload.\r\n *\r\n * Absolute URI can also be used to write LaunchApp records for Windows.\r\n *\r\n * See 2.4.2 Payload Type of the NDEF Specification\r\n * http://www.nfc-forum.org/specs/spec_list#ndefts\r\n *\r\n * Note that by default, Android will open the URI defined in the type\r\n * field of an Absolute URI record (TNF=3) and ignore the payload.\r\n * BlackBerry and Windows do not open the browser for TNF=3.\r\n *\r\n * To write a URI as the payload use ndef.uriRecord(uri)\r\n *\r\n * @uri String\r\n * @payload byte[] or String\r\n * @id byte[] (optional)\r\n */\nvar absoluteUriRecord = function absoluteUriRecord(uri, payload, id) {\n  return record(data.TNF_ABSOLUTE_URI, uri, id || [], payload || []);\n};\n\n/**\r\n* Helper that creates a NDEF record containing an mimeMediaRecord.\r\n*\r\n* @mimeType String\r\n* @payload byte[]\r\n* @id byte[] (optional)\r\n*/\nvar mimeMediaRecord = function mimeMediaRecord(mimeType, payload, id) {\n  return record(data.TNF_MIME_MEDIA, mimeType, id || [], payload || []);\n};\n\n/**\r\n* Helper that creates an NDEF record containing an Smart Poster.\r\n*\r\n* @ndefRecords array of NDEF Records\r\n* @id byte[] (optional)\r\n*/\nvar smartPoster = function smartPoster(ndefRecords, id) {\n  var payload = [];\n\n  if (ndefRecords) {\n    // make sure we have an array of something like NDEF records before encoding\n    if (ndefRecords[0] instanceof Object && ndefRecords[0].hasOwnProperty('tnf')) {\n      payload = encodeMessage(ndefRecords);\n    } else {\n      // assume the caller has already encoded the NDEF records into a byte array\n      payload = ndefRecords;\n    }\n  } else {\n    //console.warn(\"WARNING: Expecting an array of NDEF records\")\n    throw new Error('Expecting an array of NDEF records');\n  }\n\n  return record(data.TNF_WELL_KNOWN, data.RTD_SMART_POSTER, id, payload);\n};\n\n/**\r\n* Helper that creates an empty NDEF record.\r\n*\r\n*/\nvar emptyRecord = function emptyRecord() {\n  return record(data.TNF_EMPTY, [], [], []);\n};\n\n/**\r\n* Helper that creates an Android Application Record (AAR).\r\n* http://developer.android.com/guide/topics/connectivity/nfc/nfc.html#aar\r\n*\r\n*/\nvar androidApplicationRecord = function androidApplicationRecord(packageName) {\n  return record(data.TNF_EXTERNAL_TYPE, 'android.com:pkg', [], packageName);\n};\n\n/**\r\n* Encodes an NDEF Message into bytes that can be written to a NFC tag.\r\n*\r\n* @ndefRecords an Array of NDEF Records\r\n*\r\n* @returns byte array\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\nvar encodeMessage = function encodeMessage(ndefRecords) {\n  var encoded = [],\n      tnf_byte = void 0,\n      record_type = void 0,\n      payload_length = void 0,\n      id_length = void 0,\n      i = void 0,\n      mb = void 0,\n      me = void 0,\n      // messageBegin, messageEnd\n  cf = false,\n      // chunkFlag TODO implement\n  sr = void 0,\n      // boolean shortRecord\n  il = void 0; // boolean idLengthFieldIsPresent\n\n  for (i = 0; i < ndefRecords.length; i++) {\n    mb = i === 0;\n    me = i === ndefRecords.length - 1;\n    sr = ndefRecords[i].payload.length < 0xFF;\n    il = ndefRecords[i].id.length > 0;\n    tnf_byte = encodeTnf(mb, me, cf, sr, il, ndefRecords[i].tnf);\n    encoded.push(tnf_byte);\n\n    // type is stored as String, converting to bytes for storage\n    record_type = [].slice.call(Buffer.from(ndefRecords[i].type));\n    encoded.push(record_type.length);\n\n    if (sr) {\n      payload_length = ndefRecords[i].payload.length;\n      encoded.push(payload_length);\n    } else {\n      payload_length = ndefRecords[i].payload.length;\n      // 4 bytes\n      encoded.push(payload_length >> 24);\n      encoded.push(payload_length >> 16);\n      encoded.push(payload_length >> 8);\n      encoded.push(payload_length & 0xFF);\n    }\n\n    if (il) {\n      id_length = ndefRecords[i].id.length;\n      encoded.push(id_length);\n    }\n\n    encoded = encoded.concat(record_type);\n\n    if (il) {\n      encoded = encoded.concat(ndefRecords[i].id);\n    }\n\n    encoded = encoded.concat([].slice.call(ndefRecords[i].payload));\n  }\n\n  return encoded;\n};\n\n/**\r\n* Decodes an array bytes into an NDEF Message\r\n*\r\n* @bytes an array bytes read from a NFC tag\r\n*\r\n* @returns array of NDEF Records\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\nvar decodeMessage = function decodeMessage(_bytes) {\n  var bytes = _bytes.slice(0),\n      // clone since parsing is destructive\n  ndef_message = [],\n      tnf_byte = void 0,\n      header = void 0,\n      type_length = 0,\n      payload_length = 0,\n      id_length = 0,\n      record_type = [],\n      id = [],\n      payload = [];\n\n  while (bytes.length) {\n    tnf_byte = bytes.shift();\n    header = decodeTnf(tnf_byte);\n\n    type_length = bytes.shift();\n\n    if (header.sr) {\n      payload_length = bytes.shift();\n    } else {\n      // next 4 bytes are length\n      payload_length = (0xFF & bytes.shift()) << 24 | (0xFF & bytes.shift()) << 16 | (0xFF & bytes.shift()) << 8 | 0xFF & bytes.shift();\n    }\n\n    if (header.il) {\n      id_length = bytes.shift();\n    }\n\n    record_type = bytes.splice(0, type_length);\n    id = bytes.splice(0, id_length);\n    payload = bytes.splice(0, payload_length);\n\n    ndef_message.push(record(header.tnf, record_type, id, payload));\n\n    if (header.me) {\n      // last message\n      break;\n    }\n  }\n\n  return ndef_message;\n};\n\n/**\r\n* Decode the bit flags from a TNF Byte.\r\n*\r\n* @returns object with decoded data\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\nvar decodeTnf = function decodeTnf(tnf_byte) {\n  return {\n    mb: (tnf_byte & 0x80) !== 0,\n    me: (tnf_byte & 0x40) !== 0,\n    cf: (tnf_byte & 0x20) !== 0,\n    sr: (tnf_byte & 0x10) !== 0,\n    il: (tnf_byte & 0x8) !== 0,\n    tnf: tnf_byte & 0x7\n  };\n};\n\n/**\r\n* Encode NDEF bit flags into a TNF Byte.\r\n*\r\n* @returns tnf byte\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\nvar encodeTnf = function encodeTnf(mb, me, cf, sr, il, tnf, value) {\n  if (!value) {\n    value = tnf;\n  }\n\n  if (mb) {\n    value = value | 0x80;\n  }\n\n  if (me) {\n    value = value | 0x40;\n  }\n\n  // note if cf: me, mb, li must be false and tnf must be 0x6\n  if (cf) {\n    value = value | 0x20;\n  }\n\n  if (sr) {\n    value = value | 0x10;\n  }\n\n  if (il) {\n    value = value | 0x8;\n  }\n\n  return value;\n};\n\n// TODO test with byte[] and string\nvar isType = function isType(record, tnf, type) {\n  return record.tnf === tnf ? s(record) === s(type) : false;\n};\n\n// export const tnfToString = (tnf, value = tnf) => {\n//   if(tnf == constants.TNF_EMPTY) {\n//     value = \"Empty\"\n//   }\n//   else if(constants.TNF_WELL_KNOWN) {\n//     value = \"Well Known\"\n//   }\n//   else if(constants.TNF_MIME_MEDIA) {\n//     value = \"Mime Media\"\n//   }\n//   else if(constants.TNF_ABSOLUTE_URI) {\n//     value = \"Absolute URI\"\n//   }\n//   else if(constants.TNF_EXTERNAL_TYPE) {\n//     value = \"External\"\n//   }\n//   else if(constants.TNF_UNKNOWN) {\n//     value = \"Unknown\"\n//   }\n//   else if(constants.TNF_UNCHANGED) {\n//     value = \"Unchanged\"\n//   }\n//   else if(constants.TNF_RESERVED) {\n//     value = \"Reserved\"\n//   }\n//   return value\n// }\n\n// Convert NDEF records and messages to strings\n// This works OK for demos, but real code proably needs\n// a custom implementation. It would be nice to make\n// smarter record objects that can print themselves\n// var stringifier = {\n//     stringify: function (data, separator) {\n//       if (Array.isArray(data)) {\n//         if (typeof data[0] === 'number') {\n//           // guessing this message bytes\n//           data = decodeMessage(data)\n//         }\n//\n//         return stringifier.printRecords(data, separator)\n//       } else {\n//         return stringifier.printRecord(data, separator)\n//       }\n//     },\n//\n//     // @message - NDEF Message (array of NDEF Records)\n//     // @separator - line separator, optional, defaults to \\n\n//     // @returns string with NDEF Message\n//     printRecords: function (message, separator) {\n//\n//         if(!separator) { separator = \"\\n\" }\n//         result = \"\"\n//\n//         // Print out the payload for each record\n//         message.forEach(function(record) {\n//             result += stringifier.printRecord(record, separator)\n//             result += separator\n//         })\n//\n//         return result.slice(0, (-1 * separator.length))\n//     },\n//\n//     // @record - NDEF Record\n//     // @separator - line separator, optional, defaults to \\n\n//     // @returns string with NDEF Record\n//     printRecord: function (record, separator) {\n//\n//         var result = \"\"\n//\n//         if(!separator) { separator = \"\\n\" }\n//\n//         switch(record.tnf) {\n//             case ndef.constants.TNF_EMPTY:\n//                 result += \"Empty Record\"\n//                 result += separator\n//                 break\n//             case ndef.constants.TNF_WELL_KNOWN:\n//                 result += stringifier.printWellKnown(record, separator)\n//                 break\n//             case ndef.constants.TNF_MIME_MEDIA:\n//                 result += \"MIME Media\"\n//                 result += separator\n//                 result += s(record.type)\n//                 result += separator\n//                 result += s(record.payload) // might be binary\n//                 break\n//             case ndef.constants.TNF_ABSOLUTE_URI:\n//                 result += \"Absolute URI\"\n//                 result += separator\n//                 result += s(record.type)    // the URI is the type\n//                 result += separator\n//                 result += s(record.payload) // might be binary\n//                 break\n//             case ndef.constants.TNF_EXTERNAL_TYPE:\n//                 // AAR contains strings, other types could\n//                 // contain binary data\n//                 result += \"External\"\n//                 result += separator\n//                 result += s(record.type)\n//                 result += separator\n//                 result += s(record.payload)\n//                 break\n//             default:\n//                 result += s(\"Can't process TNF \" + record.tnf)\n//         }\n//\n//         result += separator\n//         return result\n//     },\n//\n//     printWellKnown: function (record, separator) {\n//\n//         var result = \"\"\n//\n//         if (record.tnf !== ndef.constants.TNF_WELL_KNOWN) {\n//             return \"ERROR expecting TNF Well Known\"\n//         }\n//\n//         switch(record.type) {\n//             case ndef.constants.RTD_TEXT:\n//                 result += \"Text Record\"\n//                 result += separator\n//                 result += (ndef.text.decodePayload(record.payload))\n//                 break\n//             case ndef.constants.RTD_URI:\n//                 result += \"URI Record\"\n//                 result += separator\n//                 result += (ndef.uri.decodePayload(record.payload))\n//                 break\n//             case ndef.constants.RTD_SMART_POSTER:\n//                 result += \"Smart Poster\"\n//                 result += separator\n//                 // the payload of a smartposter is a NDEF message\n//                 result += stringifier.printRecords(ndef.decodeMessage(record.payload))\n//                 break\n//             default:\n//                 // attempt to display other types\n//                 result += record.type + \" Record\"\n//                 result += separator\n//                 result += s(record.payload)\n//         }\n//\n//         return result\n//     }\n// }\n//\n// export const stringify = { stringifier }\n\nexport { data as constants, record, textRecord, uriRecord, absoluteUriRecord, mimeMediaRecord, smartPoster, emptyRecord, androidApplicationRecord, encodeMessage, decodeMessage, decodeTnf, encodeTnf, isType };\n"],"names":["EventEmitter","Buffer","Error","BufferState","options","assign","this","toString","binary","str","i","length","String","fromCharCode","_broadcast","chunk","read","nextTick","_this","_readableState","defaultEncoding","encodings","UTF8","emit","_flow","flowing","call","_end","ended","_Readable","BINARY","pipes","_read","bind","TypeError","Function","_readFromInternalBuffer","spliced","_writableState","nodes","needDrain","highWaterMark","_flush","corked","cb","err","consumed","_writev","node","_write","encoding","_Writable","write","_this2","_buffer","size","_transform","data","push","_Schedule","pending","Promise","resolve","_parse","_busState","incoming","watching","frame","currentChunkIndex","incomingIndex","isEqual","watchingIndex","patterns","callback","incomingI","expected","currentPattern","byteIndex","undefined","Array","arrayOffset","slice","patternIndex","splice","pattern","nextPattern","series","arr","done","next","chunks","bytesLeft","offset","subchunk","apply","arguments","_Bus","Object","_setup","setup","blink","mode","status","start","stop","shrinkToUint8","values","reduce","sum","value","remainder","CHECKSUM_std","byte","loop","queue","handle","tick","timers","asyncFlush","stage","exec","asyncCall","setImmediate","timeoutCall","_setTimeout","timeout","index","setTimeout","_process","process","console","time","label","Date","now","timeEnd","log","toFixed","error","target","args","obj","key","defProp","prop","desc","defineProperty","e","get","name","f","SUPER_CHAIN_PROTO_PROP","SUPER_CHAIN_APPLY_PROP","PROTOTYPE_IS_EXTENDED_PROP","_copyChain","Extended","ProtoChain","chainPropName","ignoreExtended","prototype","forEach","isExtended","Proto","hasSameChain","alreadyInChain","some","P","shouldBePushed","_extend","Super","super","static","Child","proto","indexOf","concat","concatenated","j","_named","on","once","event","listener","_listener","removeListener","Stream","_events","from","iterable","c","charCodeAt","array","list","totalLength","buffer","set","buf","unshift","count","nodeIndex","to","at","shift","overflow","writable","pipe","stopped","pause","resume","find","Readable","Writable","Duplex","Transform","transform","task","all","fail","catch","then","Schedule","deferred","configured","reject","slots","watcher","watch","_this3","Bus","LED2","led","cmd","PN532_PREAMBLE","PN532_STARTCODE1","PN532_STARTCODE2","command","PN532_HOSTTOPN532","checksum","PN532_POSTAMBLE","Uint8ClampedArray","TNF_EMPTY","decode","languageCodeLength","encode","text","lang","protocols","decode$1","prefix","record","tnf","type","id","payload","TNF_WELL_KNOWN","RTD_TEXT","RTD_URI","encodeTnf","mb","me","cf","sr","il","encoded","ndefRecords","tnf_byte","record_type","payload_length","id_length","encodeMessage","languageCode","textRecord","INFO_FRAME_std","ERR_FRAME","ACK_FRAME","wakeup","PN532_WAKEUP","sam","PN532_COMMAND_SAMCONFIGURATION","PN532_SAM_NORMAL_MODE","bus","B7","tx","B6","LED1","Serial1","KEY","poll","uid","block","LIST","PN532_COMMAND_INLISTPASSIVETARGET","rx","body","uidLength","_uid","AUTH","PN532_COMMAND_INDATAEXCHANGE","MIFARE_CMD_AUTH_A","WRITE","MIFARE_CMD_WRITE_4","READ","MIFARE_CMD_READ","memory"],"mappings":"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"}