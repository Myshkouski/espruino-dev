{"version":3,"file":"index.esp.min.js","sources":["../globals/console.js","../globals/buffer/index.js","../lib/stream/bufferState.js","../helpers/series.js","../lib/bus.js","../lib/schedule.js","../lib/blink.js","../src/index.js","../globals/array.js","../globals/promise.js","../globals/object.js","../globals/event-loop.js","../lib/nfc/index.js","../node_modules/esp-ndef/dist/index.esm.js"],"sourcesContent":["const timers = {}\r\n\r\nfunction time(label) {\r\n  timers[label] = Date.now()\r\n}\r\n\r\nfunction timeEnd(label) {\r\n  if(label in timers) {\r\n    console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\r\n    delete timers[label]\r\n  }\r\n}\r\n\r\nif(typeof console.time !== 'function') {\r\n  console.time = time\r\n  console.timeEnd = timeEnd\r\n}\r\n\r\nif(typeof console.error !== 'function') {\r\n  console.error = console.log\r\n}\r\n\r\nexport default console\r\n","import Proto from './proto'\r\nimport { toBuffer } from './utils/to'\r\n\r\nfunction copy(target) {\r\n\tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\r\n\t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\r\n\t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\r\n\r\n\tlet copied = 0\r\n\r\n\tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\r\n\t\ttarget.set([ this[sourceIndex] ], targetIndex)\r\n\r\n\treturn copied\r\n}\r\n\r\nfunction Buffer() {\r\n\tthrow new Error('Buffer constructor is deprecated. Use Buffer.from() instead.')\r\n}\r\n\r\nBuffer.from = function _createBuffer() {\r\n\t//console.log(arguments)\r\n\tlet iterable = []\r\n\tif(typeof arguments[0] === 'string') {\r\n    for(let c in arguments[0])\r\n  \t\titerable[c] = arguments[0].charCodeAt(c)\r\n\r\n  \titerable = new Proto(iterable)\r\n  }\r\n\r\n  else if(arguments[0] instanceof Proto || arguments[0] instanceof Array)\r\n\t\titerable = new Proto(arguments[0])\r\n\r\n\tconst offset = arguments[1] !== undefined ? arguments[1] : 0,\r\n\t\tlength = arguments[2] !== undefined ? arguments[2] : iterable.length\r\n\r\n\tconst array = []\r\n\r\n\tfor(let i = offset;i--;)\r\n\t\tarray[i] = 0\r\n\r\n\tfor(let i = 0; (i < iterable.length) && (i < length); i++)\r\n\t\tarray[offset + i] = iterable[i]\r\n\r\n\tfor(let i = array.length; i < length; i++)\r\n\t\tarray[i] = 0\r\n\r\n\tconst buffer = new Proto(array)\r\n\r\n\treturn buffer\r\n}\r\n\r\nBuffer.concat = function concat() {\r\n\tconst list = arguments[0] || [],\r\n\t\t\t\ttotalLength = arguments[1] !== undefined ? arguments[1] : list.reduce((totalLength, array) => (totalLength + array.length), 0),\r\n\t\t\t\tbuffer = Buffer.from([], 0, totalLength)\r\n\r\n\tlet offset = 0\r\n\r\n\tlist.forEach(buf => {\r\n\t\tbuffer.set(buf, offset)\r\n\t\toffset += buf.length\r\n\t})\r\n\r\n\treturn buffer\r\n}\r\n\r\nexport default Buffer\r\n","function BufferState(options = {}) {\r\n  Object.assign(this, {\r\n\t\t_buffer: [],\r\n\t\tlength: 0\r\n\t}, options)\r\n}\r\n\r\nBufferState.prototype = {\r\n  push(chunk) {\r\n    const node = {\r\n  \t\tchunk: Buffer.from(chunk),\r\n  \t\tnext: null\r\n  \t}\r\n\r\n    if(this._buffer.length) {\r\n      this._buffer[this._buffer.length - 1].next = node\r\n    }\r\n\r\n    this._buffer.push(node)\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  unshift(chunk) {\r\n    const node = {\r\n  \t\tchunk: Buffer.from(chunk),\r\n      encoding: 'binary',\r\n  \t\tnext: null\r\n  \t}\r\n\r\n    if(this._buffer.length) {\r\n      node.next = this._buffer[0]\r\n    }\r\n\r\n    this._buffer.unshift(node)\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  nodes(count) {\r\n    const nodes = this._buffer.splice(0, count)\r\n    nodes.forEach(node => this.length -= node.chunk.length)\r\n\r\n    return nodes\r\n  },\r\n\r\n  at(index) {\r\n    if(index >= this.length || index < 0) {\r\n      return\r\n    }\r\n\r\n    for(let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex ++) {\r\n      if(index < this._buffer[nodeIndex].chunk.length) {\r\n        return {\r\n          index,\r\n          nodeIndex\r\n        }\r\n      }\r\n\r\n      index -= this._buffer[nodeIndex].chunk.length\r\n    }\r\n  },\r\n\r\n  buffer(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!this.length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      to = this.at(length)\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n\r\n    const buffer = Buffer.from([], 0, length)\r\n\r\n    const offset = this.nodes(to.nodeIndex).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset += node.chunk.length\r\n    }, 0)\r\n\r\n    if(offset < length) {\r\n      const node = this.nodes(1).shift()\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n      node.chunk = node.chunk.slice(length - offset)\r\n\r\n      this.unshift(node)\r\n    }\r\n\r\n    return buffer\r\n\r\n    // return from.nodeIndex == to.nodeIndex\r\n    //   ? this._buffer[from.nodeIndex].chunk.slice(from.index, to.index)\r\n    //   : Buffer.concat([\r\n    //       this._buffer[from.nodeIndex].chunk.slice(from.index),\r\n    //       ...this._buffer.slice(1 + from.nodeIndex, to.nodeIndex).map(node => node.chunk),\r\n    //       this._buffer[to.nodeIndex].chunk.slice(0, to.index)\r\n    //     ])\r\n  }\r\n}\r\n\r\nexport default BufferState\r\n","export default function series(arr, cb, done) {\r\n  let i = 0\r\n  ;(function next(res) {\r\n    if (res !== undefined || i >= arr.length) {\r\n      done && done(res)\r\n    }\r\n    else {\r\n      setImmediate(() => cb(next, arr[i], i++, arr))\r\n    }\r\n  })()\r\n}\r\n","//import { Writable } from 'stream'\r\nimport BufferState from 'stream/bufferState'\r\n//import Schedule from 'schedule'\r\nimport series from 'series'\r\n\r\nfunction _parse(chunk) {\r\n  const { incoming, watching, frame } = this._busState\r\n\r\n  let currentChunkIndex = 0,\r\n      currentIncomingWatcherIndex = 0,\r\n      incomingIndex = 0,\r\n      isEqual = false,\r\n      isChunkCorrupted = false\r\n\r\n  if(!watching.length) {\r\n    this.emit('error', new Error({\r\n      msg: 'Unexpected incoming data',\r\n      data: chunk\r\n    }))\r\n  }\r\n  else {\r\n    for(;currentChunkIndex < chunk.length; currentChunkIndex ++) {\r\n      frame.push(chunk[currentChunkIndex])\r\n\r\n      if(!incoming.length) {\r\n        for(let watchingIndex in watching) {\r\n          try {\r\n            incoming.push({\r\n              patterns: watching[watchingIndex].patterns,\r\n              callback: watching[watchingIndex].callback,\r\n              currentPattern: watching[watchingIndex].patterns[0] instanceof Function ? watching[watchingIndex].patterns[0]([]) : watching[watchingIndex].patterns[0],\r\n              arrayOffset: 0,\r\n              patternIndex: 0,\r\n              byteIndex: 0,\r\n              length: 0\r\n            })\r\n          } catch(err) {\r\n            this.emit('error', err)\r\n          }\r\n        }\r\n      }\r\n\r\n      for(incomingIndex = 0; incomingIndex < incoming.length;) {\r\n        const incomingI = incoming[incomingIndex],\r\n              expected = incomingI.currentPattern[incomingI.byteIndex]\r\n\r\n        if(expected === undefined || expected === chunk[currentChunkIndex]) {\r\n          isEqual = true\r\n\r\n          incomingI.byteIndex ++\r\n        }\r\n        else if(expected instanceof Array) {\r\n          isEqual = true\r\n\r\n          if(incomingI.arrayOffset <= 0 && expected[0] > 0) {\r\n            incomingI.arrayOffset = expected[0]\r\n          }\r\n\r\n          if(--incomingI.arrayOffset > 0) {\r\n            continue\r\n          }\r\n          else {\r\n            incomingI.byteIndex ++\r\n          }\r\n        }\r\n        else if(expected instanceof Function) {\r\n          try {\r\n            isEqual = !!expected.call(this, chunk[currentChunkIndex], incomingI.length, frame.slice(-incomingI.length - 1))\r\n            incomingI.byteIndex ++\r\n          } catch(err) {\r\n            this.emit('error', err)\r\n            isEqual = false\r\n          }\r\n        }\r\n        else {\r\n          isEqual = false\r\n        }\r\n\r\n        if(isEqual) {\r\n          incomingI.length ++\r\n\r\n          if(incomingI.byteIndex >= incomingI.currentPattern.length) {\r\n            if(++ incomingI.patternIndex >= incomingI.patterns.length) {\r\n              try {\r\n                incomingI.callback.call(\r\n                  this,\r\n                  frame.splice(-incomingI.length),\r\n                  incomingI.pattern\r\n                )\r\n              } catch(err) {\r\n                this.emit('error', err)\r\n              }\r\n\r\n              incoming.splice(0)\r\n              //break\r\n            }\r\n            else {\r\n              const nextPattern = incomingI.patterns[incomingI.patternIndex]\r\n              incomingI.byteIndex = 0\r\n              try {\r\n                if(nextPattern instanceof Function) {\r\n                  incomingI.currentPattern = nextPattern(frame.slice(-incomingI.length))\r\n                }\r\n                else {\r\n                  incomingI.currentPattern = nextPattern\r\n                }\r\n                incomingIndex ++\r\n              } catch(err) {\r\n                this.emit('error', err)\r\n                incoming.splice(incomingIndex, 1)\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            incomingIndex ++\r\n          }\r\n        }\r\n        else {\r\n          incoming.splice(incomingIndex, 1)\r\n        }\r\n      }\r\n\r\n      if(!incoming.length && frame.length) {\r\n        this.emit('error', {\r\n          msg: 'Unparsed chunk',\r\n          data: frame.splice(0)\r\n        })\r\n        /*\r\n        if(!isChunkCorrupted) {\r\n          isChunkCorrupted = true\r\n          setImmediate(() => {\r\n            isChunkCorrupted = false\r\n            this.emit('error', {\r\n              msg: 'Unparsed chunk',\r\n              data: frame.splice(0)\r\n            })\r\n          })\r\n        }*/\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction _Bus(options = {}) {\r\n  this._setup = options.setup.bind(this)\r\n  this.options = {\r\n    highWaterMark: options.highWaterMark || 64\r\n  }\r\n\r\n  this._busState = new BufferState({\r\n    watching: [],\r\n    incoming: [],\r\n    frame: [],\r\n    configured: false\r\n  })\r\n}\r\n\r\n_Bus.prototype = {\r\n  setup () {\r\n    if(this._busState.configured)\r\n      return Promise.reject('already configured')\r\n\r\n    this._busState.configured = true\r\n    return this._setup.apply(this, arguments)\r\n  },\r\n\r\n  parse(chunk) {\r\n    const highWaterMark = this.options.highWaterMark\r\n\r\n    if(chunk.length > highWaterMark) {\r\n      const chunks = []\r\n      let subchunkIndex = 0\r\n\r\n      for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\r\n        const subchunk = chunk.slice(offset, offset += highWaterMark)\r\n        chunks.push(subchunk)\r\n      }\r\n\r\n      series(chunks, (next, subchunk) => {\r\n        _parse.call(this, subchunk)\r\n        next()\r\n      })\r\n    }\r\n    else {\r\n      _parse.apply(this, arguments)\r\n    }\r\n  },\r\n\r\n  watch (patterns, callback) {\r\n    const watcher = {\r\n      patterns,\r\n      callback\r\n    }\r\n\r\n    this._busState.watching.push(watcher)\r\n\r\n    return watcher\r\n  },\r\n\r\n  unwatch (watcher) {\r\n    if(watcher) {\r\n      const index = this._busState.watching.indexOf(watcher)\r\n\r\n      if(index >= 0)\r\n        this._busState.watching.splice(index, 1)\r\n    } else {\r\n      this._busState.watching.splice(0)\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  /**\r\n    * @TODO - Proper unwatch(): delete all previously RXed watchers\r\n    */\r\n  rx(patterns, cb) {\r\n    const watcher = this.watch(patterns, frame => {\r\n      //this.unwatch(watcher)\r\n      const index = this._busState.watching.indexOf(watcher)\r\n\r\n      if(index >= 0)\r\n        this._busState.watching.splice(0, index + 1)\r\n\r\n      cb(frame)\r\n    })\r\n\r\n    return this\r\n  },\r\n\r\n  tx(binary, options = {}) {\r\n    console.log('tx')\r\n    if('timeout' in options) {\r\n      return new Promise((done, fail) => {\r\n        setTimeout(() => {\r\n          this.write(binary)\r\n          done()\r\n        }, options.timeout)\r\n      })\r\n    }\r\n\r\n    this.write(binary)\r\n\r\n    return Promise.resolve()\r\n  },\r\n\r\n  reset () {\r\n    this._busState.frame.splice(0)\r\n    this._busState.incoming.splice(0)\r\n    return this\r\n  }\r\n}\r\n\r\nexport default _Bus\r\n","import EventEmitter from 'events'\r\n\r\nfunction _Schedule() {\r\n  this.pending = Promise.resolve(null)\r\n}\r\n\r\n_Schedule.prototype = {\r\n  immediate(task) {\r\n    this.pending = Promise.all([\r\n      this.pending,\r\n      new Promise((done, fail) => {\r\n        task(done, fail)\r\n      }).catch(err => this.emit('error', err))\r\n    ])\r\n\r\n    return this\r\n  },\r\n\r\n  deferred(task) {\r\n    this.pending = this.pending\r\n      .then(r => new Promise((done, fail) => {\r\n        task(done, fail)\r\n      }))\r\n      .catch(err => this.emit('error', err))\r\n\r\n    return this\r\n  }\r\n}\r\n\r\n// const Schedule = _extend({\r\n//   name: 'Schedule',\r\n//   super: [EventEmitter, _named('Schedule', _Schedule)],\r\n//   apply: [EventEmitter, _named('Schedule', _Schedule)]\r\n// })\r\n\r\nexport default _Schedule\r\n","let status = false\r\nconst defaultInterval = 20\r\n\r\nfunction blink(mode) {\r\n  if(mode === undefined)\r\n    mode = !status\r\n\r\n  !mode\r\n    ? blink.stop()\r\n    : blink.start()\r\n\r\n  return !!status\r\n}\r\n\r\nblink.start = () => {\r\n  if(!status) {\r\n    status = true\r\n\r\n    blink.once(LED2, 20, function cb() {\r\n      if(status) {\r\n        setTimeout(() => blink.once(LED2, 20, cb), 980)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nblink.stop = () => {\r\n  if(status) {\r\n    status = false\r\n  }\r\n}\r\n\r\nblink.once = (led, on = 20, cb) => {\r\n  led.write(true)\r\n  setTimeout(() => {\r\n    led.write(false)\r\n    cb && cb()\r\n  }, on)\r\n}\r\n\r\nexport default blink\r\n","import Bus from 'bus'\r\nimport Schedule from 'schedule'\r\nimport blink from 'blink'\r\nimport { command, ack, nack, info, xinfo, err } from 'nfc'\r\nimport {\r\n  PN532_COMMAND_SAMCONFIGURATION,\r\n  PN532_SAM_NORMAL_MODE,\r\n  PN532_COMMAND_WRITEGPIO,\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  PN532_COMMAND_GETFIRMWAREVERSION,\r\n  PN532_WAKEUP,\r\n  MIFARE_CMD_READ_16,\r\n  MIFARE_CMD_AUTH_A,\r\n  MIFARE_CMD_AUTH_B,\r\n  MIFARE_CMD_WRITE_4,\r\n  MIFARE_CMD_WRITE_16\r\n} from 'nfc/constants'\r\n\r\nimport series from 'series'\r\n\r\nimport { encodeMessage, decodeMessage, textRecord } from 'esp-ndef'\r\n\r\nblink()\r\n\r\nconst encoded = encodeMessage([\r\n  textRecord('2enhello world!')\r\n])\r\n\r\nconst wakeup = command([PN532_WAKEUP])\r\nconst sam = command([PN532_COMMAND_SAMCONFIGURATION, PN532_SAM_NORMAL_MODE, 20, 0])\r\n\r\nfunction rx(data) {\r\n  this._busState.push(data)\r\n  this._busState.nodes().forEach(node => this.parse(node.chunk))\r\n}\r\n\r\nfunction setup(done) {\r\n  Serial1.setup(115200, {\r\n    rx: B7, tx: B6\r\n  })\r\n\r\n  Serial1.write(wakeup)\r\n  Serial1.write(sam)\r\n\r\n  setTimeout(() => {\r\n    Serial1.read()\r\n    Serial1.on('data', rx.bind(this))\r\n  }, 1500)\r\n\r\n  setTimeout(() => {\r\n    blink.once(LED1, 20, () => setTimeout(() => blink.once(LED1, 20), 200))\r\n\r\n    done()\r\n  }, 2000)\r\n}\r\n\r\nconst bus = new Bus({\r\n  setup, highWaterMark: 64\r\n})\r\n\r\nconst schedule = new Schedule()\r\n\r\nbus.on('error', console.error)\r\n\r\nschedule.deferred(setup.bind(bus))\r\n\r\nconst readBlock = (uid, key, block) => {\r\n  const auth = (done, fail) => {\r\n    \"compiled\"\r\n\r\n    const AUTH = command([\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_CMD_AUTH_A,\r\n      block,\r\n      ...key,\r\n      ...uid\r\n    ])\r\n\r\n    bus.rx(ack, ack => {})\r\n\r\n    bus.rx(err, err => {\r\n      console.error(err)\r\n      fail(err)\r\n    })\r\n\r\n    bus.rx(info, frame => {\r\n      console.log('AUTH SUCCEED', {\r\n        code: frame[6],\r\n        body: frame.slice(7, -2)\r\n      })\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(AUTH)\r\n  }\r\n\r\n  const read = (done, fail) => {\r\n    console.log('read')\r\n    const READ = command([\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_CMD_READ_16,\r\n      block\r\n    ])\r\n\r\n    bus.rx(ack, ack => {})\r\n\r\n    bus.rx(err, err => {\r\n      console.error(err)\r\n      fail(err)\r\n    })\r\n\r\n    bus.rx(info, frame => {\r\n      const body = frame.slice(8, -2)\r\n      const data = {\r\n        block,\r\n        status: frame[7],\r\n        body,\r\n        length: body.length\r\n      }\r\n\r\n      done(data)\r\n    })\r\n\r\n    Serial1.write(READ)\r\n  }\r\n\r\n  return Promise.resolve()\r\n    .then(() => new Promise(auth))\r\n    .then(() => new Promise(read))\r\n}\r\n\r\nconst readSector = (uid, key, sector) => {\r\n  return new Promise((done, fail) => {\r\n    const readBlocksArr = []\r\n    for(let block = sector * 4; block < sector * 4 + 4; block ++) {\r\n      readBlocksArr.push(block)\r\n    }\r\n    series(readBlocksArr, (next, block, index) => {\r\n      readBlock(uid, key, block).then(data => {\r\n        readBlocksArr[index] = data\r\n        next()\r\n      })\r\n    }, () => done(readBlocksArr))\r\n  })\r\n}\r\n\r\nconst key = new Uint8ClampedArray([0xff, 0xff, 0xff, 0xff, 0xff, 0xff])\r\n\r\n;(function poll() {\r\n  let uid,\r\n      block = 0,\r\n      data = null\r\n\r\n  schedule.deferred(done => {\r\n    const LIST = command([\r\n      PN532_COMMAND_INLISTPASSIVETARGET,\r\n      1,\r\n      0\r\n    ])\r\n\r\n    bus.rx(ack, () => {\r\n      console.log('ACK')\r\n    })\r\n\r\n    bus.rx(info, frame => {\r\n      const body = frame.slice(7, 5 + frame[3]),\r\n            uidLength = body[5],\r\n            _uid = body.slice(6, 6 + uidLength)\r\n\r\n      console.log('FOUND', {\r\n        code: frame[6],\r\n        body,\r\n        count: body[0],\r\n        ATQA: body.slice(2, 4), // SENS_RES\r\n        SAK: body[4],\r\n        uidLength,\r\n        uid: _uid\r\n      }['ATQA'])\r\n\r\n      uid = _uid\r\n\r\n      done()\r\n    })\r\n\r\n    Serial1.write(LIST)\r\n  })\r\n\r\n  schedule.deferred((done, fail) => {\r\n    readSector(uid, key, 0)\r\n      .then(data => {\r\n        console.log(data)\r\n        return data\r\n      })\r\n      .then(done).catch(console.error)\r\n  })\r\n\r\n  schedule.deferred(done => {\r\n    setTimeout(() => {\r\n      console.log(process.memory().free)\r\n      done()\r\n      poll()\r\n    }, 1000)\r\n  })\r\n})()\r\n","Array.prototype.concat = function () {\r\n  const concatenated = []\r\n\r\n  for(let i in this) {\r\n    concatenated.push(this[i])\r\n  }\r\n\r\n  for(let i in arguments) {\r\n    for(let j in arguments[i]) {\r\n      concatenated.push(arguments[i][j])\r\n    }\r\n  }\r\n\r\n  return concatenated\r\n}\r\n\r\nexport default Array\r\n","// var PENDING = 'pending'\r\n// var SEALED = 'sealed'\r\n// var FULFILLED = 'fulfilled'\r\n// var REJECTED = 'rejected'\r\n//\r\n// var NOOP = function() {}\r\n//\r\n// function invokeResolver(resolver, promise) {\r\n//   function resolvePromise(value) {\r\n//     resolve(promise, value)\r\n//   }\r\n//\r\n//   function rejectPromise(reason) {\r\n//     reject(promise, reason)\r\n//   }\r\n//\r\n//   try {\r\n//     resolver(resolvePromise, rejectPromise)\r\n//   } catch(e) {\r\n//     rejectPromise(e)\r\n//   }\r\n// }\r\n//\r\n// function invokeCallback(subscriber) {\r\n//   var owner = subscriber.owner\r\n//   var settled = owner.state_\r\n//   var value = owner.data_\r\n//   var callback = subscriber[settled]\r\n//   var promise = subscriber.then\r\n//\r\n//   if (typeof callback === 'function')\r\n//   {\r\n//     settled = FULFILLED\r\n//     try {\r\n//       value = callback(value)\r\n//     } catch(e) {\r\n//       reject(promise, e)\r\n//     }\r\n//   }\r\n//\r\n//   if (!handleThenable(promise, value))\r\n//   {\r\n//     if (settled === FULFILLED)\r\n//       resolve(promise, value)\r\n//\r\n//     if (settled === REJECTED)\r\n//       reject(promise, value)\r\n//   }\r\n// }\r\n//\r\n// function handleThenable(promise, value) {\r\n//   var resolved\r\n//\r\n//   try {\r\n//     if (promise === value)\r\n//       throw new TypeError('A promises callback cannot return that same promise.')\r\n//\r\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\r\n//     {\r\n//       var then = value.then  // then should be retrived only once\r\n//\r\n//       if (typeof then === 'function')\r\n//       {\r\n//         then.call(value, function(val){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             if (value !== val)\r\n//               resolve(promise, val)\r\n//             else\r\n//               fulfill(promise, val)\r\n//           }\r\n//         }, function(reason){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             reject(promise, reason)\r\n//           }\r\n//         })\r\n//\r\n//         return true\r\n//       }\r\n//     }\r\n//   } catch (e) {\r\n//     if (!resolved)\r\n//       reject(promise, e)\r\n//\r\n//     return true\r\n//   }\r\n//\r\n//   return false\r\n// }\r\n//\r\n// function resolve(promise, value){\r\n//   if (promise === value || !handleThenable(promise, value))\r\n//     fulfill(promise, value)\r\n// }\r\n//\r\n// function publish(promise) {\r\n//   var callbacks = promise.then_\r\n//   promise.then_ = undefined\r\n//\r\n//   for (var i = 0 i < callbacks.length i++) {\r\n//     invokeCallback(callbacks[i])\r\n//   }\r\n// }\r\n//\r\n// function fulfill(promise, value){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = value\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = FULFILLED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function reject(promise, reason){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = reason\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = REJECTED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function Promise(resolver) {\r\n//   if (typeof resolver !== 'function')\r\n//     throw new TypeError('Promise constructor takes a function argument')\r\n//\r\n//   if (this instanceof Promise === false)\r\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\r\n//\r\n//   this.then_ = []\r\n//\r\n//   invokeResolver(resolver, this)\r\n// }\r\n//\r\n// Promise.prototype = {\r\n//   constructor: Promise,\r\n//\r\n//   state_: PENDING,\r\n//   then_: null,\r\n//   data_: undefined,\r\n//\r\n//   then: function(onFulfillment, onRejection){\r\n//     var subscriber = {\r\n//       owner: this,\r\n//       then: new this.constructor(NOOP),\r\n//       fulfilled: onFulfillment,\r\n//       rejected: onRejection\r\n//     }\r\n//\r\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\r\n//     {\r\n//       // already resolved, call callback async\r\n//       setImmediate(() => {invokeCallback(subscriber)})\r\n//     }\r\n//     else\r\n//     {\r\n//       // subscribe\r\n//       this.then_.push(subscriber)\r\n//     }\r\n//\r\n//     return subscriber.then\r\n//   },\r\n//\r\n//   'catch': function(onRejection) {\r\n//     return this.then(null, onRejection)\r\n//   }\r\n// }\r\n//\r\n// Promise.all = function(promises) {\r\n//   if (!(promises instanceof Array))\r\n//     throw new TypeError('You must pass an array to Promise.all().')\r\n//\r\n//   return new Promise((resolve, reject) => {\r\n//     var results = []\r\n//     var remaining = 0\r\n//\r\n//     function resolver(index){\r\n//       remaining++\r\n//       return function(value){\r\n//         results[index] = value\r\n//         if (!--remaining)\r\n//           resolve(results)\r\n//       }\r\n//     }\r\n//\r\n//     for (var i = 0, promise; i < promises.length; i++) {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function')\r\n//         promise.then(resolver(i), reject)\r\n//       else\r\n//         results[i] = promise\r\n//     }\r\n//\r\n//     if (!remaining)\r\n//       resolve(results)\r\n//   })\r\n// }\r\n\r\nPromise.race = function(promises){\r\n  var Class = this\r\n\r\n  if (!(promises instanceof Array))\r\n    throw new TypeError('You must pass an array to Promise.race().')\r\n\r\n  return new Class((resolve, reject) => {\r\n    for (var i = 0, promise; i < promises.length; i++)\r\n    {\r\n      promise = promises[i]\r\n\r\n      if (promise && typeof promise.then === 'function')\r\n        promise.then(resolve, reject)\r\n      else\r\n        resolve(promise)\r\n    }\r\n  })\r\n}\r\n\r\n// Promise.resolve = function(value) {\r\n//   var Class = this\r\n//\r\n//   if (value && typeof value === 'object' && value.constructor === Class)\r\n//     return value\r\n//\r\n//   return new Class(function(resolve){\r\n//     resolve(value)\r\n//   })\r\n// }\r\n//\r\n// Promise.reject = function(reason){\r\n//   var Class = this\r\n//\r\n//   return new Class(function(resolve, reject){\r\n//     reject(reason)\r\n//   })\r\n// }\r\n//\r\n\r\nexport default Promise\r\n","Object.assign = (target, ...args) => {\r\n  for(let i in args) {\r\n    const obj = args[i]\r\n    if(obj instanceof Object)\r\n      for(let key in obj) {\r\n        target[key] = obj[key]\r\n      }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\n//Object.freeze = obj => obj\r\n\r\nexport default Object\r\n","const PUSH_TO_QUEUE_IMMEDIATE = 0,\r\n      PUSH_AT_NEXT_STAGE = 1,\r\n      loop = [\r\n        // nextTick\r\n        { queue: [], immediatePush: true, tick: false },\r\n        // immediate\r\n        { queue: [], immediatePush: true, tick: false },\r\n        // timeout\r\n        { queue: [], immediatePush: false, tick: false }\r\n      ]\r\n\r\nlet tick = false,\r\n    timers = {}\r\n\r\nconst asyncFlush = () => {\r\n  for (let stage in loop) {\r\n    if(loop[stage].queue.length) {\r\n      if(loop[stage].immediatePush) {\r\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\r\n          loop[stage].queue[exec]()\r\n        }\r\n        loop[stage].queue.splice(0)\r\n      } else {\r\n        const queue = loop[stage].queue.splice(0)\r\n        for (let exec = 0; exec < queue.length; exec ++) {\r\n          queue[exec]()\r\n        }\r\n      }\r\n    }\r\n\r\n    loop[stage].tick = tick = false\r\n  }\r\n}\r\n\r\nconst asyncCall = stage => cb => {\r\n  loop[stage].queue.push(cb)\r\n\r\n  if (!tick && !loop[stage].tick) {\r\n    loop[stage].tick = tick = true\r\n\r\n    setTimeout(asyncFlush)\r\n  }\r\n}\r\n\r\nconst nextTick = asyncCall(/* .nextTick */0)\r\n\r\nconst setImmediate = asyncCall(/* .immediate */1)\r\n\r\nconst timeoutCall = asyncCall(/* .timeeout */2)\r\n\r\nexport const _setTimeout = (cb, timeout) => {\r\n  // let index = 0\r\n  // while(timers[index]) {\r\n  //   index++\r\n  // }\r\n  // timers[index] = setTimeout(() => {\r\n  //   if(timers[index]) {\r\n  //     delete timers[index]\r\n  //     timeoutCall(cb)\r\n  //   }\r\n  // }, timeout)\r\n  //\r\n  // return index\r\n\r\n  return setTimeout(() => {\r\n    timeoutCall(cb)\r\n  }, timeout)\r\n}\r\n\r\nexport const _setInterval = (cb, timeout) => {\r\n  return (function setTimer() {\r\n    return _setTimeout(() => {\r\n      setTimer()\r\n      cb()\r\n    }, timeout)\r\n  })()\r\n}\r\n\r\nexport {\r\n  nextTick,\r\n  setImmediate,\r\n  _setTimeout as setTimeout,\r\n  _setInterval as setInterval\r\n}\r\n","import {\r\n  PN532_PREAMBLE,\r\n  PN532_STARTCODE1,\r\n  PN532_STARTCODE2,\r\n  PN532_HOST_TO_PN532,\r\n  PN532_PN532_TO_HOST,\r\n  PN532_POSTAMBLE\r\n} from './constants'\r\n\r\nconst check = values => !(0xff & (-values.reduce((sum, value) => sum + value, 0x00)))\r\n\r\nconst LCS_std = (byte, length, frame) => check(frame.slice(-2))\r\n\r\nconst LCS_ext = (byte, length, frame) => check([frame[5] * 256 + frame[6], frame[7]])\r\n\r\nconst CHECKSUM_std = (byte, length, frame) => check(frame.slice(5))\r\n\r\nconst CHECKSUM_ext = (byte, length, frame) => check(frame.slice(8))\r\n\r\nconst BODY_std = frame => {\r\n  const arr = []\r\n  for(let i = 0; i < frame[3] - 1; i ++)\r\n    arr.push(undefined)\r\n  return arr\r\n}\r\n\r\nconst BODY_ext = frame => {\r\n  const arr = [], length = frame[5] * 256 + frame[6]\r\n  for(let i = 0; i < length - 1; i ++)\r\n    arr.push(undefined)\r\n  return arr\r\n}\r\n\r\nexport const info = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, undefined, LCS_std, PN532_PN532_TO_HOST],\r\n  BODY_std,\r\n  [CHECKSUM_std, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const xinfo = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0xff, undefined, undefined, LCS_ext, PN532_PN532_TO_HOST],\r\n  BODY_ext,\r\n  [CHECKSUM_ext, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const err = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1 , PN532_STARTCODE2, 0x01, 0xff, undefined, CHECKSUM_std, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const ack = [\r\n  new Uint8ClampedArray([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x00, 0xff, PN532_POSTAMBLE])\r\n]\r\n\r\nexport const nack = [\r\n  new Uint8ClampedArray([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0x00, PN532_POSTAMBLE])\r\n]\r\n\r\nexport const command = command =>\r\n  new Uint8ClampedArray([\r\n    PN532_PREAMBLE,\r\n    PN532_STARTCODE1,\r\n    PN532_STARTCODE2,\r\n    0xff & (command.length + 1),\r\n    0xff & (~command.length),\r\n    PN532_HOST_TO_PN532,\r\n    ...command,\r\n    // checksum\r\n    0xff & (-command.reduce((checksum, byte) => checksum + byte, PN532_HOST_TO_PN532)),\r\n    PN532_POSTAMBLE\r\n  ])\r\n","var data = { TNF_EMPTY: 0,\r\n  TNF_WELL_KNOWN: 1,\r\n  TNF_MIME_MEDIA: 2,\r\n  TNF_ABSOLUTE_URI: 3,\r\n  TNF_EXTERNAL_TYPE: 4,\r\n  TNF_UNKNOWN: 5,\r\n  TNF_UNCHANGED: 6,\r\n  TNF_RESERVED: 7,\r\n  RTD_TEXT: \"T\",\r\n  RTD_URI: \"U\",\r\n  RTD_SMART_POSTER: \"Sp\",\r\n  RTD_ALTERNATIVE_CARRIER: \"ac\",\r\n  RTD_HANDOVER_CARRIER: \"Hc\",\r\n  RTD_HANDOVER_REQUEST: \"Hr\",\r\n  RTD_HANDOVER_SELECT: \"Hs\",\r\n  BLOCK_SIZE: 16,\r\n  TLV_START: 64,\r\n  TL_LENGTH: 4 };\r\n\r\n/**\r\n  * decode text bytes from ndef record payload\r\n  *\r\n  * @returns a string\r\n  */\r\nvar decode = function decode(data) {\r\n    var languageCodeLength = data[0] & 0x3F,\r\n        // 6 LSBs\r\n    languageCode = data.slice(1, 1 + languageCodeLength),\r\n        utf16 = (data[0] & 0x80) !== 0; // assuming UTF-16BE\r\n\r\n    // TODO need to deal with UTF in the future\r\n    // console.log(\"lang \" + languageCode + (utf16 ? \" utf16\" : \" utf8\"))\r\n\r\n    return Buffer.from(data.slice(languageCodeLength + 1)).toString();\r\n};\r\n\r\n/**\r\n  * Encode text payload\r\n  *\r\n  * @returns an array of bytes\r\n  */\r\nvar encode = function encode(text, lang, encoding) {\r\n    // ISO/IANA language code, but we're not enforcing\r\n    if (!lang) {\r\n        lang = 'en';\r\n    }\r\n\r\n    var encoded = Buffer.from([lang.length].concat([].slice.call(Buffer.from(lang + text))));\r\n\r\n    return encoded;\r\n};\r\n\r\n// URI identifier codes from URI Record Type Definition NFCForum-TS-RTD_URI_1.0 2006-07-24\r\n// index in array matches code in the spec\r\nvar protocols = [\"\", \"http://www.\", \"https://www.\", \"http://\", \"https://\", \"tel:\", \"mailto:\", \"ftp://anonymous:anonymous@\", \"ftp://ftp.\", \"ftps://\", \"sftp://\", \"smb://\", \"nfs://\", \"ftp://\", \"dav://\", \"news:\", \"telnet://\", \"imap:\", \"rtsp://\", \"urn:\", \"pop:\", \"sip:\", \"sips:\", \"tftp:\", \"btspp://\", \"btl2cap://\", \"btgoep://\", \"tcpobex://\", \"irdaobex://\", \"file://\", \"urn:epc:id:\", \"urn:epc:tag:\", \"urn:epc:pat:\", \"urn:epc:raw:\", \"urn:epc:\", \"urn:nfc:\"];\r\n\r\n/**\r\n  * @returns a string\r\n  */\r\nvar decode$1 = function decode(data) {\r\n    var prefix = protocols[data[0]];\r\n    if (!prefix) {\r\n        // 36 to 255 should be \"\"\r\n        prefix = \"\";\r\n    }\r\n    return prefix + Buffer.from(data.slice(1)).toString();\r\n};\r\n\r\n/**\r\n  * shorten a URI with standard prefix\r\n  *\r\n  * @returns an array of bytes\r\n  */\r\nvar encode$1 = function encode(uri) {\r\n    var prefix, protocolCode, encoded;\r\n\r\n    // check each protocol, unless we've found a match\r\n    // \"urn:\" is the one exception where we need to keep checking\r\n    // slice so we don't check \"\"\r\n    protocols.slice(1).forEach(function (protocol) {\r\n        if ((!prefix || prefix === \"urn:\") && uri.indexOf(protocol) === 0) {\r\n            prefix = protocol;\r\n        }\r\n    });\r\n\r\n    if (!prefix) {\r\n        prefix = \"\";\r\n    }\r\n\r\n    protocolCode = protocols.indexOf(prefix);\r\n    encoded = Buffer.from([protocolCode].concat([].slice.call(Buffer.from(uri.slice(prefix.length)))));\r\n\r\n    return encoded;\r\n};\r\n\r\n// ndef.js\r\n// Copyright 2013 Don Coleman\r\n//\r\n// This code is from phonegap-nfc.js https://github.com/don/phonegap-nfc\r\n\r\n// see android.nfc.NdefRecord for documentation about constants\r\n// http://developer.android.com/reference/android/nfc/NdefRecord.html\r\n\r\n// convert bytes to a String\r\nvar s = function s(bytes) {\r\n  return Buffer.from(bytes).toString();\r\n};\r\n\r\n/**\r\n * Creates a JSON representation of a NDEF Record.\r\n *\r\n * @tnf 3-bit TNF (Type Name Format) - use one of the constants.TNF_* constants\r\n * @type byte array, containing zero to 255 bytes, must not be null\r\n * @id byte array, containing zero to 255 bytes, must not be null\r\n * @payload byte array, containing zero to (2 ** 32 - 1) bytes, must not be null\r\n *\r\n * @returns JSON representation of a NDEF record\r\n *\r\n * @see Ndef.textRecord, Ndef.uriRecord and Ndef.mimeMediaRecord for examples\r\n */\r\n\r\nvar record = function record(tnf, type, id, payload, value) {\r\n  if (!tnf) {\r\n    tnf = data.TNF_EMPTY;\r\n  }\r\n  if (!type) {\r\n    type = [];\r\n  }\r\n  if (!id) {\r\n    id = [];\r\n  }\r\n  if (!payload) {\r\n    payload = [];\r\n  }\r\n  // store type as String so it's easier to compare\r\n  if (type instanceof Array) {\r\n    type = Buffer.from(type).toString();\r\n  }\r\n\r\n  // in the future, id could be a String\r\n  if (!(id instanceof Array)) {\r\n    id = Buffer.from(id);\r\n  }\r\n\r\n  // Payload must be binary\r\n  if (!(payload instanceof Array)) {\r\n    payload = Buffer.from(payload);\r\n  }\r\n\r\n  // Experimental feature\r\n  // Convert payload to text for Text and URI records\r\n  if (tnf == data.TNF_WELL_KNOWN) {\r\n    if (type == data.RTD_TEXT) {\r\n      value = decode(payload);\r\n    } else if (type == data.RTD_URI) {\r\n      value = decode$1(payload);\r\n    }\r\n  }\r\n\r\n  return {\r\n    tnf: tnf,\r\n    type: type,\r\n    id: id,\r\n    payload: payload,\r\n    value: value\r\n  };\r\n};\r\n\r\n/**\r\n * Helper that creates an NDEF record containing plain text.\r\n *\r\n * @text String of text to encode\r\n * @languageCode ISO/IANA language code. Examples: “fi”, “en-US”, “fr-CA”, “jp”. (optional)\r\n * @id byte[] (optional)\r\n */\r\nvar textRecord = function textRecord(text, languageCode, id) {\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_TEXT, id || [], encode(text, languageCode));\r\n};\r\n\r\n/**\r\n * Helper that creates a NDEF record containing a URI.\r\n *\r\n * @uri String\r\n * @id byte[] (optional)\r\n */\r\nvar uriRecord = function uriRecord(uri, id) {\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_URI, id || [], encode$1(uri));\r\n};\r\n\r\n/**\r\n * Helper that creates a NDEF record containing an absolute URI.\r\n *\r\n * An Absolute URI record means the URI describes the payload of the record.\r\n *\r\n * For example a SOAP message could use \"http://schemas.xmlsoap.org/soap/envelope/\"\r\n * as the type and XML content for the payload.\r\n *\r\n * Absolute URI can also be used to write LaunchApp records for Windows.\r\n *\r\n * See 2.4.2 Payload Type of the NDEF Specification\r\n * http://www.nfc-forum.org/specs/spec_list#ndefts\r\n *\r\n * Note that by default, Android will open the URI defined in the type\r\n * field of an Absolute URI record (TNF=3) and ignore the payload.\r\n * BlackBerry and Windows do not open the browser for TNF=3.\r\n *\r\n * To write a URI as the payload use ndef.uriRecord(uri)\r\n *\r\n * @uri String\r\n * @payload byte[] or String\r\n * @id byte[] (optional)\r\n */\r\nvar absoluteUriRecord = function absoluteUriRecord(uri, payload, id) {\r\n  return record(data.TNF_ABSOLUTE_URI, uri, id || [], payload || []);\r\n};\r\n\r\n/**\r\n* Helper that creates a NDEF record containing an mimeMediaRecord.\r\n*\r\n* @mimeType String\r\n* @payload byte[]\r\n* @id byte[] (optional)\r\n*/\r\nvar mimeMediaRecord = function mimeMediaRecord(mimeType, payload, id) {\r\n  return record(data.TNF_MIME_MEDIA, mimeType, id || [], payload || []);\r\n};\r\n\r\n/**\r\n* Helper that creates an NDEF record containing an Smart Poster.\r\n*\r\n* @ndefRecords array of NDEF Records\r\n* @id byte[] (optional)\r\n*/\r\nvar smartPoster = function smartPoster(ndefRecords, id) {\r\n  var payload = [];\r\n\r\n  if (ndefRecords) {\r\n    // make sure we have an array of something like NDEF records before encoding\r\n    if (ndefRecords[0] instanceof Object && ndefRecords[0].hasOwnProperty('tnf')) {\r\n      payload = encodeMessage(ndefRecords);\r\n    } else {\r\n      // assume the caller has already encoded the NDEF records into a byte array\r\n      payload = ndefRecords;\r\n    }\r\n  } else {\r\n    //console.warn(\"WARNING: Expecting an array of NDEF records\")\r\n    throw new Error('Expecting an array of NDEF records');\r\n  }\r\n\r\n  return record(data.TNF_WELL_KNOWN, data.RTD_SMART_POSTER, id, payload);\r\n};\r\n\r\n/**\r\n* Helper that creates an empty NDEF record.\r\n*\r\n*/\r\nvar emptyRecord = function emptyRecord() {\r\n  return record(data.TNF_EMPTY, [], [], []);\r\n};\r\n\r\n/**\r\n* Helper that creates an Android Application Record (AAR).\r\n* http://developer.android.com/guide/topics/connectivity/nfc/nfc.html#aar\r\n*\r\n*/\r\nvar androidApplicationRecord = function androidApplicationRecord(packageName) {\r\n  return record(data.TNF_EXTERNAL_TYPE, 'android.com:pkg', [], packageName);\r\n};\r\n\r\n/**\r\n* Encodes an NDEF Message into bytes that can be written to a NFC tag.\r\n*\r\n* @ndefRecords an Array of NDEF Records\r\n*\r\n* @returns byte array\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\r\nvar encodeMessage = function encodeMessage(ndefRecords) {\r\n  var encoded = [],\r\n      tnf_byte = void 0,\r\n      record_type = void 0,\r\n      payload_length = void 0,\r\n      id_length = void 0,\r\n      i = void 0,\r\n      mb = void 0,\r\n      me = void 0,\r\n      // messageBegin, messageEnd\r\n  cf = false,\r\n      // chunkFlag TODO implement\r\n  sr = void 0,\r\n      // boolean shortRecord\r\n  il = void 0; // boolean idLengthFieldIsPresent\r\n\r\n  for (i = 0; i < ndefRecords.length; i++) {\r\n    mb = i === 0;\r\n    me = i === ndefRecords.length - 1;\r\n    sr = ndefRecords[i].payload.length < 0xFF;\r\n    il = ndefRecords[i].id.length > 0;\r\n    tnf_byte = encodeTnf(mb, me, cf, sr, il, ndefRecords[i].tnf);\r\n    encoded.push(tnf_byte);\r\n\r\n    // type is stored as String, converting to bytes for storage\r\n    record_type = [].slice.call(Buffer.from(ndefRecords[i].type));\r\n    encoded.push(record_type.length);\r\n\r\n    if (sr) {\r\n      payload_length = ndefRecords[i].payload.length;\r\n      encoded.push(payload_length);\r\n    } else {\r\n      payload_length = ndefRecords[i].payload.length;\r\n      // 4 bytes\r\n      encoded.push(payload_length >> 24);\r\n      encoded.push(payload_length >> 16);\r\n      encoded.push(payload_length >> 8);\r\n      encoded.push(payload_length & 0xFF);\r\n    }\r\n\r\n    if (il) {\r\n      id_length = ndefRecords[i].id.length;\r\n      encoded.push(id_length);\r\n    }\r\n\r\n    encoded = encoded.concat(record_type);\r\n\r\n    if (il) {\r\n      encoded = encoded.concat(ndefRecords[i].id);\r\n    }\r\n\r\n    encoded = encoded.concat([].slice.call(ndefRecords[i].payload));\r\n  }\r\n\r\n  return encoded;\r\n};\r\n\r\n/**\r\n* Decodes an array bytes into an NDEF Message\r\n*\r\n* @bytes an array bytes read from a NFC tag\r\n*\r\n* @returns array of NDEF Records\r\n*\r\n* @see NFC Data Exchange Format (NDEF) http://www.nfc-forum.org/specs/spec_list/\r\n*/\r\nvar decodeMessage = function decodeMessage(_bytes) {\r\n  var bytes = _bytes.slice(0),\r\n      // clone since parsing is destructive\r\n  ndef_message = [],\r\n      tnf_byte = void 0,\r\n      header = void 0,\r\n      type_length = 0,\r\n      payload_length = 0,\r\n      id_length = 0,\r\n      record_type = [],\r\n      id = [],\r\n      payload = [];\r\n\r\n  while (bytes.length) {\r\n    tnf_byte = bytes.shift();\r\n    header = decodeTnf(tnf_byte);\r\n\r\n    type_length = bytes.shift();\r\n\r\n    if (header.sr) {\r\n      payload_length = bytes.shift();\r\n    } else {\r\n      // next 4 bytes are length\r\n      payload_length = (0xFF & bytes.shift()) << 24 | (0xFF & bytes.shift()) << 16 | (0xFF & bytes.shift()) << 8 | 0xFF & bytes.shift();\r\n    }\r\n\r\n    if (header.il) {\r\n      id_length = bytes.shift();\r\n    }\r\n\r\n    record_type = bytes.splice(0, type_length);\r\n    id = bytes.splice(0, id_length);\r\n    payload = bytes.splice(0, payload_length);\r\n\r\n    ndef_message.push(record(header.tnf, record_type, id, payload));\r\n\r\n    if (header.me) {\r\n      // last message\r\n      break;\r\n    }\r\n  }\r\n\r\n  return ndef_message;\r\n};\r\n\r\n/**\r\n* Decode the bit flags from a TNF Byte.\r\n*\r\n* @returns object with decoded data\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\r\nvar decodeTnf = function decodeTnf(tnf_byte) {\r\n  return {\r\n    mb: (tnf_byte & 0x80) !== 0,\r\n    me: (tnf_byte & 0x40) !== 0,\r\n    cf: (tnf_byte & 0x20) !== 0,\r\n    sr: (tnf_byte & 0x10) !== 0,\r\n    il: (tnf_byte & 0x8) !== 0,\r\n    tnf: tnf_byte & 0x7\r\n  };\r\n};\r\n\r\n/**\r\n* Encode NDEF bit flags into a TNF Byte.\r\n*\r\n* @returns tnf byte\r\n*\r\n*  See NFC Data Exchange Format (NDEF) Specification Section 3.2 RecordLayout\r\n*/\r\nvar encodeTnf = function encodeTnf(mb, me, cf, sr, il, tnf, value) {\r\n  if (!value) {\r\n    value = tnf;\r\n  }\r\n\r\n  if (mb) {\r\n    value = value | 0x80;\r\n  }\r\n\r\n  if (me) {\r\n    value = value | 0x40;\r\n  }\r\n\r\n  // note if cf: me, mb, li must be false and tnf must be 0x6\r\n  if (cf) {\r\n    value = value | 0x20;\r\n  }\r\n\r\n  if (sr) {\r\n    value = value | 0x10;\r\n  }\r\n\r\n  if (il) {\r\n    value = value | 0x8;\r\n  }\r\n\r\n  return value;\r\n};\r\n\r\n// TODO test with byte[] and string\r\nvar isType = function isType(record, tnf, type) {\r\n  return record.tnf === tnf ? s(record) === s(type) : false;\r\n};\r\n\r\n// export const tnfToString = (tnf, value = tnf) => {\r\n//   if(tnf == constants.TNF_EMPTY) {\r\n//     value = \"Empty\"\r\n//   }\r\n//   else if(constants.TNF_WELL_KNOWN) {\r\n//     value = \"Well Known\"\r\n//   }\r\n//   else if(constants.TNF_MIME_MEDIA) {\r\n//     value = \"Mime Media\"\r\n//   }\r\n//   else if(constants.TNF_ABSOLUTE_URI) {\r\n//     value = \"Absolute URI\"\r\n//   }\r\n//   else if(constants.TNF_EXTERNAL_TYPE) {\r\n//     value = \"External\"\r\n//   }\r\n//   else if(constants.TNF_UNKNOWN) {\r\n//     value = \"Unknown\"\r\n//   }\r\n//   else if(constants.TNF_UNCHANGED) {\r\n//     value = \"Unchanged\"\r\n//   }\r\n//   else if(constants.TNF_RESERVED) {\r\n//     value = \"Reserved\"\r\n//   }\r\n//   return value\r\n// }\r\n\r\n// Convert NDEF records and messages to strings\r\n// This works OK for demos, but real code proably needs\r\n// a custom implementation. It would be nice to make\r\n// smarter record objects that can print themselves\r\n// var stringifier = {\r\n//     stringify: function (data, separator) {\r\n//       if (Array.isArray(data)) {\r\n//         if (typeof data[0] === 'number') {\r\n//           // guessing this message bytes\r\n//           data = decodeMessage(data)\r\n//         }\r\n//\r\n//         return stringifier.printRecords(data, separator)\r\n//       } else {\r\n//         return stringifier.printRecord(data, separator)\r\n//       }\r\n//     },\r\n//\r\n//     // @message - NDEF Message (array of NDEF Records)\r\n//     // @separator - line separator, optional, defaults to \\n\r\n//     // @returns string with NDEF Message\r\n//     printRecords: function (message, separator) {\r\n//\r\n//         if(!separator) { separator = \"\\n\" }\r\n//         result = \"\"\r\n//\r\n//         // Print out the payload for each record\r\n//         message.forEach(function(record) {\r\n//             result += stringifier.printRecord(record, separator)\r\n//             result += separator\r\n//         })\r\n//\r\n//         return result.slice(0, (-1 * separator.length))\r\n//     },\r\n//\r\n//     // @record - NDEF Record\r\n//     // @separator - line separator, optional, defaults to \\n\r\n//     // @returns string with NDEF Record\r\n//     printRecord: function (record, separator) {\r\n//\r\n//         var result = \"\"\r\n//\r\n//         if(!separator) { separator = \"\\n\" }\r\n//\r\n//         switch(record.tnf) {\r\n//             case ndef.constants.TNF_EMPTY:\r\n//                 result += \"Empty Record\"\r\n//                 result += separator\r\n//                 break\r\n//             case ndef.constants.TNF_WELL_KNOWN:\r\n//                 result += stringifier.printWellKnown(record, separator)\r\n//                 break\r\n//             case ndef.constants.TNF_MIME_MEDIA:\r\n//                 result += \"MIME Media\"\r\n//                 result += separator\r\n//                 result += s(record.type)\r\n//                 result += separator\r\n//                 result += s(record.payload) // might be binary\r\n//                 break\r\n//             case ndef.constants.TNF_ABSOLUTE_URI:\r\n//                 result += \"Absolute URI\"\r\n//                 result += separator\r\n//                 result += s(record.type)    // the URI is the type\r\n//                 result += separator\r\n//                 result += s(record.payload) // might be binary\r\n//                 break\r\n//             case ndef.constants.TNF_EXTERNAL_TYPE:\r\n//                 // AAR contains strings, other types could\r\n//                 // contain binary data\r\n//                 result += \"External\"\r\n//                 result += separator\r\n//                 result += s(record.type)\r\n//                 result += separator\r\n//                 result += s(record.payload)\r\n//                 break\r\n//             default:\r\n//                 result += s(\"Can't process TNF \" + record.tnf)\r\n//         }\r\n//\r\n//         result += separator\r\n//         return result\r\n//     },\r\n//\r\n//     printWellKnown: function (record, separator) {\r\n//\r\n//         var result = \"\"\r\n//\r\n//         if (record.tnf !== ndef.constants.TNF_WELL_KNOWN) {\r\n//             return \"ERROR expecting TNF Well Known\"\r\n//         }\r\n//\r\n//         switch(record.type) {\r\n//             case ndef.constants.RTD_TEXT:\r\n//                 result += \"Text Record\"\r\n//                 result += separator\r\n//                 result += (ndef.text.decodePayload(record.payload))\r\n//                 break\r\n//             case ndef.constants.RTD_URI:\r\n//                 result += \"URI Record\"\r\n//                 result += separator\r\n//                 result += (ndef.uri.decodePayload(record.payload))\r\n//                 break\r\n//             case ndef.constants.RTD_SMART_POSTER:\r\n//                 result += \"Smart Poster\"\r\n//                 result += separator\r\n//                 // the payload of a smartposter is a NDEF message\r\n//                 result += stringifier.printRecords(ndef.decodeMessage(record.payload))\r\n//                 break\r\n//             default:\r\n//                 // attempt to display other types\r\n//                 result += record.type + \" Record\"\r\n//                 result += separator\r\n//                 result += s(record.payload)\r\n//         }\r\n//\r\n//         return result\r\n//     }\r\n// }\r\n//\r\n// export const stringify = { stringifier }\r\n\r\nexport { data as constants, record, textRecord, uriRecord, absoluteUriRecord, mimeMediaRecord, smartPoster, emptyRecord, androidApplicationRecord, encodeMessage, decodeMessage, decodeTnf, encodeTnf, isType };\r\n"],"names":["time","label","Date","now","timeEnd","timers","log","toFixed","Buffer","Error","BufferState","options","assign","this","series","arr","cb","done","i","next","res","undefined","length","_parse","chunk","_busState","incoming","watching","frame","currentChunkIndex","incomingIndex","isEqual","push","watchingIndex","patterns","callback","Function","err","emit","incomingI","expected","currentPattern","byteIndex","Array","arrayOffset","call","slice","patternIndex","splice","pattern","nextPattern","_Bus","_setup","setup","bind","highWaterMark","_Schedule","pending","Promise","resolve","blink","mode","status","start","stop","rx","data","nodes","forEach","_this","parse","node","B7","tx","B6","write","wakeup","sam","read","on","once","LED1","setTimeout","console","error","prototype","concat","concatenated","arguments","j","race","promises","Class","TypeError","reject","promise","then","from","iterable","c","charCodeAt","Proto","offset","array","list","totalLength","reduce","buffer","set","buf","Object","target","args","obj","key","_buffer","unshift","count","index","nodeIndex","to","at","shift","loop","queue","immediatePush","tick","asyncFlush","stage","exec","asyncCall","nextTick","setImmediate","timeoutCall","configured","apply","chunks","bytesLeft","subchunk","watcher","indexOf","watch","_this2","binary","fail","timeout","task","all","catch","LED2","led","check","values","sum","value","LCS_std","byte","CHECKSUM_std","BODY_std","info","PN532_PREAMBLE","PN532_STARTCODE1","PN532_STARTCODE2","PN532_PN532_TO_HOST","PN532_POSTAMBLE","ack","Uint8ClampedArray","command","PN532_HOST_TO_PN532","checksum","TNF_EMPTY","TNF_WELL_KNOWN","TNF_MIME_MEDIA","TNF_ABSOLUTE_URI","TNF_EXTERNAL_TYPE","TNF_UNKNOWN","TNF_UNCHANGED","TNF_RESERVED","RTD_TEXT","RTD_URI","RTD_SMART_POSTER","RTD_ALTERNATIVE_CARRIER","RTD_HANDOVER_CARRIER","RTD_HANDOVER_REQUEST","RTD_HANDOVER_SELECT","BLOCK_SIZE","TLV_START","TL_LENGTH","decode","languageCodeLength","toString","encode","text","lang","encoding","protocols","decode$1","prefix","record","tnf","type","id","payload","textRecord","languageCode","encodeMessage","ndefRecords","encoded","tnf_byte","record_type","payload_length","id_length","mb","me","sr","il","encodeTnf","cf","PN532_WAKEUP","PN532_COMMAND_SAMCONFIGURATION","PN532_SAM_NORMAL_MODE","bus","Bus","schedule","Schedule","deferred","readBlock","uid","block","auth","AUTH","PN532_COMMAND_INDATAEXCHANGE","MIFARE_CMD_AUTH_A","READ","MIFARE_CMD_READ_16","body","readSector","sector","readBlocksArr","poll","LIST","PN532_COMMAND_INLISTPASSIVETARGET","uidLength","_uid","process","memory","free"],"mappings":"aAEA,SAASA,KAAKC,UACLA,GAASC,KAAKC,MAGvB,SAASC,QAAQH,GACZA,KAASI,iBACFC,IAAQL,QAAaC,KAAKC,MAAQE,OAAOJ,IAAQM,QAAQ,gBAC1DF,OAAOJ,ICOlB,SAASO,eACF,IAAIC,MAAM,gECjBjB,SAASC,kBAAYC,mEACZC,OAAOC,wBAEN,GACNF,GCJW,SAASG,OAAOC,EAAKC,EAAIC,OAClCC,EAAI,GACP,SAAUC,EAAKC,QACFC,IAARD,GAAqBF,GAAKH,EAAIO,UACxBL,EAAKG,gBAGA,kBAAMJ,EAAGG,EAAMJ,EAAIG,GAAIA,IAAKH,KAL5C,GCCH,SAESQ,OAAOC,SACwBX,KAAKY,UAAnCC,IAAAA,SAAUC,IAAAA,SAAUC,IAAAA,MAExBC,EAAoB,EAEpBC,EAAgB,EAChBC,GAAU,KAGVJ,EAASL,YAONO,EAAoBL,EAAMF,OAAQO,IAAsB,MACrDG,KAAKR,EAAMK,KAEbH,EAASJ,WACP,IAAIW,KAAiBN,QAEZK,eACGL,EAASM,GAAeC,kBACxBP,EAASM,GAAeE,wBAClBR,EAASM,GAAeC,SAAS,aAAcE,SAAWT,EAASM,GAAeC,SAAS,OAASP,EAASM,GAAeC,SAAS,eACxI,eACC,YACH,SACH,IAEV,MAAMG,QACDC,KAAK,QAASD,OAKrBP,EAAgB,EAAGA,EAAgBJ,EAASJ,QAAS,KACjDiB,EAAYb,EAASI,GACrBU,EAAWD,EAAUE,eAAeF,EAAUG,mBAEpCrB,IAAbmB,GAA0BA,IAAahB,EAAMK,MACpC,IAEAa,iBAEP,GAAGF,aAAoBG,MAAO,OACvB,EAEPJ,EAAUK,aAAe,GAAKJ,EAAS,GAAK,MACnCI,YAAcJ,EAAS,MAG9BD,EAAUK,YAAc,aAIjBF,iBAGT,GAAGF,aAAoBJ,iBAEZI,EAASK,KAAKhC,KAAMW,EAAMK,GAAoBU,EAAUjB,OAAQM,EAAMkB,OAAOP,EAAUjB,OAAS,MAClGoB,YACV,MAAML,QACDC,KAAK,QAASD,MACT,UAIF,KAGTN,OACST,SAEPiB,EAAUG,WAAaH,EAAUE,eAAenB,YAC3CiB,EAAUQ,cAAgBR,EAAUL,SAASZ,OAAQ,OAE7Ca,SAASU,KACjBhC,KACAe,EAAMoB,QAAQT,EAAUjB,QACxBiB,EAAUU,SAEZ,MAAMZ,QACDC,KAAK,QAASD,KAGZW,OAAO,OAGb,KACGE,EAAcX,EAAUL,SAASK,EAAUQ,gBACvCL,UAAY,MAEjBQ,aAAuBd,WACdK,eAAiBS,EAAYtB,EAAMkB,OAAOP,EAAUjB,WAGpDmB,eAAiBS,MAG7B,MAAMb,QACDC,KAAK,QAASD,KACVW,OAAOlB,EAAe,oBAS5BkB,OAAOlB,EAAe,IAI/BJ,EAASJ,QAAUM,EAAMN,aACtBgB,KAAK,aACH,sBACCV,EAAMoB,OAAO,eA9GpBV,KAAK,QAAS,IAAI7B,WAChB,gCACCe,KA8HZ,SAAS2B,WAAKxC,iEACPyC,OAASzC,EAAQ0C,MAAMC,KAAKzC,WAC5BF,uBACYA,EAAQ4C,eAAiB,SAGrC9B,UAAY,IAAIf,0DAIP,ICvJhB,SAAS8C,iBACFC,QAAUC,QAAQC,QAAQ,MCFjC,SAESC,MAAMC,eACDxC,IAATwC,IACDA,GAAQC,QAETD,EAEGD,MAAMG,QADNH,MAAMI,SAGDF,OCqBX,SAASG,GAAGC,mBACLzC,UAAUO,KAAKkC,QACfzC,UAAU0C,QAAQC,QAAQ,mBAAQC,EAAKC,MAAMC,EAAK/C,SAGzD,SAAS6B,MAAMpC,sBACLoC,MAAM,WACRmB,GAAIC,GAAIC,aAGNC,MAAMC,gBACND,MAAME,gBAEH,mBACDC,eACAC,GAAG,OAAQd,GAAGX,UACrB,iBAEQ,iBACH0B,KAAKC,KAAM,GAAI,kBAAMC,WAAW,kBAAMtB,MAAMoB,KAAKC,KAAM,KAAK,YAGjE,KPtDL,IAAM5E,UAaqB,mBAAjB8E,QAAQnF,eACRA,KAAOA,aACPI,QAAUA,SAGQ,mBAAlB+E,QAAQC,gBACRA,MAAQD,QAAQ7E,KQnB1BqC,MAAM0C,UAAUC,OAAS,eACjBC,SAEF,IAAIrE,KAAKL,OACEmB,KAAKnB,KAAKK,QAGrB,IAAIA,KAAKsE,cACP,IAAIC,KAAKD,UAAUtE,KACRc,KAAKwD,UAAUtE,GAAGuE,WAI5BF,GCuMT7B,QAAQgC,KAAO,SAASC,OAClBC,EAAQ/E,UAEN8E,aAAoBhD,OACxB,MAAM,IAAIkD,UAAU,oDAEf,IAAID,EAAM,SAACjC,EAASmC,OACpB,IAAWC,EAAP7E,EAAI,EAAYA,EAAIyE,EAASrE,OAAQJ,OAElCyE,EAASzE,KAEoB,mBAAjB6E,EAAQC,KAC5BD,EAAQC,KAAKrC,EAASmC,GAEtBnC,EAAQoC,MR9MhBvF,OAAOyF,KAAO,eAETC,QACuB,iBAAjBV,UAAU,GAAiB,KAC9B,IAAIW,KAAKX,UAAU,KACdW,GAAKX,UAAU,GAAGY,WAAWD,GAEvCD,EAAW,IAAIG,WAAMH,QAGdV,UAAU,aAAca,YAASb,UAAU,aAAc7C,SACjEuD,EAAW,IAAIG,WAAMb,UAAU,SAO5B,IALEc,OAA0BjF,IAAjBmE,UAAU,GAAmBA,UAAU,GAAK,EAC1DlE,OAA0BD,IAAjBmE,UAAU,GAAmBA,UAAU,GAAKU,EAAS5E,OAEzDiF,KAEErF,EAAIoF,EAAOpF,OACZA,GAAK,EAEZ,IAAI,IAAIA,EAAI,EAAIA,EAAIgF,EAAS5E,QAAYJ,EAAII,EAASJ,MAC/CoF,EAASpF,GAAKgF,EAAShF,GAE9B,IAAI,IAAIA,EAAIqF,EAAMjF,OAAQJ,EAAII,EAAQJ,MAC/BA,GAAK,SAEG,IAAImF,WAAME,IAK1B/F,OAAO8E,OAAS,eACTkB,EAAOhB,UAAU,OACpBiB,OAA+BpF,IAAjBmE,UAAU,GAAmBA,UAAU,GAAKgB,EAAKE,OAAO,SAACD,EAAaF,UAAWE,EAAcF,EAAMjF,QAAS,GAC5HqF,EAASnG,OAAOyF,QAAS,EAAGQ,GAE3BH,EAAS,WAERlC,QAAQ,cACLwC,IAAIC,EAAKP,MACNO,EAAIvF,SAGRqF,GShERG,OAAOlG,OAAS,SAACmG,8BAAWC,uDACtB,IAAI9F,KAAK8F,EAAM,KACXC,EAAMD,EAAK9F,MACd+F,aAAeH,OAChB,IAAI,IAAII,KAAOD,IACNC,GAAOD,EAAIC,UAIjBH,GRFTrG,YAAY2E,yBACL7D,OACG+C,SACC/D,OAAOyF,KAAKzE,QACb,aAGHX,KAAKsG,QAAQ7F,cACT6F,QAAQtG,KAAKsG,QAAQ7F,OAAS,GAAGH,KAAOoD,QAG1C4C,QAAQnF,KAAKuC,QACbjD,QAAUiD,EAAK/C,MAAMF,OAEnBT,KAAKS,yBAGNE,OACA+C,SACC/D,OAAOyF,KAAKzE,YACP,cACN,aAGHX,KAAKsG,QAAQ7F,WACTH,KAAON,KAAKsG,QAAQ,SAGtBA,QAAQC,QAAQ7C,QAChBjD,QAAUiD,EAAK/C,MAAMF,OAEnBT,KAAKS,uBAGR+F,cACElD,EAAQtD,KAAKsG,QAAQnE,OAAO,EAAGqE,YAC/BjD,QAAQ,mBAAQC,EAAK/C,QAAUiD,EAAK/C,MAAMF,SAEzC6C,eAGNmD,QACEA,GAASzG,KAAKS,QAAUgG,EAAQ,OAI/B,IAAIC,EAAY,EAAGA,EAAY1G,KAAKsG,QAAQ7F,OAAQiG,IAAc,IACjED,EAAQzG,KAAKsG,QAAQI,GAAW/F,MAAMF,sCAOhCT,KAAKsG,QAAQI,GAAW/F,MAAMF,yBAIpCA,WACSD,IAAXC,MACQT,KAAKS,SAGZT,KAAKS,cACAd,OAAOyF,SAGb3E,EAAST,KAAKS,WACNT,KAAKS,YAGZkG,SAEDlG,MACIT,KAAK4G,GAAGnG,IAGXkG,aAEO3G,KAAKS,OAAS,YACVT,KAAKsG,QAAQ7F,OAAS,QAI/BqF,EAASnG,OAAOyF,QAAS,EAAG3E,GAE5BgF,EAASzF,KAAKsD,MAAMqD,EAAGD,WAAWb,OAAO,SAACJ,EAAQ/B,YAC/CqC,IAAIrC,EAAK/C,MAAO8E,GAChBA,GAAU/B,EAAK/C,MAAMF,QAC3B,MAEAgF,EAAShF,EAAQ,KACZiD,EAAO1D,KAAKsD,MAAM,GAAGuD,UAEpBd,IAAIrC,EAAK/C,MAAMsB,MAAM,EAAGxB,EAASgF,GAASA,KAC5C9E,MAAQ+C,EAAK/C,MAAMsB,MAAMxB,EAASgF,QAElCc,QAAQ7C,UAGRoC,IS3GX,IAEMgB,OAEIC,SAAWC,eAAe,EAAMC,MAAM,IAEtCF,SAAWC,eAAe,EAAMC,MAAM,IAEtCF,SAAWC,eAAe,EAAOC,MAAM,IAG7CA,MAAO,EAGLC,WAAa,eACZ,IAAIC,KAASL,KAAM,IACnBA,KAAKK,GAAOJ,MAAMtG,UAChBqG,KAAKK,GAAOH,cAAe,KACvB,IAAII,EAAO,EAAGA,EAAON,KAAKK,GAAOJ,MAAMtG,OAAQ2G,SAC7CD,GAAOJ,MAAMK,UAEfD,GAAOJ,MAAM5E,OAAO,YAGpB,IADC4E,EAAQD,KAAKK,GAAOJ,MAAM5E,OAAO,GAC9BiF,EAAO,EAAGA,EAAOL,EAAMtG,OAAQ2G,MAChCA,UAKPD,GAAOF,KAAOA,MAAO,IAIxBI,UAAY,mBAAS,iBACpBF,GAAOJ,MAAM5F,KAAKhB,GAElB8G,MAASH,KAAKK,GAAOF,YACnBE,GAAOF,KAAOA,MAAO,aAEfC,eAITI,SAAWD,UAAyB,GAEpCE,aAAeF,UAA0B,GAEzCG,YAAcH,UAAyB,GP6G7C/E,KAAKkC,mCAEExE,KAAKY,UAAU6G,WACT5E,QAAQoC,OAAO,4BAEnBrE,UAAU6G,YAAa,EACrBzH,KAAKuC,OAAOmF,MAAM1H,KAAM2E,4BAG3BhE,cACE+B,EAAgB1C,KAAKF,QAAQ4C,iBAEhC/B,EAAMF,OAASiC,EAAe,KAI3B,IAHEiF,KAGEC,EAAYjH,EAAMF,OAAQgF,EAAS,EAAGmC,EAAY,EAAGA,GAAalF,EAAe,KACjFmF,EAAWlH,EAAMsB,MAAMwD,EAAQA,GAAU/C,KACxCvB,KAAK0G,UAGPF,EAAQ,SAACrH,EAAMuH,UACb7F,OAAW6F,qBAKbH,MAAM1H,KAAM2E,2BAIhBtD,EAAUC,OACTwG,sCAKDlH,UAAUE,SAASK,KAAK2G,GAEtBA,oBAGAA,MACJA,EAAS,KACJrB,EAAQzG,KAAKY,UAAUE,SAASiH,QAAQD,GAE3CrB,GAAS,GACVzG,KAAKY,UAAUE,SAASqB,OAAOsE,EAAO,aAEnC7F,UAAUE,SAASqB,OAAO,UAG1BnC,kBAMNqB,EAAUlB,cACL2H,EAAU9H,KAAKgI,MAAM3G,EAAU,gBAE7BoF,EAAQwB,EAAKrH,UAAUE,SAASiH,QAAQD,GAE3CrB,GAAS,GACVwB,EAAKrH,UAAUE,SAASqB,OAAO,EAAGsE,EAAQ,KAEzC1F,YAGEf,kBAGNkI,cAAQpI,2EACDL,IAAI,MACT,YAAaK,EACP,IAAI+C,QAAQ,SAACzC,EAAM+H,cACb,aACJrE,MAAMoE,QAEVpI,EAAQsI,iBAIVtE,MAAMoE,GAEJrF,QAAQC,yCAIVlC,UAAUG,MAAMoB,OAAO,QACvBvB,UAAUC,SAASsB,OAAO,GACxBnC,OClPX2C,UAAU6B,8BACE6D,0BACHzF,QAAUC,QAAQyF,KACrBtI,KAAK4C,QACL,IAAIC,QAAQ,SAACzC,EAAM+H,KACZ/H,EAAM+H,KACVI,MAAM,mBAAO/E,EAAK/B,KAAK,QAASD,OAG9BxB,wBAGAqI,0BACFzF,QAAU5C,KAAK4C,QACjBuC,KAAK,mBAAK,IAAItC,QAAQ,SAACzC,EAAM+H,KACvB/H,EAAM+H,OAEZI,MAAM,mBAAON,EAAKxG,KAAK,QAASD,KAE5BxB,OCzBX,IAAIiD,QAAS,EAcbF,MAAMG,MAAQ,WACRD,iBACO,QAEHkB,KAAKqE,KAAM,GAAI,SAASrI,IACzB8C,mBACU,kBAAMF,MAAMoB,KAAKqE,KAAM,GAAIrI,IAAK,SAMnD4C,MAAMI,KAAO,WACRF,iBACQ,IAIbF,MAAMoB,KAAO,SAACsE,OAAKvE,yDAAK,GAAI/D,iBACtB2D,OAAM,cACC,aACLA,OAAM,MACJ3D,KACL+D,s3GM5BCwE,MAAQ,oBAAY,KAASC,EAAO9C,OAAO,SAAC+C,EAAKC,UAAUD,EAAMC,GAAO,KAExEC,QAAU,SAACC,EAAMtI,EAAQM,UAAU2H,MAAM3H,EAAMkB,OAAO,KAItD+G,aAAe,SAACD,EAAMtI,EAAQM,UAAU2H,MAAM3H,EAAMkB,MAAM,KAI1DgH,SAAW,gBAEX,IADE/I,KACEG,EAAI,EAAGA,EAAIU,EAAM,GAAK,EAAGV,MAC3Bc,UAAKX,GACX,OAAON,GAUIgJ,OACVC,eAAgBC,iBAAkBC,sBAAkB7I,EAAWsI,QAASQ,qBACzEL,UACCD,aAAcO,kBASJ/H,MACV2H,eAAgBC,iBAAmBC,iBAAkB,EAAM,SAAM7I,EAAWwI,aAAcO,kBAGhFC,KACX,IAAIC,mBAAmBN,eAAgBC,iBAAkBC,iBAAkB,EAAM,IAAME,mBAO5EG,QAAU,mBACrB,IAAID,mBACFN,eACAC,iBACAC,iBACA,IAAQK,EAAQjJ,OAAS,EACzB,KAASiJ,EAAQjJ,OACjBkJ,4BACGD,QAEMA,EAAQ7D,OAAO,SAAC+D,EAAUb,UAASa,EAAWb,GAAMY,qBAC7DJ,oBCpEAlG,QAASwG,UAAW,EACtBC,eAAgB,EAChBC,eAAgB,EAChBC,iBAAkB,EAClBC,kBAAmB,EACnBC,YAAa,EACbC,cAAe,EACfC,aAAc,EACdC,SAAU,IACVC,QAAS,IACTC,iBAAkB,KAClBC,wBAAyB,KACzBC,qBAAsB,KACtBC,qBAAsB,KACtBC,oBAAqB,KACrBC,WAAY,GACZC,UAAW,GACXC,UAAW,GAOTC,OAAS,SAAgB1H,GACzB,IAAI2H,EAA+B,GAAV3H,EAAK,GAEfA,EAAKpB,MAAM,EAAG,EAAI+I,GAMjC,OAAOrL,OAAOyF,KAAK/B,EAAKpB,MAAM+I,EAAqB,IAAIC,YAQvDC,OAAS,SAAgBC,EAAMC,EAAMC,GAQrC,OANKD,IACDA,EAAO,MAGGzL,OAAOyF,MAAMgG,EAAK3K,QAAQgE,UAAUxC,MAAMD,KAAKrC,OAAOyF,KAAKgG,EAAOD,OAOhFG,WAAa,GAAI,cAAe,eAAgB,UAAW,WAAY,OAAQ,UAAW,6BAA8B,aAAc,UAAW,UAAW,SAAU,SAAU,SAAU,SAAU,QAAS,YAAa,QAAS,UAAW,OAAQ,OAAQ,OAAQ,QAAS,QAAS,WAAY,aAAc,YAAa,aAAc,cAAe,UAAW,cAAe,eAAgB,eAAgB,eAAgB,WAAY,YAKlbC,SAAW,SAAgBlI,GAC3B,IAAImI,EAASF,UAAUjI,EAAK,IAK5B,OAJKmI,IAEDA,EAAS,IAENA,EAAS7L,OAAOyF,KAAK/B,EAAKpB,MAAM,IAAIgJ,YAwD3CQ,OAAS,SAAgBC,EAAKC,EAAMC,EAAIC,EAAShD,GAsCnD,OArCK6C,IACHA,EAAMrI,OAAKwG,WAER8B,IACHA,MAEGC,IACHA,MAEGC,IACHA,MAGEF,aAAgB7J,QAClB6J,EAAOhM,OAAOyF,KAAKuG,GAAMV,YAIrBW,aAAc9J,QAClB8J,EAAKjM,OAAOyF,KAAKwG,IAIbC,aAAmB/J,QACvB+J,EAAUlM,OAAOyF,KAAKyG,IAKpBH,GAAOrI,OAAKyG,iBACV6B,GAAQtI,OAAKgH,SACfxB,EAAQkC,OAAOc,GACNF,GAAQtI,OAAKiH,UACtBzB,EAAQ0C,SAASM,MAKnBH,IAAKA,EACLC,KAAMA,EACNC,GAAIA,EACJC,QAASA,EACThD,MAAOA,IAWPiD,WAAa,SAAoBX,EAAMY,EAAcH,GACvD,OAAOH,OAAOpI,OAAKyG,eAAgBzG,OAAKgH,SAAUuB,MAAUV,OAAOC,EAAMY,KAsGvEC,cAAgB,SAAuBC,GACzC,IAAIC,KACAC,OAAW,EACXC,OAAc,EACdC,OAAiB,EACjBC,OAAY,EACZjM,OAAI,EACJkM,OAAK,EACLC,OAAK,EAITC,OAAK,EAELC,OAAK,EAEL,IAAKrM,EAAI,EAAGA,EAAI4L,EAAYxL,OAAQJ,IAClCkM,EAAW,IAANlM,EACLmM,EAAKnM,IAAM4L,EAAYxL,OAAS,EAChCgM,EAAKR,EAAY5L,GAAGwL,QAAQpL,OAAS,IACrCiM,EAAKT,EAAY5L,GAAGuL,GAAGnL,OAAS,EAChC0L,EAAWQ,UAAUJ,EAAIC,GAXtB,EAW8BC,EAAIC,EAAIT,EAAY5L,GAAGqL,KACxDQ,EAAQ/K,KAAKgL,GAGbC,KAAiBnK,MAAMD,KAAKrC,OAAOyF,KAAK6G,EAAY5L,GAAGsL,OACvDO,EAAQ/K,KAAKiL,EAAY3L,QAErBgM,GACFJ,EAAiBJ,EAAY5L,GAAGwL,QAAQpL,OACxCyL,EAAQ/K,KAAKkL,KAEbA,EAAiBJ,EAAY5L,GAAGwL,QAAQpL,OAExCyL,EAAQ/K,KAAKkL,GAAkB,IAC/BH,EAAQ/K,KAAKkL,GAAkB,IAC/BH,EAAQ/K,KAAKkL,GAAkB,GAC/BH,EAAQ/K,KAAsB,IAAjBkL,IAGXK,IACFJ,EAAYL,EAAY5L,GAAGuL,GAAGnL,OAC9ByL,EAAQ/K,KAAKmL,IAGfJ,EAAUA,EAAQzH,OAAO2H,GAErBM,IACFR,EAAUA,EAAQzH,OAAOwH,EAAY5L,GAAGuL,KAG1CM,EAAUA,EAAQzH,UAAUxC,MAAMD,KAAKiK,EAAY5L,GAAGwL,UAGxD,OAAOK,GAkFLS,UAAY,SAAmBJ,EAAIC,EAAII,EAAIH,EAAIC,EAAIhB,EAAK7C,GA0B1D,OAzBKA,IACHA,EAAQ6C,GAGNa,IACF1D,GAAgB,KAGd2D,IACF3D,GAAgB,IAId+D,IACF/D,GAAgB,IAGd4D,IACF5D,GAAgB,IAGd6D,IACF7D,GAAgB,GAGXA,GNjaT9F,QAEA,IAAMmJ,QAAUF,eACdF,WAAW,qBAGP/H,OAAS2F,SAASmD,eAClB7I,IAAM0F,SAASoD,+BAAgCC,sBAAuB,GAAI,IA2B1EC,IAAM,IAAIC,kBACPvK,cAAe,KAGlBwK,SAAW,IAAIC,UAErBH,IAAI9I,GAAG,QAASI,QAAQC,OAExB2I,SAASE,SAAS5K,MAAMC,KAAKuK,MAE7B,IAAMK,UAAY,SAACC,EAAKjH,EAAKkH,OACrBC,EAAO,SAACpN,EAAM+H,kBAGZsF,EAAO/D,SACXgE,6BACA,EACAC,kBACAJ,UACGlH,EACAiH,QAGDlK,GAAGoG,IAAK,mBAERpG,GAAG5B,IAAK,oBACF+C,MAAM/C,KACTA,SAGH4B,GAAG8F,KAAM,oBACHzJ,IAAI,qBACJsB,EAAM,QACNA,EAAMkB,MAAM,GAAI,mBAMlB6B,MAAM2J,IAGVxJ,EAAO,SAAC7D,EAAM+H,WACV1I,IAAI,YACNmO,EAAOlE,SACXgE,6BACA,EACAG,mBACAN,QAGEnK,GAAGoG,IAAK,mBAERpG,GAAG5B,IAAK,oBACF+C,MAAM/C,KACTA,SAGH4B,GAAG8F,KAAM,gBACL4E,EAAO/M,EAAMkB,MAAM,GAAI,GACvBoB,kBAEItC,EAAM,iBAEN+M,EAAKrN,UAGV4C,aAGCS,MAAM8J,WAGT/K,QAAQC,UACZqC,KAAK,kBAAM,IAAItC,QAAQ2K,KACvBrI,KAAK,kBAAM,IAAItC,QAAQoB,MAGtB8J,WAAa,SAACT,EAAKjH,EAAK2H,UACrB,IAAInL,QAAQ,SAACzC,EAAM+H,OAEpB,IADE8F,KACEV,EAAiB,EAATS,EAAYT,EAAiB,EAATS,EAAa,EAAGT,MACpCpM,KAAKoM,UAEdU,EAAe,SAAC3N,EAAMiN,EAAO9G,aACxB6G,EAAKjH,EAAKkH,GAAOpI,KAAK,cAChBsB,GAASpD,SAGxB,kBAAMjD,EAAK6N,QAIZ5H,IAAM,IAAIoD,mBAAmB,IAAM,IAAM,IAAM,IAAM,IAAM,OAEhE,SAAUyE,QACLZ,kBAIKF,SAAS,gBACVe,EAAOzE,SACX0E,kCACA,EACA,QAGEhL,GAAGoG,IAAK,mBACF/J,IAAI,aAGV2D,GAAG8F,KAAM,gBACL4E,EAAO/M,EAAMkB,MAAM,EAAG,EAAIlB,EAAM,IAChCsN,EAAYP,EAAK,GACjBQ,EAAOR,EAAK7L,MAAM,EAAG,EAAIoM,WAEvB5O,IAAI,SACJsB,EAAM,GAEL+M,EAAK,GACNA,EAAK7L,MAAM,EAAG,GACf6L,EAAK,IALS,MAUfQ,gBAKAxK,MAAMqK,cAGPf,SAAS,SAAChN,EAAM+H,cACZmF,EAAKjH,IAAK,GAClBlB,KAAK,2BACI1F,IAAI4D,GACLA,IAER8B,KAAK/E,GAAMmI,MAAMjE,QAAQC,kBAGrB6I,SAAS,uBACL,mBACD3N,IAAI8O,QAAQC,SAASC,eAG5B,OArDN"}