{"version":3,"file":"index.pico.min.js","sources":["../globals/buffer.js","../lib/events.js","../lib/stream/bufferState.js","../lib/bus.js","../lib/nfc/bus.js","../globals/console.js","../lib/blink.js","../globals/object.js","../globals/namedFunction.js","../globals/extend/index.js","../globals/array.js","../globals/promise.js","../globals/event-loop.js","../lib/nfc/frames.js","../helpers/series.js","../src/index.js"],"sourcesContent":["// import Uint8Array from './Uint8Array'\r\n// import { toBuffer } from './utils/to'\r\n\r\n// function copy(target) {\r\n// \tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\r\n// \t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\r\n// \t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\r\n//\r\n// \tlet copied = 0\r\n//\r\n// \tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\r\n// \t\ttarget.set([ this[sourceIndex] ], targetIndex)\r\n//\r\n// \treturn copied\r\n// }\r\n//\r\nfunction Buffer() {\r\n  throw new Error()\r\n}\r\n\r\n//Buffer.from = (iterable, offset, length) => E.toUint8Array(iterable)\r\n\r\nBuffer.from = (iterable, offset, length) => {\r\n  if (typeof iterable == 'string') {\r\n    const parsed = []\r\n\r\n    for (let c in iterable) {\r\n      parsed[c] = iterable.charCodeAt(c)\r\n    }\r\n\r\n    return new Uint8Array(parsed)\r\n  } else if (iterable instanceof ArrayBuffer) {\r\n    return new Uint8Array(iterable.slice(offset !== undefined ? offset : 0, offset + (length !== undefined ? length : iterable.length)))\r\n  } else if (iterable instanceof Array || iterable instanceof Uint8Array) {\r\n    return new Uint8Array(iterable)\r\n  } else {\r\n    throw new TypeError('Cannot create buffer from', typeof iterable)\r\n  }\r\n}\r\n\r\nBuffer.concat = (_list, _totalLength) => {\r\n  const list = _list || [],\r\n    totalLength = _totalLength !== undefined ? _totalLength : list.reduce((totalLength, array) => totalLength + array.length, 0),\r\n    buffer = Buffer.from([], 0, totalLength)\r\n\r\n  list.reduce((offset, buf) => {\r\n    buffer.set(buf, offset)\r\n    return offset + buf.length\r\n  }, 0)\r\n\r\n  return buffer\r\n}\r\n\r\nexport default Buffer\r\n","function EventEmitter() {\r\n  this._listeners = {}\r\n}\r\n\r\n//_named('EventEmitter', EventEmitter)\r\n\r\nfunction _duplicateEvent(event) {\r\n  if(event) {\r\n    if(`#${ event }` in this) {\r\n      this._listeners[event] = this[`#${ event }`]\r\n    } else {\r\n      delete this._listeners[event]\r\n    }\r\n  }\r\n}\r\n\r\nEventEmitter.prototype = {\r\n  on(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n\r\n    // this._listeners[event]\r\n    //   ? this._listeners[event].push(listener)\r\n    //   : this._listeners[event] = [listener]\r\n\r\n    return this\r\n  },\r\n\r\n  removeListener(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n    // if(!event) {\r\n    //   this._listeners = {}\r\n    // } else {\r\n    //   if(listener && this._listeners[event]) {\r\n    //     const index = this._listeners[event].indexOf(listener)\r\n    //\r\n    //     if(~index) {\r\n    //       this._listeners[event].splice(index, 1)\r\n    //     }\r\n    //   }\r\n    //\r\n    //   if(!listener || !this._listeners[event]) {\r\n    //     delete this._listeners[event]\r\n    //   }\r\n    // }\r\n    return this\r\n  },\r\n\r\n  once(event, listener) {\r\n    function once() {\r\n      this.removeListener(event, _listener)\r\n      return listener.apply(this, arguments)\r\n    }\r\n\r\n    return this.on(event, once)\r\n  }\r\n}\r\n\r\nexport default EventEmitter\r\n","function BufferState(options = {}) {\r\n  Object.assign(this, {\r\n\t\t_buffer: [],\r\n\t\tlength: 0\r\n\t}, options)\r\n}\r\n\r\nBufferState.prototype = {\r\n  push(chunk) {\r\n    if(chunk.length) {\r\n      const node = {\r\n    \t\tchunk: Buffer.from(chunk),\r\n        encoding: 'binary',\r\n    \t\tnext: null\r\n    \t}\r\n\r\n      if(this._buffer.length) {\r\n        this._buffer[this._buffer.length - 1].next = node\r\n      }\r\n\r\n      this._buffer.push(node)\r\n      this.length += node.chunk.length\r\n    }\r\n\r\n    return this.length\r\n  },\r\n\r\n  unshift(chunk) {\r\n    const node = {\r\n  \t\tchunk: Buffer.from(chunk),\r\n      encoding: 'binary',\r\n  \t\tnext: null\r\n  \t}\r\n\r\n    if(this._buffer.length) {\r\n      node.next = this._buffer[0]\r\n    }\r\n\r\n    this._buffer.unshift(node)\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  nodes(count) {\r\n    const nodes = this._buffer.splice(0, count)\r\n    nodes.forEach(node => this.length -= node.chunk.length)\r\n\r\n    return nodes\r\n  },\r\n\r\n  at(index) {\r\n    if(index >= this.length || index < 0) {\r\n      return\r\n    }\r\n\r\n    for(let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex ++) {\r\n      const chunk = this._buffer[nodeIndex].chunk\r\n      if(index < chunk.length) {\r\n        return {\r\n          index,\r\n          nodeIndex,\r\n          value: chunk[index]\r\n        }\r\n      }\r\n\r\n      index -= chunk.length\r\n    }\r\n  },\r\n\r\n  for(from, to, callee) {\r\n    const firstNode = this._buffer[from.nodeIndex]\r\n    for(let index = from.nodeIndex; index < firstNode.chunk.length; index ++) {\r\n      callee.call(this, firstNode.chunk[index])\r\n    }\r\n\r\n    for(let nodeIndex = 1 + from.nodeIndex; nodeIndex < to.nodeIndex; nodeIndex ++) {\r\n      const node = this._buffer[nodeIndex]\r\n      for(let index = 0; index < node.chunk.length; index ++) {\r\n        callee.call(this, node.chunk[index])\r\n      }\r\n    }\r\n\r\n    if(from.nodeIndex < to.nodeIndex) {\r\n      const lastNode = this._buffer[to.nodeIndex]\r\n      for(let index = 0; index <= to.index; index ++) {\r\n        callee.call(this, lastNode.chunk[index])\r\n      }\r\n    }\r\n  },\r\n\r\n  slice(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      to = this.at(length)\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n\r\n    const buffer = Buffer.from(Array(length))\r\n\r\n    const offset = this._buffer.slice(0, to.nodeIndex - 1).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset + node.chunk.length\r\n    }, 0)\r\n\r\n    if(offset < length) {\r\n      const node = this._buffer[to.nodeIndex]\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n    }\r\n\r\n    return buffer\r\n  },\r\n\r\n  buffer(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      // console.time('at')\r\n      to = this.at(length)\r\n      // console.timeEnd('at')\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n    // console.time('from')\r\n    const buffer = Buffer.from(Array(length))\r\n    // console.timeEnd('from')\r\n    // console.time('offset')\r\n\r\n    // console.timeEnd('buffer')\r\n\r\n    const offset = this.nodes(to.nodeIndex).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset + node.chunk.length\r\n    }, 0)\r\n    // console.timeEnd('offset')\r\n    if(offset < length) {\r\n      const node = this.nodes(1)[0]\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n      node.chunk = node.chunk.slice(length - offset)\r\n\r\n      this.unshift(node.chunk)\r\n    }\r\n\r\n    return buffer\r\n  }\r\n}\r\n\r\nexport default BufferState\r\n","import EventEmitter from 'events'\r\nimport BufferState from 'stream/bufferState'\r\n//import Schedule from 'schedule'\r\nimport series from 'series'\r\n\r\nconst DEFAULT_HIGHWATERMARK = 64\r\n\r\nfunction checkIndex( index, length ) {\r\n\r\n}\r\n\r\nfunction _resetWatcher( watcher ) {\r\n  watcher.currentPattern = null\r\n  watcher.arrayOffset =\r\n    watcher.patternIndex =\r\n    watcher.byteIndex =\r\n    watcher.index = 0\r\n  watcher.active = false\r\n\r\n  return watcher\r\n\r\n  // return Object.assign(watcher, defaultWatcher)\r\n}\r\n\r\n// function Watcher(bus) {\r\n//   _resetWatcher(this)\r\n//\r\n//\r\n// }\r\n//\r\n// Watcher.prototype = {\r\n//   rx() {\r\n//\r\n//   }\r\n// }\r\n\r\nfunction _resetActive() {\r\n  this._busState.active = 0\r\n  this.emit( 'inactive' )\r\n}\r\n\r\nfunction _decrementActive() {\r\n  if ( !--this._busState.active ) {\r\n    this.emit( 'inactive' )\r\n  }\r\n}\r\n\r\nfunction _push() {\r\n  const { _busState } = this\r\n  const {\r\n    watching,\r\n    _buffer\r\n  } = _busState\r\n\r\n  for ( ; _busState.nodeIndex < _buffer.length; _busState.nodeIndex++ ) {\r\n    if ( !watching.length ) {\r\n      this.emit( 'error', {\r\n        msg: 'Unexpected incoming data',\r\n        data: _busState.buffer()\r\n      } )\r\n      return\r\n    }\r\n\r\n    if ( _busState.nodeIndex < 0 ) {\r\n      _busState.nodeIndex = 0\r\n    }\r\n\r\n    const {\r\n      chunk\r\n    } = _buffer[ _busState.nodeIndex ]\r\n    let currentChunkIndex = 0\r\n    let currentIncomingWatcherIndex = 0\r\n    let watcherIndex = 0\r\n    let isEqual = false\r\n    let isChunkCorrupted = false\r\n\r\n    for ( ; currentChunkIndex < chunk.length; currentChunkIndex++ ) {\r\n      let isChunkCorrupted = false\r\n      if ( !_busState.active ) {\r\n        _busState.active = _busState.watching.reduce( ( active, watcher ) => {\r\n          const {\r\n            patterns\r\n          } = watcher\r\n          try {\r\n            watcher.currentPattern = typeof patterns[ 0 ] == 'function' ? patterns[ 0 ]( _busState.slice(watcher.length) ) : patterns[ 0 ]\r\n            watcher.active = true\r\n            return 1 + active\r\n          } catch ( err ) {\r\n            this.emit( 'error', err )\r\n            return active\r\n          }\r\n        }, 0 )\r\n      }\r\n\r\n      const byte = chunk[ currentChunkIndex ]\r\n\r\n      for ( watcherIndex = 0; watcherIndex < watching.length; watcherIndex++, isEqual = false ) {\r\n        const watcher = watching[ watcherIndex ]\r\n        if ( !watcher.active ) {\r\n          continue\r\n        }\r\n\r\n        const { currentPattern } = watcher\r\n\r\n        if(Array.isArray(currentPattern)) {\r\n          const expected = currentPattern[ watcher.byteIndex ]\r\n\r\n          // console.log('current watching:', watcher.currentPattern)\r\n          // console.log('current chunk:', chunk)\r\n          // console.log('byte:', byte)\r\n          // console.log('expected:', expected)\r\n\r\n          if ( expected === undefined || (typeof expected == 'number' && expected === byte) ) {\r\n            isEqual = true\r\n          } else if ( typeof expected == 'function' ) {\r\n            try {\r\n              isEqual = !!expected.call( this, byte, watcher.index /*i.e. index*/ , _busState.slice( watcher.index /*i.e. actual length*/ ) )\r\n            } catch ( err ) {\r\n              this.emit( 'error', err )\r\n            }\r\n          }\r\n        } else if ( typeof currentPattern == 'number' ) {\r\n          if(currentPattern <= 0) {\r\n            throw new RangeError('Pattern length should be a positive integer, but set to', currentPattern)\r\n          }\r\n\r\n          if ( watcher.arrayOffset <= 0 ) {\r\n            watcher.arrayOffset = currentPattern\r\n          }\r\n\r\n          console.log(--watcher.arrayOffset)\r\n\r\n          if ( --watcher.arrayOffset > 0 ) {\r\n            watcher.index++\r\n              continue\r\n          }\r\n\r\n          isEqual = true\r\n        }\r\n\r\n        if ( isEqual ) {\r\n          watcher.index++\r\n\r\n            if ( ++watcher.byteIndex >= currentPattern.length ) {\r\n              if ( ++watcher.patternIndex >= watcher.patterns.length ) {\r\n                // console.time( 'buffer' )\r\n                // console.log(watcher.callback)\r\n                const chunk = _busState.buffer( watcher.index )\r\n                // console.timeEnd( 'buffer' )\r\n                _busState.nodeIndex = -1\r\n                try {\r\n                  // console.time( 'cb' )\r\n                  watcher.callback(\r\n                    chunk,\r\n                    // frame.splice(-watcher.index),\r\n                    watcher.pattern\r\n                  )\r\n                  // console.timeEnd( 'cb' )\r\n                } catch ( err ) {\r\n                  this.emit( 'error', err )\r\n                }\r\n                // _busState.watching = []\r\n                // console.time( 'reset' )\r\n                watching.forEach( _resetWatcher )\r\n                _resetActive.call(this)\r\n                // console.timeEnd( 'reset' )\r\n              } else {\r\n                // console.time('next pattern')\r\n                const nextPattern = watcher.patterns[ watcher.patternIndex ]\r\n                watcher.byteIndex = 0\r\n\r\n                if ( typeof nextPattern == 'function' ) {\r\n                  try {\r\n                    watcher.currentPattern = nextPattern.call( this, _busState.slice( watcher.length ) )\r\n                  } catch ( err ) {\r\n                    _resetWatcher( watcher )\r\n                    _decrementActive.call( this )\r\n                    this.emit( 'error', err )\r\n                  }\r\n                } else {\r\n                  watcher.currentPattern = nextPattern\r\n                }\r\n                // console.timeEnd('next pattern')\r\n              }\r\n            }\r\n        } else {\r\n          _resetWatcher( watcher )\r\n          _decrementActive.call( this )\r\n\r\n          if ( !_busState.active ) {\r\n            this.emit( 'error', {\r\n              msg: 'Unparsed chunk',\r\n              data: _busState.buffer() // frame.splice(0)\r\n            } )\r\n            //\r\n            // if(!isChunkCorrupted) {\r\n            //   isChunkCorrupted = true\r\n            //   setImmediate(() => {\r\n            //     isChunkCorrupted = false\r\n            //     this.emit('error', {\r\n            //       msg: 'Unparsed chunk',\r\n            //       data: frame.splice(0)\r\n            //     })\r\n            //   })\r\n            // }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if ( _busState.active ) {\r\n    this.emit( 'drain' )\r\n  }\r\n}\r\n\r\nfunction _Bus( options = {} ) {\r\n  this.transport = options.transport\r\n  this.type = options.type\r\n  this._setup = options.setup.bind( this )\r\n  this._read = length => options.read.call( this, length === undefined ? length : this.options.highWaterMark )\r\n  this._write = options.write.bind( this )\r\n\r\n  this.options = {\r\n    highWaterMark: options.highWaterMark || DEFAULT_HIGHWATERMARK\r\n  }\r\n\r\n  this._busState = new BufferState( {\r\n    watching: [],\r\n    active: 0,\r\n    nodeIndex: 0,\r\n    configured: false,\r\n    ticker: false\r\n  } )\r\n}\r\n\r\n_Bus.prototype = {\r\n  setup() {\r\n    if ( this._busState.configured ) {\r\n      return Promise.reject( 'already configured' )\r\n    }\r\n\r\n    this._busState.configured = true\r\n    return this._setup.apply( this, arguments )\r\n  },\r\n\r\n  push( chunk ) {\r\n    if ( chunk.length ) {\r\n      this._busState.push( chunk )\r\n\r\n      if ( !this._busState.ticker ) {\r\n        this._busState.ticker = true\r\n        setImmediate( () => {\r\n          this._busState.ticker = false\r\n          _push.call( this )\r\n        } )\r\n      }\r\n    }\r\n    // const highWaterMark = this.options.highWaterMark,\r\n    //       parse = _parse.bind(this)\r\n    //\r\n    // if(chunk.length > highWaterMark) {\r\n    //   const chunks = []\r\n    //   let subchunkIndex = 0\r\n    //\r\n    //   for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\r\n    //     const subchunk = chunk.slice(offset, offset += highWaterMark)\r\n    //     chunks.push(subchunk)\r\n    //   }\r\n    //\r\n    //   series(chunks, (next, subchunk) => {\r\n    //     parse(subchunk)\r\n    //     next()\r\n    //   })\r\n    // }\r\n    // else {\r\n    //   parse(chunk)\r\n    // }\r\n  },\r\n\r\n  watch( patterns, cb ) {\r\n    const watcher = _resetWatcher( {\r\n      patterns,\r\n      callback: cb.bind( this )\r\n    } )\r\n\r\n    this._busState.watching.push( watcher )\r\n\r\n    return watcher\r\n  },\r\n\r\n  unwatch( watcher ) {\r\n    if ( watcher ) {\r\n      const index = this._busState.watching.indexOf( watcher )\r\n\r\n      if ( index >= 0 ) {\r\n        if(this._busState.watching[index].active) {\r\n          _resetWatcher( watcher )\r\n          _decrementActive.call( this )\r\n        }\r\n\r\n        this._busState.watching.splice( index, 1 )\r\n      }\r\n    } else {\r\n      this._busState.watching.splice( 0 )\r\n      _resetActive.call(this)\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  /**\r\n    @TODO Promise interface\r\n  */\r\n\r\n  expect( patterns, ...args ) {\r\n    let cb, options = {}\r\n\r\n    if ( typeof args[ 0 ] == 'function' ) {\r\n      cb = args[ 0 ]\r\n    } else if ( typeof args[ 1 ] == 'function' ) {\r\n      cb = args[ 1 ]\r\n      Object.assign( options, args[ 0 ] )\r\n    } else {\r\n      throw new ReferenceError( 'Callback is not provided' )\r\n    }\r\n\r\n    let watcher\r\n    const setWatcher = () => {\r\n      watcher = this.watch( patterns, (...args) => {\r\n        this.unwatch(watcher)\r\n        cb.apply(this, args)\r\n      } )\r\n      this._read( this.options.highWaterMark )\r\n    }\r\n\r\n    // if ( 'timeout' in options ) {\r\n    //   setTimeout( setWatcher, options.timeout )\r\n    // } else {\r\n    //\r\n    // }\r\n\r\n    setWatcher()\r\n\r\n    return watcher\r\n  },\r\n\r\n  send( binary, options = {} ) {\r\n    if ( 'timeout' in options ) {\r\n      setTimeout( () => {\r\n        this._write( binary )\r\n      }, options.timeout )\r\n    } else {\r\n      this._write( binary )\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  reset() {\r\n    this._busState.watching.splice( 0 )\r\n    return this\r\n  }\r\n}\r\n\r\nconst Bus = _extend( {\r\n  super: [ EventEmitter, _Bus ],\r\n  apply: [ EventEmitter, _Bus ]\r\n} )\r\n\r\nexport default Bus\r\n","import Bus from 'bus'\r\nimport {\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_WRITE_16,\r\n  PN532_BRTY_ISO14443A,\r\n  PN532_BRTY_ISO14443B\r\n} from './constants'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  ERR,\r\n  INFO\r\n} from './frames'\r\n\r\nimport series from 'series'\r\n\r\nconst sliceAck = chunk => chunk.slice( ACK.length )\r\n\r\nconst parseInfo = chunk => {\r\n  return {\r\n    raw: chunk,\r\n    code: chunk[ 6 ],\r\n    body: Buffer.from( chunk.slice( 7, 5 + chunk[ 3 ] ) )\r\n  }\r\n}\r\n\r\nconst parseBlockData = data => {\r\n  if ( data.body.length == 1 ) {\r\n    throw {\r\n      cmd: data.code,\r\n      errCode: data.body[ 0 ]\r\n    }\r\n  } else {\r\n    return {\r\n      chunk: data.body.slice( 1 )\r\n    }\r\n  }\r\n}\r\n\r\nfunction _Bus() {}\r\n\r\n_Bus.prototype = {\r\n  makeTransaction( cmd, info, parsers ) {\r\n    return new Promise( ( done, fail ) => {\r\n        // Don't be silly again - info frame refers to index from beginning, i.e. to ACK\r\n        // this.expect([...ACK, ...info], chunk => done((parsers || [sliceAck, parseInfo]).reduce((data, parse) => parse(data), chunk)))\r\n        this.expect( ACK, () => {\r\n          this.expect( info, chunk => done( ( parsers || [ parseInfo ] )\r\n            .reduce( ( data, parse ) => parse( data ), chunk ) ) )\r\n        } )\r\n\r\n        this.expect( NACK, fail )\r\n        this.expect( ERR, fail )\r\n\r\n        this.send( command( cmd ) )\r\n      } )\r\n      .catch( err => {\r\n        this.unwatch()\r\n        throw err\r\n      } )\r\n      .then( data => {\r\n        this.unwatch()\r\n        return data\r\n      } )\r\n  },\r\n\r\n  findTargets( count, type ) {\r\n    if ( type == 'A' ) {\r\n      type = PN532_BRTY_ISO14443A\r\n    } else if ( type == 'B' ) {\r\n      type = PN532_BRTY_ISO14443B\r\n    } else {\r\n      throw new Error( 'Unknown ISO14443 type:', `\"${ type }\"` )\r\n    }\r\n\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INLISTPASSIVETARGET,\r\n      count,\r\n      type\r\n    ], INFO, [ chunk => {\r\n      const body = chunk.slice( 7, 5 + chunk[ 3 ] )\r\n      const uid = body.slice( 6, 6 + body[ 5 ] )\r\n      return {\r\n        code: chunk[ 6 ],\r\n        body,\r\n        count: body[ 0 ],\r\n        atqa: body.slice( 2, 4 ), // SENS_RES\r\n        sak: body[ 4 ],\r\n        uid\r\n      }\r\n    } ] )\r\n  },\r\n\r\n  authenticate( block, uid, key ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_AUTH_A,\r\n      block,\r\n      ...[].slice.call( key ),\r\n      ...[].slice.call( uid )\r\n    ], INFO )\r\n  },\r\n\r\n  readBlock( block ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_READ_16,\r\n      block\r\n    ], INFO, [ parseInfo, parseBlockData ] )\r\n  },\r\n\r\n  writeBlock( block, chunk ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_WRITE_16,\r\n      block,\r\n      ...[].slice.call( chunk )\r\n    ], INFO )\r\n  },\r\n\r\n  readSector( sector ) {\r\n    return new Promise( ( done, fail ) => {\r\n      const readBlocksArr = []\r\n      for ( let block = sector * 4; block < sector * 4 + 3; block++ ) {\r\n        readBlocksArr.push( block )\r\n      }\r\n\r\n      series( readBlocksArr, ( next, block, index ) => {\r\n        this.readBlock( block )\r\n          .then( data => {\r\n            readBlocksArr[ index ] = data\r\n            next()\r\n          } )\r\n          .catch( err => {\r\n            console.log( '!!!' )\r\n            next( err )\r\n          } )\r\n      }, err => err ? fail( err ) : done( readBlocksArr ) )\r\n    } )\r\n  },\r\n\r\n  writeSector( start, chunk ) {\r\n\r\n  }\r\n}\r\n\r\nexport default _extend({ super: [Bus, _Bus], apply: [Bus, _Bus] })\r\n","if(typeof console.time !== 'function') {\r\n  const timers = {}\r\n\r\n  console.time = label => {\r\n    timers[label] = Date.now()\r\n  }\r\n\r\n  console.timeEnd = label => {\r\n    if(label in timers) {\r\n      console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\r\n      delete timers[label]\r\n    }\r\n  }\r\n}\r\n\r\nif(typeof console.error !== 'function') {\r\n  console.error = console.log\r\n}\r\n\r\nexport default console\r\n","let defaultLed\r\nlet ON = 1,\r\n  OFF = 0\r\n\r\nif (process.env.CHIP && process.env.CHIP.toUpperCase() == 'ESP32') {\r\n  defaultLed = D5\r\n  ON = 0\r\n  OFF = 1\r\n} else {\r\n  defaultLed = LED2\r\n}\r\n\r\nlet status = false\r\nconst defaultTimeout = 20\r\n\r\nexport const once = (led, timeout, cb) => {\r\n  // D5.write(0)\r\n  // console.log('on')\r\n  led.write(ON)\r\n  setTimeout(() => {\r\n    // D5.write(1)\r\n    // console.log('off')\r\n    led.write(OFF)\r\n    cb && cb()\r\n  }, timeout || defaultTimeout)\r\n}\r\n\r\nexport const start = led => {\r\n  if (!led) {\r\n    led = defaultLed\r\n  }\r\n  if (!status) {\r\n    status = true\r\n\r\n    once(led, defaultTimeout, function cb() {\r\n      if (status) {\r\n        setTimeout(() => {\r\n          once(led, defaultTimeout, cb)\r\n        }, 1000 - defaultTimeout)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport const stop = () => {\r\n  if (status) {\r\n    status = false\r\n  }\r\n}\r\n","Object.assign = (target, ...args) => {\r\n  for(let i in args) {\r\n    const obj = args[i]\r\n    if(obj instanceof Object) {\r\n      for(let key in obj) {\r\n        target[key] = obj[key]\r\n      }\r\n    }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\nconst _defProp = Object.defineProperty\r\n\r\nObject.defineProperty = (obj, prop, descriptor) => {\r\n  try {\r\n    return _defProp(obj, prop, descriptor)\r\n  } catch(e) {\r\n    if(desc.get) {\r\n      obj.value = descriptor.get()\r\n    }\r\n    else if(desc.value) {\r\n      obj[prop] = descriptor.value\r\n    }\r\n\r\n    return obj\r\n  }\r\n}\r\n\r\nObject.defineProperties = (obj, descriptors) => {\r\n  for(let prop in descriptors) {\r\n    const descriptor = descriptors[prop]\r\n    Object.defineProperty(obj, prop, descriptor)\r\n  }\r\n  return obj\r\n}\r\n\r\n\r\nexport default Object\r\n","export default (name, f) => Object.defineProperty(f, 'name', { value: name })\r\n","import {\r\n  SUPER_CHAIN_PROTO_PROP,\r\n  SUPER_CHAIN_APPLY_PROP,\r\n  PROTOTYPE_IS_EXTENDED_PROP\r\n} from './props'\r\n\r\nexport const _copyChain = (Extended, ProtoChain, chainPropName, ignoreExtended) => {\r\n  //if chain on [Extended] has not been created yet\r\n  if(!Extended.prototype[chainPropName]) {\r\n    Object.defineProperty(Extended.prototype, chainPropName, { value: [] })\r\n  }\r\n\r\n  ProtoChain.forEach(Proto => {\r\n    //console.log(!!Proto.prototype['__extended__'], Proto)\r\n    //if [Proto] has been '__extended__' and has same-named proto chain, copy the Proto chain to Extended chain\r\n    const isExtended = !!Proto.prototype[PROTOTYPE_IS_EXTENDED_PROP],\r\n          hasSameChain = !!Proto.prototype[chainPropName]\r\n\r\n    const alreadyInChain = Extended.prototype[chainPropName].some(P => P === Proto),\r\n          shouldBePushed = (!isExtended || !ignoreExtended) && !alreadyInChain,\r\n          shouldCopyChain = isExtended && hasSameChain\r\n\r\n    if(shouldCopyChain)\r\n      Proto.prototype[chainPropName].forEach(Proto => {\r\n        //avoid pushing twice\r\n        if(!Extended.prototype[chainPropName].some(P => P === Proto) ) {\r\n          //console.log('pushed', Proto)\r\n          Extended.prototype[chainPropName].push(Proto)\r\n        }\r\n      })\r\n\r\n    if(shouldBePushed) {\r\n      Extended.prototype[chainPropName].push(Proto)\r\n    }\r\n  })\r\n\r\n  //console.log(Extended.prototype[chainPropName])\r\n}\r\n\r\nexport const _extend = (options = {}) => {\r\n  if(!options.apply)\r\n    options.apply = []\r\n  if(!options.super)\r\n    options.super = []\r\n  if(!options.static)\r\n    options.static = []\r\n\r\n  const Child = options.super[0]\r\n\r\n  if(!options.name)\r\n    options.name = Child.name\r\n\r\n  function Extended() {\r\n    Extended.prototype[SUPER_CHAIN_APPLY_PROP].forEach(Super => {\r\n      if(Super !== Extended) {\r\n        Super.apply(this, arguments)\r\n      }\r\n    })\r\n  }\r\n\r\n  _named(options.name, Extended)\r\n\r\n  for(let i in options.static) {\r\n    for(let prop in options.static[i]) {\r\n      if('prototype' != prop) {\r\n        Object.defineProperty(Extended, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  Object.defineProperty(Extended, 'prototype', { value: {} })\r\n  Object.defineProperty(Extended.prototype, 'constructor', { value: Child })\r\n  Object.defineProperty(Extended.prototype, PROTOTYPE_IS_EXTENDED_PROP, { value: true })\r\n\r\n  for(let i in options.super) {\r\n    function Proto() {}\r\n    Proto.prototype = options.super[i].prototype\r\n    const proto = new Proto()\r\n\r\n    for(let prop in proto) {\r\n      if(['constructor', PROTOTYPE_IS_EXTENDED_PROP, SUPER_CHAIN_PROTO_PROP, SUPER_CHAIN_APPLY_PROP].indexOf(prop) < 0) {\r\n        Object.defineProperty(Extended.prototype, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  _copyChain(Extended, options.super, SUPER_CHAIN_PROTO_PROP, false)\r\n  _copyChain(Extended, options.apply, SUPER_CHAIN_APPLY_PROP, true)\r\n\r\n  return Extended\r\n}\r\n\r\nexport const extend = (...args) => _extend({ super: args.slice(1), apply: args })\r\n","Array.prototype.concat = function () {\r\n  const concatenated = []\r\n\r\n  for(let i in this) {\r\n    concatenated.push(this[i])\r\n  }\r\n\r\n  for(let i in arguments) {\r\n    for(let j in arguments[i]) {\r\n      concatenated.push(arguments[i][j])\r\n    }\r\n  }\r\n\r\n  return concatenated\r\n}\r\n\r\nexport default Array\r\n","// var PENDING = 'pending'\r\n// var SEALED = 'sealed'\r\n// var FULFILLED = 'fulfilled'\r\n// var REJECTED = 'rejected'\r\n//\r\n// var NOOP = function() {}\r\n//\r\n// function invokeResolver(resolver, promise) {\r\n//   function resolvePromise(value) {\r\n//     resolve(promise, value)\r\n//   }\r\n//\r\n//   function rejectPromise(reason) {\r\n//     reject(promise, reason)\r\n//   }\r\n//\r\n//   try {\r\n//     resolver(resolvePromise, rejectPromise)\r\n//   } catch(e) {\r\n//     rejectPromise(e)\r\n//   }\r\n// }\r\n//\r\n// function invokeCallback(subscriber) {\r\n//   var owner = subscriber.owner\r\n//   var settled = owner.state_\r\n//   var value = owner.data_\r\n//   var callback = subscriber[settled]\r\n//   var promise = subscriber.then\r\n//\r\n//   if (typeof callback === 'function')\r\n//   {\r\n//     settled = FULFILLED\r\n//     try {\r\n//       value = callback(value)\r\n//     } catch(e) {\r\n//       reject(promise, e)\r\n//     }\r\n//   }\r\n//\r\n//   if (!handleThenable(promise, value))\r\n//   {\r\n//     if (settled === FULFILLED)\r\n//       resolve(promise, value)\r\n//\r\n//     if (settled === REJECTED)\r\n//       reject(promise, value)\r\n//   }\r\n// }\r\n//\r\n// function handleThenable(promise, value) {\r\n//   var resolved\r\n//\r\n//   try {\r\n//     if (promise === value)\r\n//       throw new TypeError('A promises callback cannot return that same promise.')\r\n//\r\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\r\n//     {\r\n//       var then = value.then  // then should be retrived only once\r\n//\r\n//       if (typeof then === 'function')\r\n//       {\r\n//         then.call(value, function(val){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             if (value !== val)\r\n//               resolve(promise, val)\r\n//             else\r\n//               fulfill(promise, val)\r\n//           }\r\n//         }, function(reason){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             reject(promise, reason)\r\n//           }\r\n//         })\r\n//\r\n//         return true\r\n//       }\r\n//     }\r\n//   } catch (e) {\r\n//     if (!resolved)\r\n//       reject(promise, e)\r\n//\r\n//     return true\r\n//   }\r\n//\r\n//   return false\r\n// }\r\n//\r\n// function resolve(promise, value){\r\n//   if (promise === value || !handleThenable(promise, value))\r\n//     fulfill(promise, value)\r\n// }\r\n//\r\n// function publish(promise) {\r\n//   var callbacks = promise.then_\r\n//   promise.then_ = undefined\r\n//\r\n//   for (var i = 0 i < callbacks.length i++) {\r\n//     invokeCallback(callbacks[i])\r\n//   }\r\n// }\r\n//\r\n// function fulfill(promise, value){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = value\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = FULFILLED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function reject(promise, reason){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = reason\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = REJECTED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function Promise(resolver) {\r\n//   if (typeof resolver !== 'function')\r\n//     throw new TypeError('Promise constructor takes a function argument')\r\n//\r\n//   if (this instanceof Promise === false)\r\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\r\n//\r\n//   this.then_ = []\r\n//\r\n//   invokeResolver(resolver, this)\r\n// }\r\n//\r\n// Promise.prototype = {\r\n//   constructor: Promise,\r\n//\r\n//   state_: PENDING,\r\n//   then_: null,\r\n//   data_: undefined,\r\n//\r\n//   then: function(onFulfillment, onRejection){\r\n//     var subscriber = {\r\n//       owner: this,\r\n//       then: new this.constructor(NOOP),\r\n//       fulfilled: onFulfillment,\r\n//       rejected: onRejection\r\n//     }\r\n//\r\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\r\n//     {\r\n//       // already resolved, call callback async\r\n//       setImmediate(() => {invokeCallback(subscriber)})\r\n//     }\r\n//     else\r\n//     {\r\n//       // subscribe\r\n//       this.then_.push(subscriber)\r\n//     }\r\n//\r\n//     return subscriber.then\r\n//   },\r\n//\r\n//   'catch': function(onRejection) {\r\n//     return this.then(null, onRejection)\r\n//   }\r\n// }\r\n\r\n// Promise.all = function(promises) {\r\n//   if (!(promises instanceof Array)) {\r\n//     throw new TypeError('You must pass an array to Promise.all().')\r\n//   }\r\n//\r\n//   return new Promise((resolve, reject) => {\r\n//     var results = []\r\n//     var remaining = 0\r\n//\r\n//     function resolver(index) {\r\n//       remaining++\r\n//       return function(value) {\r\n//         results[index] = value\r\n//         if (!--remaining) {\r\n//           resolve(results)\r\n//         }\r\n//       }\r\n//     }\r\n//\r\n//     for (var i = 0, promise; i < promises.length; i++) {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function') {\r\n//         promise.then(resolver(i), reject)\r\n//       }\r\n//       else {\r\n//         results[i] = promise\r\n//       }\r\n//     }\r\n//\r\n//     if (!remaining) {\r\n//       resolve(results)\r\n//     }\r\n//   })\r\n// }\r\n\r\nPromise.race = function(promises){\r\n  var Class = this\r\n\r\n  if (!(promises instanceof Array))\r\n    throw new TypeError('You must pass an array to Promise.race().')\r\n\r\n  return new Class((resolve, reject) => {\r\n    for (var i = 0, promise; i < promises.length; i++)\r\n    {\r\n      promise = promises[i]\r\n\r\n      if (promise && typeof promise.then === 'function')\r\n        promise.then(resolve, reject)\r\n      else\r\n        resolve(promise)\r\n    }\r\n  })\r\n}\r\n\r\n// Promise.resolve = function(value) {\r\n//   var Class = this\r\n//\r\n//   if (value && typeof value === 'object' && value.constructor === Class)\r\n//     return value\r\n//\r\n//   return new Class(function(resolve){\r\n//     resolve(value)\r\n//   })\r\n// }\r\n//\r\n// Promise.reject = function(reason){\r\n//   var Class = this\r\n//\r\n//   return new Class(function(resolve, reject){\r\n//     reject(reason)\r\n//   })\r\n// }\r\n//\r\n\r\nexport default Promise\r\n","const loop = [\r\n  // immediate\r\n  { queue: [], immediatePush: true, tick: false },\r\n  // timeout\r\n  { queue: [], immediatePush: false, tick: false }\r\n]\r\n\r\nlet tick = false\r\n\r\nconst asyncFlush = () => {\r\n  for (let stage in loop) {\r\n    if(loop[stage].queue.length) {\r\n      if(loop[stage].immediatePush) {\r\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\r\n          loop[stage].queue[exec]()\r\n        }\r\n        loop[stage].queue.splice(0)\r\n      } else {\r\n        const queue = loop[stage].queue.splice(0)\r\n        for (let exec = 0; exec < queue.length; exec ++) {\r\n          queue[exec]()\r\n        }\r\n      }\r\n    }\r\n\r\n    loop[stage].tick = tick = false\r\n  }\r\n}\r\n\r\nconst asyncCall = stage => cb => {\r\n  loop[stage].queue.push(cb)\r\n\r\n  if (!tick && !loop[stage].tick) {\r\n    loop[stage].tick = tick = true\r\n\r\n    setTimeout(asyncFlush)\r\n  }\r\n}\r\n\r\nconst setImmediate = asyncCall(/* .immediate */0)\r\n\r\nconst timeoutCall = asyncCall(/* .timeeout */1)\r\n\r\nexport const _setTimeout = (cb, timeout) => setTimeout(() => { timeoutCall(cb) }, timeout)\r\n\r\nexport const _setInterval = (cb, timeout) => (function setTimer() {\r\n  return _setTimeout(() => {\r\n    setTimer()\r\n    cb()\r\n  }, timeout)\r\n})()\r\n\r\nexport {\r\n  setImmediate,\r\n  _setTimeout as setTimeout,\r\n  _setInterval as setInterval\r\n}\r\n","import {\r\n  PN532_PREAMBLE,\r\n  PN532_STARTCODE1,\r\n  PN532_STARTCODE2,\r\n  PN532_HOST_TO_PN532,\r\n  PN532_PN532_TO_HOST,\r\n  PN532_POSTAMBLE\r\n} from './constants'\r\n\r\nconst check = values => !(0xff & (-values.reduce((sum, value) => sum + value, 0)))\r\n\r\nconst LCS = (byte, length, frame) => check(frame.slice(-2))\r\n\r\nconst EXTENDED_LCS = (byte, length, frame) => check([frame[5] * 256 + frame[6], frame[7]])\r\n\r\nconst CHECKSUM = (byte, length, frame) => check(frame.slice(5))\r\n\r\nconst EXTENDED_CHECKSUM = (byte, length, frame) => check(frame.slice(8))\r\n\r\nconst BODY = frame => frame[3] - 1 /* response code + payload */\r\n\r\nconst EXTENDED_BODY = frame => 256 * frame[5] + frame[6]\r\n\r\nexport const INFO = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, undefined, LCS, PN532_PN532_TO_HOST],\r\n  BODY,\r\n  [CHECKSUM, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const XINFO = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0xff], 2, [EXTENDED_LCS, PN532_PN532_TO_HOST],\r\n  EXTENDED_BODY,\r\n  [EXTENDED_CHECKSUM, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const ERR = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1 , PN532_STARTCODE2, 0x01, 0xff, undefined, CHECKSUM, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const ACK = [\r\n  new Uint8Array([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x00, 0xff, PN532_POSTAMBLE])\r\n]\r\n\r\nexport const NACK = [\r\n  new Uint8Array([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0x00, PN532_POSTAMBLE])\r\n]\r\n\r\nexport const command = command =>\r\n  new Uint8Array([\r\n    PN532_PREAMBLE,\r\n    PN532_STARTCODE1,\r\n    PN532_STARTCODE2,\r\n    0xff & (command.length + 1),\r\n    0xff & (~command.length),\r\n    PN532_HOST_TO_PN532,\r\n    ...command,\r\n    // checksum\r\n    0xff & (-command.reduce((checksum, byte) => checksum + byte, PN532_HOST_TO_PN532)),\r\n    PN532_POSTAMBLE\r\n  ])\r\n","export default function series( arr, cb, done ) {\r\n  let i = 0\r\n  let aborted = false;\r\n  ( function next( res ) {\r\n    if ( !aborted ) {\r\n      if ( typeof res !== 'undefined' || i >= arr.length ) {\r\n        done && done( res )\r\n      } else {\r\n        setImmediate( () => {\r\n          try {\r\n            cb( next, arr[ i ], i++, arr )\r\n          } catch ( err ) {\r\n            next( err )\r\n            aborted = true\r\n          }\r\n        } )\r\n      }\r\n    }\r\n  } )()\r\n}\r\n","// import Bus from 'bus'\r\n//\r\n// const preamble = [ 1, 2, 3 ]\r\n// const postamble = [ 4, ( {\r\n//   getFrame,\r\n//   getAbsoluteIndex,\r\n//   getRelativeIndex\r\n// } ) => {\r\n//   console.log( getAbsoluteIndex( 1 ), getRelativeIndex( 0 ) )\r\n//   return true\r\n// }, 6 ]\r\n//\r\n// const bus = new Bus( {\r\n//   read() {},\r\n//   write() {},\r\n//   setup() {}\r\n// } )\r\n//\r\n// bus.on( 'error', console.error )\r\n//\r\n// bus.rx( [\r\n//   preamble,\r\n//   postamble\r\n// ], console.log )\r\n//\r\n// bus.push( preamble )\r\n// bus.push( postamble )\r\n\r\n// import Bus from 'bus'\r\n// import Schedule from 'schedule'\r\nimport * as Blink from 'blink'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  INFO,\r\n  XINFO\r\n} from 'nfc'\r\nimport Bus from 'nfc/bus'\r\nimport {\r\n  PN532_I2C_ADDRESS,\r\n  PN532_COMMAND_SAMCONFIGURATION,\r\n  PN532_SAM_NORMAL_MODE,\r\n  PN532_COMMAND_WRITEGPIO,\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  PN532_COMMAND_GETFIRMWAREVERSION,\r\n  PN532_COMMAND_WAKEUP,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_AUTH_B,\r\n  MIFARE_COMMAND_WRITE_4,\r\n  MIFARE_COMMAND_WRITE_16\r\n} from 'nfc/constants'\r\n\r\nimport {\r\n  encodeMessage,\r\n  decodeMessage,\r\n  textRecord\r\n} from 'esp-ndef'\r\n\r\n// let usbConsole = true\r\n// let consoleBus = null\r\n// let log = ''\r\n//\r\n//\r\n// function toggleConsole() {\r\n//   usbConsole = !usbConsole\r\n//   if (usbConsole) {\r\n//     consoleBus = null\r\n//     USB.removeAllListeners()\r\n//   } else {\r\n//     consoleBus = new Bus({\r\n//       setup() {\r\n//         USB.on('data', data => {\r\n//           this.parse.call(this, data)\r\n//           USB.setup()\r\n//           // USB.write(Buffer.from(['!', ...[].slice.call(data, 0)]))\r\n//         })\r\n//       },\r\n//       read() {},\r\n//       write() {}\r\n//     })\r\n//\r\n//     consoleBus.rx([Buffer.from('/on')], () => {\r\n//       Blink.once(LED1)\r\n//       USB.write(JSON.stringify(consoleBus._busState))\r\n//       // toggleConsole()\r\n//     })\r\n//\r\n//     // consoleBus.rx([Buffer.from('/off')], () => {\r\n//     //   LED1.write(1)\r\n//     //   // USB.write('/off\\r\\n')\r\n//     //   // toggleConsole()\r\n//     // })\r\n//     //\r\n//     // consoleBus.on('error', err => {\r\n//     //   Blink.once(LED1, 200)\r\n//     // })\r\n//\r\n//     consoleBus.setup()\r\n//   }\r\n//\r\n//   usbConsole ?\r\n//     USB.setConsole(false) :\r\n//     LoopbackA.setConsole(false)\r\n// }\r\n//\r\n// toggleConsole()\r\n\r\n// setWatch( toggleConsole, BTN1, {\r\n//   repeat: true,\r\n//   edge: 'rising',\r\n//   debounce: 50\r\n// } )\r\n//\r\n// Blink.start( LED2 )\r\n//\r\n// const encoded = encodeMessage( [\r\n//   textRecord( '2enhello world!' )\r\n// ] )\r\n//\r\n// import fs from 'fs'\r\n\r\nconst wakeup = command( [ PN532_COMMAND_WAKEUP ] )\r\nconst sam = command( [ PN532_COMMAND_SAMCONFIGURATION, PN532_SAM_NORMAL_MODE, 20, 0 ] )\r\n\r\n// [0, 0, 255, 0, 255, 0]\r\n// [0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0]\r\n\r\n// [0, 0, 255, 0, 255, 0, 2, 42, 1, 6, 7, 232, 0, 0, 0, ]\r\n\r\n// [1, 0, 0, 255, 0, 255, 0, 2, 42, 0, 0, 0, 0, 0, 0, 0]\r\n// [1, 0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0, 0, 0]\r\n\r\nfunction setup() {\r\n  if ( this.type == 'serial' ) {\r\n    this.transport.setup( 115200 )\r\n\r\n    this.transport.write( wakeup )\r\n    this.transport.write( sam )\r\n\r\n    setTimeout( () => {\r\n      this.transport.read()\r\n      this.transport.on( 'data', data => this.push( data ) )\r\n      console.log( 'Bus has been set up' )\r\n      Blink.once( LED1, 20, () => {\r\n        setTimeout( () => Blink.once( LED1, 20 ), 200 )\r\n      } )\r\n\r\n      this.rx( [\r\n        ...ACK,\r\n        ...INFO\r\n      ], frame => {\r\n        console.log( 'frame' )\r\n        console.log( frame )\r\n      } )\r\n\r\n      this.tx( command( [ PN532_COMMAND_GETFIRMWAREVERSION ] ) )\r\n    }, 500 )\r\n  } else if ( this.type == 'i2c' ) {\r\n    this.transport.setup( {\r\n      bitrate: 400 * 1000\r\n    } )\r\n\r\n    this.on( 'drain', () => {\r\n      this._read()\r\n    } )\r\n\r\n    try {\r\n      this.tx( 1 )\r\n    } catch ( err ) {\r\n      console.log( 'Handled', err.msg )\r\n      console.log( 'Continue...' )\r\n    }\r\n\r\n    this.tx( command( [ PN532_COMMAND_GETFIRMWAREVERSION ] ) )\r\n\r\n    this.rx( [\r\n      ...ACK,\r\n      ...INFO\r\n    ], {\r\n      timeout: 10\r\n    }, frame => {\r\n      console.log( 'frame' )\r\n      console.log( frame )\r\n    } )\r\n  }\r\n}\r\n\r\nconst bus = new Bus( {\r\n  transport: Serial1,\r\n  type: 'serial',\r\n  setup,\r\n  read( length ) {\r\n    if ( this.type == 'i2c' ) {\r\n      while ( true ) {\r\n        if ( this.transport.readFrom( PN532_I2C_ADDRESS, 1 )[ 0 ] ) {\r\n          const chunk = this.transport.readFrom( PN532_I2C_ADDRESS, 1 + length )\r\n          this.push( chunk )\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n    } else if ( this.type == 'serial' ) {\r\n      // const chunk = this.transport.read(length)\r\n      // this.push(chunk)\r\n    }\r\n  },\r\n  write( chunk ) {\r\n    if ( this.type == 'serial' ) {\r\n      this.transport.write( chunk )\r\n    } else if ( this.type == 'i2c' ) {\r\n      this.transport.writeTo( PN532_I2C_ADDRESS, chunk )\r\n    }\r\n  },\r\n  highWaterMark: 16\r\n} )\r\n\r\nbus.on( 'error', err => {\r\n  console.error( 'BusError:', err )\r\n} )\r\n\r\nbus.setup()\r\n\r\n// const key = new Uint8  Array(Array(6).fill(0xff))\r\n\r\n// console.log(key)\r\n\r\n\r\n// setTimeout(() => {\r\n//   (function poll() {\r\n//     // console.log(process.memory().free)\r\n//     // console.log(bus._busState.watching.length)\r\n//     Promise.resolve()\r\n//       .then(() => bus.findTargets(1, 'A')) // .then(data => { console.log('found card', data.uid); return data })\r\n//       .then(data => {\r\n//         LED1.write(0)\r\n//         return data\r\n//       })\r\n//       // .then(data => bus.authenticate(4, data.uid, key).then(data => { console.log('auth op 4:', data) }).then(() => bus.authenticate(3, data.uid, key).then(data => { console.log('auth op:', data) })))\r\n//       .then(data => bus.authenticate(1 * 4, data.uid, key)) // .then(data => { console.log('auth', data) })\r\n//       // .then(data => bus.writeBlock(4, [1, 3, 6, 4])).then(data => { console.log('write op:', data) })\r\n//       // .then(data => { console.time('reading 2 sector'); return data })\r\n//       .then(data => bus.readSector(1))\r\n//       .then(data => {\r\n//         LED1.write(1)\r\n//         return data\r\n//       }) // .then(data => { console.log('sector 2:', data); return data })\r\n//       .then(data => data.reduce((buffer, data) => [...buffer, ...[].slice.call(data.chunk, 0)], []))\r\n//       .then(console.log)\r\n//       // .then(data => { console.timeEnd('reading 2 sector'); return data })\r\n//       // .then(data => bus.readBlock(4)).then(data => { console.log('block 4:', data) })\r\n//       // .then(data => bus.readBlock(5)).then(data => { console.log('block 5:', data) })\r\n//       // .then(data => bus.readBlock(6)).then(data => { console.log('block 6:', data) })\r\n//       // .then(data => bus.readBlock(7)).then(data => { console.log('block 7:', data) })\r\n//       .catch(err => {\r\n//         LED1.write(1)\r\n//         console.error('Error:', err)\r\n//       })\r\n//       .then(() => {\r\n//         setTimeout(() => {\r\n//           poll()\r\n//         }, 500)\r\n//       })\r\n//   })()\r\n// }, 1000)\r\n"],"names":["Buffer","Error","EventEmitter","_listeners","_duplicateEvent","event","this","BufferState","options","assign","_resetWatcher","watcher","currentPattern","arrayOffset","patternIndex","byteIndex","index","active","_resetActive","_busState","emit","_decrementActive","_Bus","transport","type","_setup","setup","bind","_read","read","call","undefined","length","_this2","highWaterMark","_write","write","DEFAULT_HIGHWATERMARK","console","time","timers","label","Date","now","timeEnd","log","toFixed","error","ON","OFF","process","env","CHIP","toUpperCase","once","led","timeout","cb","Object","target","args","i","obj","key","_defProp","defineProperty","prop","descriptor","e","desc","get","value","defineProperties","descriptors","_copyChain","Extended","ProtoChain","chainPropName","ignoreExtended","prototype","forEach","isExtended","Proto","PROTOTYPE_IS_EXTENDED_PROP","hasSameChain","alreadyInChain","some","P","shouldBePushed","push","_extend","SUPER_CHAIN_APPLY_PROP","Super","apply","super","static","Child","name","f","proto","SUPER_CHAIN_PROTO_PROP","indexOf","concat","concatenated","arguments","j","Promise","race","promises","Array","TypeError","resolve","reject","promise","then","from","iterable","offset","parsed","c","charCodeAt","Uint8Array","ArrayBuffer","slice","_list","_totalLength","list","totalLength","reduce","array","buffer","buf","set","loop","queue","immediatePush","tick","asyncFlush","stage","exec","splice","asyncCall","setImmediate","listener","on","removeListener","_listener","chunk","node","_buffer","next","unshift","count","nodes","_this","nodeIndex","to","callee","firstNode","lastNode","at","configured","ticker","watching","currentChunkIndex","watcherIndex","isEqual","patterns","err","byte","isArray","expected","RangeError","callback","pattern","nextPattern","ReferenceError","_this4","watch","unwatch","binary","Bus","check","values","sum","CHECKSUM","frame","INFO","PN532_PREAMBLE","PN532_STARTCODE1","PN532_STARTCODE2","ERR","ACK","NACK","command","PN532_HOST_TO_PN532","checksum","parseInfo","parseBlockData","data","body","code","cmd","info","parsers","done","fail","expect","parse","send","catch","makeTransaction","uid","block","PN532_COMMAND_INDATAEXCHANGE","MIFARE_COMMAND_AUTH_A","MIFARE_COMMAND_WRITE_16","sector","readBlocksArr","arr","aborted","res","readBlock","start","sam","bus","Serial1","wakeup","LED1","Blink","rx","tx","msg","readFrom","writeTo"],"mappings":"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"}