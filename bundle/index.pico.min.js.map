{"version":3,"file":"index.pico.min.js","sources":["../globals/buffer.js","../lib/events.js","../lib/stream/bufferState.js","../lib/bus.js","../lib/nfc/bus.js","../globals/console.js","../lib/blink.js","../globals/object.js","../globals/namedFunction.js","../globals/extend/index.js","../globals/array.js","../globals/promise.js","../globals/event-loop.js","../lib/nfc/frames.js","../helpers/series.js","../src/index.js"],"sourcesContent":["// import Uint8Array from './Uint8Array'\r\n// import { toBuffer } from './utils/to'\r\n\r\n// function copy(target) {\r\n// \tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\r\n// \t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\r\n// \t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\r\n//\r\n// \tlet copied = 0\r\n//\r\n// \tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\r\n// \t\ttarget.set([ this[sourceIndex] ], targetIndex)\r\n//\r\n// \treturn copied\r\n// }\r\n//\r\nfunction Buffer() {\r\n  throw new Error()\r\n}\r\n\r\n//Buffer.from = (iterable, offset, length) => E.toUint8Array(iterable)\r\n\r\nBuffer.from = (iterable, offset, length) => {\r\n  if (typeof iterable == 'string') {\r\n    const parsed = []\r\n\r\n    for (let c in iterable) {\r\n      parsed[c] = iterable.charCodeAt(c)\r\n    }\r\n\r\n    return new Uint8Array(parsed)\r\n  } else if (iterable instanceof ArrayBuffer) {\r\n    return new Uint8Array(iterable.slice(offset !== undefined ? offset : 0, offset + (length !== undefined ? length : iterable.length)))\r\n  } else if (iterable instanceof Array || iterable instanceof Uint8Array) {\r\n    return new Uint8Array(iterable)\r\n  } else {\r\n    throw new TypeError('Cannot create buffer from', typeof iterable)\r\n  }\r\n}\r\n\r\nBuffer.concat = (_list, _totalLength) => {\r\n  const list = _list || [],\r\n    totalLength = _totalLength !== undefined ? _totalLength : list.reduce((totalLength, array) => totalLength + array.length, 0),\r\n    buffer = Buffer.from([], 0, totalLength)\r\n\r\n  list.reduce((offset, buf) => {\r\n    buffer.set(buf, offset)\r\n    return offset + buf.length\r\n  }, 0)\r\n\r\n  return buffer\r\n}\r\n\r\nexport default Buffer\r\n","function EventEmitter() {\r\n  this._listeners = {}\r\n}\r\n\r\n//_named('EventEmitter', EventEmitter)\r\n\r\nfunction _duplicateEvent(event) {\r\n  if(event) {\r\n    if(`#${ event }` in this) {\r\n      this._listeners[event] = this[`#${ event }`]\r\n    } else {\r\n      delete this._listeners[event]\r\n    }\r\n  }\r\n}\r\n\r\nEventEmitter.prototype = {\r\n  on(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n\r\n    // this._listeners[event]\r\n    //   ? this._listeners[event].push(listener)\r\n    //   : this._listeners[event] = [listener]\r\n\r\n    return this\r\n  },\r\n\r\n  removeListener(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n    // if(!event) {\r\n    //   this._listeners = {}\r\n    // } else {\r\n    //   if(listener && this._listeners[event]) {\r\n    //     const index = this._listeners[event].indexOf(listener)\r\n    //\r\n    //     if(~index) {\r\n    //       this._listeners[event].splice(index, 1)\r\n    //     }\r\n    //   }\r\n    //\r\n    //   if(!listener || !this._listeners[event]) {\r\n    //     delete this._listeners[event]\r\n    //   }\r\n    // }\r\n    return this\r\n  },\r\n\r\n  once(event, listener) {\r\n    function once() {\r\n      this.removeListener(event, _listener)\r\n      return listener.apply(this, arguments)\r\n    }\r\n\r\n    return this.on(event, once)\r\n  }\r\n}\r\n\r\nexport default EventEmitter\r\n","function BufferState(options = {}) {\r\n  Object.assign(this, {\r\n\t\t_buffer: [],\r\n\t\tlength: 0\r\n\t}, options)\r\n}\r\n\r\nBufferState.prototype = {\r\n  push(chunk) {\r\n    if(chunk.length) {\r\n      const node = {\r\n    \t\tchunk: Buffer.from(chunk),\r\n        encoding: 'binary',\r\n    \t\tnext: null\r\n    \t}\r\n\r\n      if(this._buffer.length) {\r\n        this._buffer[this._buffer.length - 1].next = node\r\n      }\r\n\r\n      this._buffer.push(node)\r\n      this.length += node.chunk.length\r\n    }\r\n\r\n    return this.length\r\n  },\r\n\r\n  unshift(chunk) {\r\n    const node = {\r\n  \t\tchunk: Buffer.from(chunk),\r\n      encoding: 'binary',\r\n  \t\tnext: null\r\n  \t}\r\n\r\n    if(this._buffer.length) {\r\n      node.next = this._buffer[0]\r\n    }\r\n\r\n    this._buffer.unshift(node)\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  nodes(count) {\r\n    const nodes = this._buffer.splice(0, count)\r\n    nodes.forEach(node => this.length -= node.chunk.length)\r\n\r\n    return nodes\r\n  },\r\n\r\n  at(index) {\r\n    if(index >= this.length || index < 0) {\r\n      return\r\n    }\r\n\r\n    for(let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex ++) {\r\n      const chunk = this._buffer[nodeIndex].chunk\r\n      if(index < chunk.length) {\r\n        return {\r\n          index,\r\n          nodeIndex,\r\n          value: chunk[index]\r\n        }\r\n      }\r\n\r\n      index -= chunk.length\r\n    }\r\n  },\r\n\r\n  for(from, to, callee) {\r\n    const firstNode = this._buffer[from.nodeIndex]\r\n    for(let index = from.nodeIndex; index < firstNode.chunk.length; index ++) {\r\n      callee.call(this, firstNode.chunk[index])\r\n    }\r\n\r\n    for(let nodeIndex = 1 + from.nodeIndex; nodeIndex < to.nodeIndex; nodeIndex ++) {\r\n      const node = this._buffer[nodeIndex]\r\n      for(let index = 0; index < node.chunk.length; index ++) {\r\n        callee.call(this, node.chunk[index])\r\n      }\r\n    }\r\n\r\n    if(from.nodeIndex < to.nodeIndex) {\r\n      const lastNode = this._buffer[to.nodeIndex]\r\n      for(let index = 0; index <= to.index; index ++) {\r\n        callee.call(this, lastNode.chunk[index])\r\n      }\r\n    }\r\n  },\r\n\r\n  slice(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      to = this.at(length)\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n\r\n    const buffer = Buffer.from(Array(length))\r\n\r\n    const offset = this._buffer.slice(0, to.nodeIndex - 1).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset + node.chunk.length\r\n    }, 0)\r\n\r\n    if(offset < length) {\r\n      const node = this._buffer[to.nodeIndex]\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n    }\r\n\r\n    return buffer\r\n  },\r\n\r\n  buffer(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      // console.time('at')\r\n      to = this.at(length)\r\n      // console.timeEnd('at')\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n    // console.time('from')\r\n    const buffer = Buffer.from(Array(length))\r\n    // console.timeEnd('from')\r\n    // console.time('offset')\r\n\r\n    // console.timeEnd('buffer')\r\n\r\n    const offset = this.nodes(to.nodeIndex).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset + node.chunk.length\r\n    }, 0)\r\n    // console.timeEnd('offset')\r\n\r\n    if(offset < length) {\r\n      const node = this.nodes(1)[0]\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n      if(length - offset < node.chunk.length) {\r\n        node.chunk = node.chunk.slice(length - offset)\r\n\r\n        this.unshift(node.chunk)\r\n      }\r\n    }\r\n\r\n    return buffer\r\n  }\r\n}\r\n\r\nexport default BufferState\r\n","import EventEmitter from 'events'\r\nimport BufferState from 'stream/bufferState'\r\n//import Schedule from 'schedule'\r\nimport series from 'series'\r\n\r\nconst DEFAULT_HIGHWATERMARK = 64\r\n\r\nfunction _resetWatcher(watcher) {\r\n  return Object.assign(watcher, {\r\n    active: false,\r\n    currentPattern: null,\r\n    length: 0,\r\n    offset: 0,\r\n    byteIndex: 0,\r\n    patternIndex: 0\r\n  })\r\n}\r\n\r\nfunction _resetActive() {\r\n  this._busState.active = 0\r\n  this.emit('inactive')\r\n}\r\n\r\nfunction _decrementActive() {\r\n  if (!--this._busState.active) {\r\n    this.emit('inactive')\r\n  }\r\n}\r\n\r\nfunction _nextPattern(watcher) {\r\n  if (1 + watcher.patternIndex < watcher.list.length) {\r\n    // console.time('next pattern')\r\n    const nextPattern = watcher.list[++watcher.patternIndex /* patternIndex has already been incremented when checked condition */ ]\r\n    watcher.byteIndex = 0\r\n\r\n    if (typeof nextPattern == 'function') {\r\n      try {\r\n        watcher.currentPattern = nextPattern.call(this, this._busState.slice(watcher.length))\r\n      } catch (err) {\r\n        _resetWatcher(watcher)\r\n        _decrementActive.call(this)\r\n        this.emit('error', err)\r\n      }\r\n    } else {\r\n      watcher.currentPattern = nextPattern\r\n    }\r\n    // console.timeEnd('next pattern')\r\n  } else {\r\n    _found.call(this, watcher)\r\n  }\r\n}\r\n\r\nfunction _found(watcher) {\r\n  const { _busState } = this\r\n  const { watching } = _busState\r\n  const chunk = _busState.buffer(watcher.length)\r\n  _busState.nodeIndex = -1\r\n  try {\r\n    // console.time( 'cb' )\r\n    watcher.callback(\r\n      chunk,\r\n      // frame.splice(-watcher.length),\r\n      watcher.pattern\r\n    )\r\n    // console.timeEnd( 'cb' )\r\n  } catch (err) {\r\n    this.emit('error', err)\r\n  }\r\n  // _busState.watching = []\r\n  // console.time( 'reset' )\r\n  watching.forEach(_resetWatcher)\r\n  _resetActive.call(this)\r\n  // console.timeEnd( 'reset' )\r\n}\r\n\r\nfunction _push() {\r\n  const {\r\n    _busState\r\n  } = this\r\n  const {\r\n    watching,\r\n    _buffer\r\n  } = _busState\r\n\r\n  for (; _busState.nodeIndex < _buffer.length; _busState.nodeIndex++) {\r\n    if (!watching.length) {\r\n      this.emit('error', {\r\n        msg: 'Unexpected incoming data',\r\n        data: _busState.buffer()\r\n      })\r\n      return\r\n    }\r\n\r\n    if (_busState.nodeIndex < 0) {\r\n      _busState.nodeIndex = 0\r\n    }\r\n\r\n    const {\r\n      chunk\r\n    } = _buffer[_busState.nodeIndex]\r\n    let currentChunkIndex = 0\r\n    let currentIncomingWatcherIndex = 0\r\n    let watcherIndex = 0\r\n    let isEqual = false\r\n    let isChunkCorrupted = false\r\n\r\n    for (; currentChunkIndex < chunk.length; currentChunkIndex++) {\r\n      let isChunkCorrupted = false\r\n      if (!_busState.active) {\r\n        _busState.active = _busState.watching.reduce((active, watcher) => {\r\n          const {\r\n            list\r\n          } = watcher\r\n          try {\r\n            watcher.currentPattern = typeof list[0] == 'function' ? list[0](_busState.slice(watcher.length)) : list[0]\r\n            watcher.active = true\r\n            return 1 + active\r\n          } catch (err) {\r\n            this.emit('error', err)\r\n            return active\r\n          }\r\n        }, 0)\r\n      }\r\n\r\n      const byte = chunk[currentChunkIndex]\r\n\r\n      for (watcherIndex = 0; watcherIndex < watching.length; watcherIndex++, isEqual = false) {\r\n        const watcher = watching[watcherIndex]\r\n        if (!watcher.active) {\r\n          continue\r\n        }\r\n\r\n        const {\r\n          currentPattern\r\n        } = watcher\r\n        // let isEqual = false\r\n\r\n        if (Array.isArray(currentPattern)) {\r\n          const expected = currentPattern[watcher.byteIndex]\r\n\r\n          // console.log('current watching:', watcher.currentPattern)\r\n          // console.log('current chunk:', chunk)\r\n          // console.log('byte:', byte)\r\n          // console.log('expected:', expected)\r\n\r\n          if (expected === undefined || (typeof expected == 'number' && expected === byte)) {\r\n            isEqual = true\r\n          } else if (typeof expected == 'function') {\r\n            try {\r\n              isEqual = !!expected.call(this, byte, watcher.length /*i.e. index*/ , _busState.slice(watcher.length /*i.e. actual length*/ ))\r\n            } catch (err) {\r\n              this.emit('error', err)\r\n            }\r\n          }\r\n\r\n          if (isEqual) {\r\n            ++watcher.length\r\n\r\n            if (1 + watcher.byteIndex < currentPattern.length) {\r\n              ++watcher.byteIndex\r\n            } else {\r\n              _nextPattern.call(this, watcher)\r\n            }\r\n          } else {\r\n            _resetWatcher(watcher)\r\n            _decrementActive.call(this)\r\n\r\n            if (!_busState.active) {\r\n              this.emit('error', {\r\n                msg: 'Unparsed chunk',\r\n                data: _busState.buffer()\r\n              })\r\n            }\r\n          }\r\n        } else if (typeof currentPattern == 'number') {\r\n          if (currentPattern <= 0) {\r\n            throw new RangeError('Pattern length should be a positive integer, but set to', currentPattern)\r\n          }\r\n\r\n          if (watcher.offset <= 0) {\r\n            watcher.offset = currentPattern\r\n          }\r\n\r\n          watcher.length++\r\n\r\n          if (--watcher.offset < 1) {\r\n            _nextPattern.call(this, watcher)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (_busState.active) {\r\n    this.emit('drain')\r\n  }\r\n}\r\n\r\nfunction _Bus(options = {}) {\r\n  this.transport = options.transport\r\n  this.type = options.type\r\n  this._setup = options.setup.bind(this)\r\n  this._read = length => options.read.call(this, length === undefined ? length : this.options.highWaterMark)\r\n  this._write = options.write.bind(this)\r\n\r\n  this.options = {\r\n    highWaterMark: options.highWaterMark || DEFAULT_HIGHWATERMARK\r\n  }\r\n\r\n  this._busState = new BufferState({\r\n    watching: [],\r\n    active: 0,\r\n    nodeIndex: 0,\r\n    configured: false,\r\n    ticker: false\r\n  })\r\n}\r\n\r\n_Bus.prototype = {\r\n  setup() {\r\n    if (this._busState.configured) {\r\n      return Promise.reject('already configured')\r\n    }\r\n\r\n    this._busState.configured = true\r\n    return this._setup.apply(this, arguments)\r\n  },\r\n\r\n  push(chunk) {\r\n    if (chunk.length) {\r\n      this._busState.push(chunk)\r\n\r\n      if (!this._busState.ticker) {\r\n        this._busState.ticker = true\r\n        setImmediate(() => {\r\n          this._busState.ticker = false\r\n          _push.call(this)\r\n        })\r\n      }\r\n    }\r\n    // const highWaterMark = this.options.highWaterMark,\r\n    //       parse = _parse.bind(this)\r\n    //\r\n    // if(chunk.length > highWaterMark) {\r\n    //   const chunks = []\r\n    //   let subchunkIndex = 0\r\n    //\r\n    //   for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\r\n    //     const subchunk = chunk.slice(offset, offset += highWaterMark)\r\n    //     chunks.push(subchunk)\r\n    //   }\r\n    //\r\n    //   series(chunks, (next, subchunk) => {\r\n    //     parse(subchunk)\r\n    //     next()\r\n    //   })\r\n    // }\r\n    // else {\r\n    //   parse(chunk)\r\n    // }\r\n  },\r\n\r\n  watch(list, cb) {\r\n    const watcher = _resetWatcher({\r\n      list,\r\n      callback: cb.bind(this)\r\n    })\r\n\r\n    this._busState.watching.push(watcher)\r\n\r\n    return watcher\r\n  },\r\n\r\n  unwatch(watcher) {\r\n    if (watcher) {\r\n      const index = this._busState.watching.indexOf(watcher)\r\n\r\n      if (index >= 0) {\r\n        if (this._busState.watching[index].active) {\r\n          _resetWatcher(watcher)\r\n          _decrementActive.call(this)\r\n        }\r\n\r\n        this._busState.watching.splice(index, 1)\r\n      }\r\n    } else {\r\n      this._busState.watching.splice(0)\r\n      _resetActive.call(this)\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  /**\r\n    @TODO Promise interface\r\n  */\r\n\r\n  expect(list, ...args) {\r\n    let cb, options = {}\r\n\r\n    if (typeof args[0] == 'function') {\r\n      cb = args[0]\r\n    } else if (typeof args[1] == 'function') {\r\n      cb = args[1]\r\n      Object.assign(options, args[0])\r\n    } else {\r\n      throw new ReferenceError('Callback is not provided')\r\n    }\r\n\r\n    let watcher\r\n    const setWatcher = () => {\r\n      watcher = this.watch(list, (...args) => {\r\n        this.unwatch(watcher)\r\n        cb.apply(this, args)\r\n      })\r\n      this._read(this.options.highWaterMark)\r\n    }\r\n\r\n    // if ( 'timeout' in options ) {\r\n    //   setTimeout( setWatcher, options.timeout )\r\n    // } else {\r\n    //\r\n    // }\r\n\r\n    setWatcher()\r\n\r\n    return watcher\r\n  },\r\n\r\n  send(binary, options = {}) {\r\n    if ('timeout' in options) {\r\n      setTimeout(() => {\r\n        this._write(binary)\r\n      }, options.timeout)\r\n    } else {\r\n      this._write(binary)\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  reset() {\r\n    this._busState.watching.splice(0)\r\n    return this\r\n  }\r\n}\r\n\r\nconst Bus = _extend({\r\n  super: [EventEmitter, _Bus],\r\n  apply: [EventEmitter, _Bus]\r\n})\r\n\r\nexport default Bus\r\n","import Bus from 'bus'\r\nimport {\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_WRITE_16,\r\n  PN532_BRTY_ISO14443A,\r\n  PN532_BRTY_ISO14443B\r\n} from './constants'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  ERR,\r\n  INFO\r\n} from './frames'\r\n\r\nimport series from 'series'\r\n\r\nconst sliceAck = chunk => chunk.slice( ACK.length )\r\n\r\nconst parseInfo = chunk => {\r\n  return {\r\n    raw: chunk,\r\n    code: chunk[ 6 ],\r\n    body: Buffer.from( chunk.slice( 7, 5 + chunk[ 3 ] ) )\r\n  }\r\n}\r\n\r\nconst parseBlockData = data => {\r\n  if ( data.body.length == 1 ) {\r\n    throw {\r\n      cmd: data.code,\r\n      errCode: data.body[ 0 ]\r\n    }\r\n  } else {\r\n    return {\r\n      chunk: data.body.slice( 1 )\r\n    }\r\n  }\r\n}\r\n\r\nfunction _Bus() {}\r\n\r\n_Bus.prototype = {\r\n  makeTransaction( cmd, info, parsers ) {\r\n    return new Promise( ( done, fail ) => {\r\n        // Don't be silly again - info frame refers to index from beginning, i.e. to ACK\r\n        // this.expect([...ACK, ...info], chunk => done((parsers || [sliceAck, parseInfo]).reduce((data, parse) => parse(data), chunk)))\r\n        this.expect( ACK, () => {\r\n          this.expect( info, chunk => done( ( parsers || [ parseInfo ] )\r\n            .reduce( ( data, parse ) => parse( data ), chunk ) ) )\r\n        } )\r\n\r\n        this.expect( NACK, fail )\r\n        this.expect( ERR, fail )\r\n\r\n        this.send( command( cmd ) )\r\n      } )\r\n      .catch( err => {\r\n        this.unwatch()\r\n        throw err\r\n      } )\r\n      .then( data => {\r\n        this.unwatch()\r\n        return data\r\n      } )\r\n  },\r\n\r\n  findTargets( count, type ) {\r\n    if ( type == 'A' ) {\r\n      type = PN532_BRTY_ISO14443A\r\n    } else if ( type == 'B' ) {\r\n      type = PN532_BRTY_ISO14443B\r\n    } else {\r\n      throw new Error( 'Unknown ISO14443 type:', `\"${ type }\"` )\r\n    }\r\n\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INLISTPASSIVETARGET,\r\n      count,\r\n      type\r\n    ], INFO, [ chunk => {\r\n      const body = chunk.slice( 7, 5 + chunk[ 3 ] )\r\n      const uid = body.slice( 6, 6 + body[ 5 ] )\r\n      return {\r\n        code: chunk[ 6 ],\r\n        body,\r\n        count: body[ 0 ],\r\n        atqa: body.slice( 2, 4 ), // SENS_RES\r\n        sak: body[ 4 ],\r\n        uid\r\n      }\r\n    } ] )\r\n  },\r\n\r\n  authenticate( block, uid, key ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_AUTH_A,\r\n      block,\r\n      ...[].slice.call( key ),\r\n      ...[].slice.call( uid )\r\n    ], INFO )\r\n  },\r\n\r\n  readBlock( block ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_READ_16,\r\n      block\r\n    ], INFO, [ parseInfo, parseBlockData ] )\r\n  },\r\n\r\n  writeBlock( block, chunk ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_WRITE_16,\r\n      block,\r\n      ...[].slice.call( chunk )\r\n    ], INFO )\r\n  },\r\n\r\n  readSector( sector ) {\r\n    return new Promise( ( done, fail ) => {\r\n      const readBlocksArr = []\r\n      for ( let block = sector * 4; block < sector * 4 + 3; block++ ) {\r\n        readBlocksArr.push( block )\r\n      }\r\n\r\n      series( readBlocksArr, ( next, block, index ) => {\r\n        this.readBlock( block )\r\n          .then( data => {\r\n            readBlocksArr[ index ] = data\r\n            next()\r\n          } )\r\n          .catch( err => {\r\n            console.log( '!!!' )\r\n            next( err )\r\n          } )\r\n      }, err => err ? fail( err ) : done( readBlocksArr ) )\r\n    } )\r\n  },\r\n\r\n  writeSector( start, chunk ) {\r\n\r\n  }\r\n}\r\n\r\nexport default _extend({ super: [Bus, _Bus], apply: [Bus, _Bus] })\r\n","if(typeof console.time !== 'function') {\r\n  const timers = {}\r\n\r\n  console.time = label => {\r\n    timers[label] = Date.now()\r\n  }\r\n\r\n  console.timeEnd = label => {\r\n    if(label in timers) {\r\n      console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\r\n      delete timers[label]\r\n    }\r\n  }\r\n}\r\n\r\nif(typeof console.error !== 'function') {\r\n  console.error = console.log\r\n}\r\n\r\nexport default console\r\n","let defaultLed\r\nlet ON = 1,\r\n  OFF = 0\r\n\r\nif (process.env.CHIP && process.env.CHIP.toUpperCase() == 'ESP32') {\r\n  defaultLed = D5\r\n  ON = 0\r\n  OFF = 1\r\n} else {\r\n  defaultLed = LED2\r\n}\r\n\r\nlet status = false\r\nconst defaultTimeout = 20\r\n\r\nexport const once = (led, timeout, cb) => {\r\n  // D5.write(0)\r\n  // console.log('on')\r\n  led.write(ON)\r\n  setTimeout(() => {\r\n    // D5.write(1)\r\n    // console.log('off')\r\n    led.write(OFF)\r\n    cb && cb()\r\n  }, timeout || defaultTimeout)\r\n}\r\n\r\nexport const start = led => {\r\n  if (!led) {\r\n    led = defaultLed\r\n  }\r\n  if (!status) {\r\n    status = true\r\n\r\n    once(led, defaultTimeout, function cb() {\r\n      if (status) {\r\n        setTimeout(() => {\r\n          once(led, defaultTimeout, cb)\r\n        }, 1000 - defaultTimeout)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport const stop = () => {\r\n  if (status) {\r\n    status = false\r\n  }\r\n}\r\n","Object.assign = (target, ...args) => {\r\n  for(let i in args) {\r\n    const obj = args[i]\r\n    if(obj instanceof Object) {\r\n      for(let key in obj) {\r\n        target[key] = obj[key]\r\n      }\r\n    }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\nconst _defProp = Object.defineProperty\r\n\r\nObject.defineProperty = (obj, prop, descriptor) => {\r\n  try {\r\n    return _defProp(obj, prop, descriptor)\r\n  } catch(e) {\r\n    if(desc.get) {\r\n      obj.value = descriptor.get()\r\n    }\r\n    else if(desc.value) {\r\n      obj[prop] = descriptor.value\r\n    }\r\n\r\n    return obj\r\n  }\r\n}\r\n\r\nObject.defineProperties = (obj, descriptors) => {\r\n  for(let prop in descriptors) {\r\n    const descriptor = descriptors[prop]\r\n    Object.defineProperty(obj, prop, descriptor)\r\n  }\r\n  return obj\r\n}\r\n\r\n\r\nexport default Object\r\n","export default (name, f) => Object.defineProperty(f, 'name', { value: name })\r\n","import {\r\n  SUPER_CHAIN_PROTO_PROP,\r\n  SUPER_CHAIN_APPLY_PROP,\r\n  PROTOTYPE_IS_EXTENDED_PROP\r\n} from './props'\r\n\r\nexport const _copyChain = (Extended, ProtoChain, chainPropName, ignoreExtended) => {\r\n  //if chain on [Extended] has not been created yet\r\n  if(!Extended.prototype[chainPropName]) {\r\n    Object.defineProperty(Extended.prototype, chainPropName, { value: [] })\r\n  }\r\n\r\n  ProtoChain.forEach(Proto => {\r\n    //console.log(!!Proto.prototype['__extended__'], Proto)\r\n    //if [Proto] has been '__extended__' and has same-named proto chain, copy the Proto chain to Extended chain\r\n    const isExtended = !!Proto.prototype[PROTOTYPE_IS_EXTENDED_PROP],\r\n          hasSameChain = !!Proto.prototype[chainPropName]\r\n\r\n    const alreadyInChain = Extended.prototype[chainPropName].some(P => P === Proto),\r\n          shouldBePushed = (!isExtended || !ignoreExtended) && !alreadyInChain,\r\n          shouldCopyChain = isExtended && hasSameChain\r\n\r\n    if(shouldCopyChain)\r\n      Proto.prototype[chainPropName].forEach(Proto => {\r\n        //avoid pushing twice\r\n        if(!Extended.prototype[chainPropName].some(P => P === Proto) ) {\r\n          //console.log('pushed', Proto)\r\n          Extended.prototype[chainPropName].push(Proto)\r\n        }\r\n      })\r\n\r\n    if(shouldBePushed) {\r\n      Extended.prototype[chainPropName].push(Proto)\r\n    }\r\n  })\r\n\r\n  //console.log(Extended.prototype[chainPropName])\r\n}\r\n\r\nexport const _extend = (options = {}) => {\r\n  if(!options.apply)\r\n    options.apply = []\r\n  if(!options.super)\r\n    options.super = []\r\n  if(!options.static)\r\n    options.static = []\r\n\r\n  const Child = options.super[0]\r\n\r\n  if(!options.name)\r\n    options.name = Child.name\r\n\r\n  function Extended() {\r\n    Extended.prototype[SUPER_CHAIN_APPLY_PROP].forEach(Super => {\r\n      if(Super !== Extended) {\r\n        Super.apply(this, arguments)\r\n      }\r\n    })\r\n  }\r\n\r\n  _named(options.name, Extended)\r\n\r\n  for(let i in options.static) {\r\n    for(let prop in options.static[i]) {\r\n      if('prototype' != prop) {\r\n        Object.defineProperty(Extended, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  Object.defineProperty(Extended, 'prototype', { value: {} })\r\n  Object.defineProperty(Extended.prototype, 'constructor', { value: Child })\r\n  Object.defineProperty(Extended.prototype, PROTOTYPE_IS_EXTENDED_PROP, { value: true })\r\n\r\n  for(let i in options.super) {\r\n    function Proto() {}\r\n    Proto.prototype = options.super[i].prototype\r\n    const proto = new Proto()\r\n\r\n    for(let prop in proto) {\r\n      if(['constructor', PROTOTYPE_IS_EXTENDED_PROP, SUPER_CHAIN_PROTO_PROP, SUPER_CHAIN_APPLY_PROP].indexOf(prop) < 0) {\r\n        Object.defineProperty(Extended.prototype, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  _copyChain(Extended, options.super, SUPER_CHAIN_PROTO_PROP, false)\r\n  _copyChain(Extended, options.apply, SUPER_CHAIN_APPLY_PROP, true)\r\n\r\n  return Extended\r\n}\r\n\r\nexport const extend = (...args) => _extend({ super: args.slice(1), apply: args })\r\n","Array.prototype.concat = function () {\r\n  const concatenated = []\r\n\r\n  for(let i in this) {\r\n    concatenated.push(this[i])\r\n  }\r\n\r\n  for(let i in arguments) {\r\n    for(let j in arguments[i]) {\r\n      concatenated.push(arguments[i][j])\r\n    }\r\n  }\r\n\r\n  return concatenated\r\n}\r\n\r\nexport default Array\r\n","// var PENDING = 'pending'\r\n// var SEALED = 'sealed'\r\n// var FULFILLED = 'fulfilled'\r\n// var REJECTED = 'rejected'\r\n//\r\n// var NOOP = function() {}\r\n//\r\n// function invokeResolver(resolver, promise) {\r\n//   function resolvePromise(value) {\r\n//     resolve(promise, value)\r\n//   }\r\n//\r\n//   function rejectPromise(reason) {\r\n//     reject(promise, reason)\r\n//   }\r\n//\r\n//   try {\r\n//     resolver(resolvePromise, rejectPromise)\r\n//   } catch(e) {\r\n//     rejectPromise(e)\r\n//   }\r\n// }\r\n//\r\n// function invokeCallback(subscriber) {\r\n//   var owner = subscriber.owner\r\n//   var settled = owner.state_\r\n//   var value = owner.data_\r\n//   var callback = subscriber[settled]\r\n//   var promise = subscriber.then\r\n//\r\n//   if (typeof callback === 'function')\r\n//   {\r\n//     settled = FULFILLED\r\n//     try {\r\n//       value = callback(value)\r\n//     } catch(e) {\r\n//       reject(promise, e)\r\n//     }\r\n//   }\r\n//\r\n//   if (!handleThenable(promise, value))\r\n//   {\r\n//     if (settled === FULFILLED)\r\n//       resolve(promise, value)\r\n//\r\n//     if (settled === REJECTED)\r\n//       reject(promise, value)\r\n//   }\r\n// }\r\n//\r\n// function handleThenable(promise, value) {\r\n//   var resolved\r\n//\r\n//   try {\r\n//     if (promise === value)\r\n//       throw new TypeError('A promises callback cannot return that same promise.')\r\n//\r\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\r\n//     {\r\n//       var then = value.then  // then should be retrived only once\r\n//\r\n//       if (typeof then === 'function')\r\n//       {\r\n//         then.call(value, function(val){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             if (value !== val)\r\n//               resolve(promise, val)\r\n//             else\r\n//               fulfill(promise, val)\r\n//           }\r\n//         }, function(reason){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             reject(promise, reason)\r\n//           }\r\n//         })\r\n//\r\n//         return true\r\n//       }\r\n//     }\r\n//   } catch (e) {\r\n//     if (!resolved)\r\n//       reject(promise, e)\r\n//\r\n//     return true\r\n//   }\r\n//\r\n//   return false\r\n// }\r\n//\r\n// function resolve(promise, value){\r\n//   if (promise === value || !handleThenable(promise, value))\r\n//     fulfill(promise, value)\r\n// }\r\n//\r\n// function publish(promise) {\r\n//   var callbacks = promise.then_\r\n//   promise.then_ = undefined\r\n//\r\n//   for (var i = 0 i < callbacks.length i++) {\r\n//     invokeCallback(callbacks[i])\r\n//   }\r\n// }\r\n//\r\n// function fulfill(promise, value){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = value\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = FULFILLED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function reject(promise, reason){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = reason\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = REJECTED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function Promise(resolver) {\r\n//   if (typeof resolver !== 'function')\r\n//     throw new TypeError('Promise constructor takes a function argument')\r\n//\r\n//   if (this instanceof Promise === false)\r\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\r\n//\r\n//   this.then_ = []\r\n//\r\n//   invokeResolver(resolver, this)\r\n// }\r\n//\r\n// Promise.prototype = {\r\n//   constructor: Promise,\r\n//\r\n//   state_: PENDING,\r\n//   then_: null,\r\n//   data_: undefined,\r\n//\r\n//   then: function(onFulfillment, onRejection){\r\n//     var subscriber = {\r\n//       owner: this,\r\n//       then: new this.constructor(NOOP),\r\n//       fulfilled: onFulfillment,\r\n//       rejected: onRejection\r\n//     }\r\n//\r\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\r\n//     {\r\n//       // already resolved, call callback async\r\n//       setImmediate(() => {invokeCallback(subscriber)})\r\n//     }\r\n//     else\r\n//     {\r\n//       // subscribe\r\n//       this.then_.push(subscriber)\r\n//     }\r\n//\r\n//     return subscriber.then\r\n//   },\r\n//\r\n//   'catch': function(onRejection) {\r\n//     return this.then(null, onRejection)\r\n//   }\r\n// }\r\n\r\n// Promise.all = function(promises) {\r\n//   if (!(promises instanceof Array)) {\r\n//     throw new TypeError('You must pass an array to Promise.all().')\r\n//   }\r\n//\r\n//   return new Promise((resolve, reject) => {\r\n//     var results = []\r\n//     var remaining = 0\r\n//\r\n//     function resolver(index) {\r\n//       remaining++\r\n//       return function(value) {\r\n//         results[index] = value\r\n//         if (!--remaining) {\r\n//           resolve(results)\r\n//         }\r\n//       }\r\n//     }\r\n//\r\n//     for (var i = 0, promise; i < promises.length; i++) {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function') {\r\n//         promise.then(resolver(i), reject)\r\n//       }\r\n//       else {\r\n//         results[i] = promise\r\n//       }\r\n//     }\r\n//\r\n//     if (!remaining) {\r\n//       resolve(results)\r\n//     }\r\n//   })\r\n// }\r\n\r\nPromise.race = function(promises){\r\n  var Class = this\r\n\r\n  if (!(promises instanceof Array))\r\n    throw new TypeError('You must pass an array to Promise.race().')\r\n\r\n  return new Class((resolve, reject) => {\r\n    for (var i = 0, promise; i < promises.length; i++)\r\n    {\r\n      promise = promises[i]\r\n\r\n      if (promise && typeof promise.then === 'function')\r\n        promise.then(resolve, reject)\r\n      else\r\n        resolve(promise)\r\n    }\r\n  })\r\n}\r\n\r\n// Promise.resolve = function(value) {\r\n//   var Class = this\r\n//\r\n//   if (value && typeof value === 'object' && value.constructor === Class)\r\n//     return value\r\n//\r\n//   return new Class(function(resolve){\r\n//     resolve(value)\r\n//   })\r\n// }\r\n//\r\n// Promise.reject = function(reason){\r\n//   var Class = this\r\n//\r\n//   return new Class(function(resolve, reject){\r\n//     reject(reason)\r\n//   })\r\n// }\r\n//\r\n\r\nexport default Promise\r\n","const loop = [\r\n  // immediate\r\n  { queue: [], immediatePush: true, tick: false },\r\n  // timeout\r\n  { queue: [], immediatePush: false, tick: false }\r\n]\r\n\r\nlet tick = false\r\n\r\nconst asyncFlush = () => {\r\n  for (let stage in loop) {\r\n    if(loop[stage].queue.length) {\r\n      if(loop[stage].immediatePush) {\r\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\r\n          loop[stage].queue[exec]()\r\n        }\r\n        loop[stage].queue.splice(0)\r\n      } else {\r\n        const queue = loop[stage].queue.splice(0)\r\n        for (let exec = 0; exec < queue.length; exec ++) {\r\n          queue[exec]()\r\n        }\r\n      }\r\n    }\r\n\r\n    loop[stage].tick = tick = false\r\n  }\r\n}\r\n\r\nconst asyncCall = stage => cb => {\r\n  loop[stage].queue.push(cb)\r\n\r\n  if (!tick && !loop[stage].tick) {\r\n    loop[stage].tick = tick = true\r\n\r\n    setTimeout(asyncFlush)\r\n  }\r\n}\r\n\r\nconst setImmediate = asyncCall(/* .immediate */0)\r\n\r\nconst timeoutCall = asyncCall(/* .timeeout */1)\r\n\r\nexport const _setTimeout = (cb, timeout) => setTimeout(() => { timeoutCall(cb) }, timeout)\r\n\r\nexport const _setInterval = (cb, timeout) => (function setTimer() {\r\n  return _setTimeout(() => {\r\n    setTimer()\r\n    cb()\r\n  }, timeout)\r\n})()\r\n\r\nexport {\r\n  setImmediate,\r\n  _setTimeout as setTimeout,\r\n  _setInterval as setInterval\r\n}\r\n","import {\r\n  PN532_PREAMBLE,\r\n  PN532_STARTCODE1,\r\n  PN532_STARTCODE2,\r\n  PN532_HOST_TO_PN532,\r\n  PN532_PN532_TO_HOST,\r\n  PN532_POSTAMBLE\r\n} from './constants'\r\n\r\nconst check = values => !(0xff & (-values.reduce((sum, value) => sum + value, 0)))\r\n\r\nconst LCS = (byte, length, frame) => check(frame.slice(-2))\r\n\r\nconst EXTENDED_LCS = (byte, length, frame) => check([frame[5] * 256 + frame[6], frame[7]])\r\n\r\nconst CHECKSUM = (byte, length, frame) => check(frame.slice(5))\r\n\r\nconst EXTENDED_CHECKSUM = (byte, length, frame) => check(frame.slice(8))\r\n\r\nconst BODY = frame => frame[3] - 1 /* response code + payload */\r\n\r\nconst EXTENDED_BODY = frame => 256 * frame[5] + frame[6]\r\n\r\nexport const INFO = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, undefined, LCS, PN532_PN532_TO_HOST],\r\n  BODY,\r\n  [CHECKSUM, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const XINFO = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0xff], 2, [EXTENDED_LCS, PN532_PN532_TO_HOST],\r\n  EXTENDED_BODY,\r\n  [EXTENDED_CHECKSUM, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const ERR = [\r\n  [PN532_PREAMBLE, PN532_STARTCODE1 , PN532_STARTCODE2, 0x01, 0xff, undefined, CHECKSUM, PN532_POSTAMBLE]\r\n]\r\n\r\nexport const ACK = [\r\n  new Uint8Array([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x00, 0xff, PN532_POSTAMBLE])\r\n]\r\n\r\nexport const NACK = [\r\n  new Uint8Array([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0x00, PN532_POSTAMBLE])\r\n]\r\n\r\nexport const command = command =>\r\n  new Uint8Array([\r\n    PN532_PREAMBLE,\r\n    PN532_STARTCODE1,\r\n    PN532_STARTCODE2,\r\n    0xff & (command.length + 1),\r\n    0xff & (~command.length),\r\n    PN532_HOST_TO_PN532,\r\n    ...command,\r\n    // checksum\r\n    0xff & (-command.reduce((checksum, byte) => checksum + byte, PN532_HOST_TO_PN532)),\r\n    PN532_POSTAMBLE\r\n  ])\r\n","export default function series( arr, cb, done ) {\r\n  let i = 0\r\n  let aborted = false;\r\n  ( function next( res ) {\r\n    if ( !aborted ) {\r\n      if ( typeof res !== 'undefined' || i >= arr.length ) {\r\n        done && done( res )\r\n      } else {\r\n        setImmediate( () => {\r\n          try {\r\n            cb( next, arr[ i ], i++, arr )\r\n          } catch ( err ) {\r\n            next( err )\r\n            aborted = true\r\n          }\r\n        } )\r\n      }\r\n    }\r\n  } )()\r\n}\r\n","// import Bus from 'bus'\r\n//\r\n// const preamble = [ 1, 2, 3 ]\r\n// const postamble = [ 4, ( {\r\n//   getFrame,\r\n//   getAbsoluteIndex,\r\n//   getRelativeIndex\r\n// } ) => {\r\n//   console.log( getAbsoluteIndex( 1 ), getRelativeIndex( 0 ) )\r\n//   return true\r\n// }, 6 ]\r\n//\r\n// const bus = new Bus( {\r\n//   read() {},\r\n//   write() {},\r\n//   setup() {}\r\n// } )\r\n//\r\n// bus.on( 'error', console.error )\r\n//\r\n// bus.rx( [\r\n//   preamble,\r\n//   postamble\r\n// ], console.log )\r\n//\r\n// bus.push( preamble )\r\n// bus.push( postamble )\r\n\r\n// import Bus from 'bus'\r\n// import Schedule from 'schedule'\r\nimport * as Blink from 'blink'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  INFO,\r\n  XINFO\r\n} from 'nfc'\r\nimport Bus from 'nfc/bus'\r\nimport {\r\n  PN532_I2C_ADDRESS,\r\n  PN532_COMMAND_SAMCONFIGURATION,\r\n  PN532_SAM_NORMAL_MODE,\r\n  PN532_COMMAND_WRITEGPIO,\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  PN532_COMMAND_GETFIRMWAREVERSION,\r\n  PN532_COMMAND_WAKEUP,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_AUTH_B,\r\n  MIFARE_COMMAND_WRITE_4,\r\n  MIFARE_COMMAND_WRITE_16\r\n} from 'nfc/constants'\r\n\r\nimport {\r\n  encodeMessage,\r\n  decodeMessage,\r\n  textRecord\r\n} from 'esp-ndef'\r\n\r\n// let usbConsole = true\r\n// let consoleBus = null\r\n// let log = ''\r\n//\r\n//\r\n// function toggleConsole() {\r\n//   usbConsole = !usbConsole\r\n//   if (usbConsole) {\r\n//     consoleBus = null\r\n//     USB.removeAllListeners()\r\n//   } else {\r\n//     consoleBus = new Bus({\r\n//       setup() {\r\n//         USB.on('data', data => {\r\n//           this.parse.call(this, data)\r\n//           USB.setup()\r\n//           // USB.write(Buffer.from(['!', ...[].slice.call(data, 0)]))\r\n//         })\r\n//       },\r\n//       read() {},\r\n//       write() {}\r\n//     })\r\n//\r\n//     consoleBus.rx([Buffer.from('/on')], () => {\r\n//       Blink.once(LED1)\r\n//       USB.write(JSON.stringify(consoleBus._busState))\r\n//       // toggleConsole()\r\n//     })\r\n//\r\n//     // consoleBus.rx([Buffer.from('/off')], () => {\r\n//     //   LED1.write(1)\r\n//     //   // USB.write('/off\\r\\n')\r\n//     //   // toggleConsole()\r\n//     // })\r\n//     //\r\n//     // consoleBus.on('error', err => {\r\n//     //   Blink.once(LED1, 200)\r\n//     // })\r\n//\r\n//     consoleBus.setup()\r\n//   }\r\n//\r\n//   usbConsole ?\r\n//     USB.setConsole(false) :\r\n//     LoopbackA.setConsole(false)\r\n// }\r\n//\r\n// toggleConsole()\r\n\r\n// setWatch( toggleConsole, BTN1, {\r\n//   repeat: true,\r\n//   edge: 'rising',\r\n//   debounce: 50\r\n// } )\r\n//\r\n// Blink.start( LED2 )\r\n//\r\n// const encoded = encodeMessage( [\r\n//   textRecord( '2enhello world!' )\r\n// ] )\r\n//\r\n// import fs from 'fs'\r\n\r\nconst wakeup = command( [ PN532_COMMAND_WAKEUP ] )\r\nconst sam = command( [ PN532_COMMAND_SAMCONFIGURATION, PN532_SAM_NORMAL_MODE, 20, 0 ] )\r\n\r\n// [0, 0, 255, 0, 255, 0]\r\n// [0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0]\r\n\r\n// [0, 0, 255, 0, 255, 0, 2, 42, 1, 6, 7, 232, 0, 0, 0, ]\r\n\r\n// [1, 0, 0, 255, 0, 255, 0, 2, 42, 0, 0, 0, 0, 0, 0, 0]\r\n// [1, 0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0, 0, 0]\r\n\r\nfunction setup() {\r\n  if ( this.type == 'serial' ) {\r\n    this.transport.setup( 115200 )\r\n\r\n    this.transport.write( wakeup )\r\n    this.transport.write( sam )\r\n\r\n    setTimeout( () => {\r\n      this.transport.read()\r\n      this.transport.on( 'data', data => this.push( data ) )\r\n      console.log( 'Bus has been set up' )\r\n      Blink.once( LED1, 20, () => {\r\n        setTimeout( () => Blink.once( LED1, 20 ), 200 )\r\n      } )\r\n\r\n      this.rx( [\r\n        ...ACK,\r\n        ...INFO\r\n      ], frame => {\r\n        console.log( 'frame' )\r\n        console.log( frame )\r\n      } )\r\n\r\n      this.tx( command( [ PN532_COMMAND_GETFIRMWAREVERSION ] ) )\r\n    }, 500 )\r\n  } else if ( this.type == 'i2c' ) {\r\n    this.transport.setup( {\r\n      bitrate: 400 * 1000\r\n    } )\r\n\r\n    this.on( 'drain', () => {\r\n      this._read()\r\n    } )\r\n\r\n    try {\r\n      this.tx( 1 )\r\n    } catch ( err ) {\r\n      console.log( 'Handled', err.msg )\r\n      console.log( 'Continue...' )\r\n    }\r\n\r\n    this.tx( command( [ PN532_COMMAND_GETFIRMWAREVERSION ] ) )\r\n\r\n    this.rx( [\r\n      ...ACK,\r\n      ...INFO\r\n    ], {\r\n      timeout: 10\r\n    }, frame => {\r\n      console.log( 'frame' )\r\n      console.log( frame )\r\n    } )\r\n  }\r\n}\r\n\r\nconst bus = new Bus( {\r\n  transport: Serial1,\r\n  type: 'serial',\r\n  setup,\r\n  read( length ) {\r\n    if ( this.type == 'i2c' ) {\r\n      while ( true ) {\r\n        if ( this.transport.readFrom( PN532_I2C_ADDRESS, 1 )[ 0 ] ) {\r\n          const chunk = this.transport.readFrom( PN532_I2C_ADDRESS, 1 + length )\r\n          this.push( chunk )\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n    } else if ( this.type == 'serial' ) {\r\n      // const chunk = this.transport.read(length)\r\n      // this.push(chunk)\r\n    }\r\n  },\r\n  write( chunk ) {\r\n    if ( this.type == 'serial' ) {\r\n      this.transport.write( chunk )\r\n    } else if ( this.type == 'i2c' ) {\r\n      this.transport.writeTo( PN532_I2C_ADDRESS, chunk )\r\n    }\r\n  },\r\n  highWaterMark: 16\r\n} )\r\n\r\nbus.on( 'error', err => {\r\n  console.error( 'BusError:', err )\r\n} )\r\n\r\nbus.setup()\r\n\r\n// const key = new Uint8  Array(Array(6).fill(0xff))\r\n\r\n// console.log(key)\r\n\r\n\r\n// setTimeout(() => {\r\n//   (function poll() {\r\n//     // console.log(process.memory().free)\r\n//     // console.log(bus._busState.watching.length)\r\n//     Promise.resolve()\r\n//       .then(() => bus.findTargets(1, 'A')) // .then(data => { console.log('found card', data.uid); return data })\r\n//       .then(data => {\r\n//         LED1.write(0)\r\n//         return data\r\n//       })\r\n//       // .then(data => bus.authenticate(4, data.uid, key).then(data => { console.log('auth op 4:', data) }).then(() => bus.authenticate(3, data.uid, key).then(data => { console.log('auth op:', data) })))\r\n//       .then(data => bus.authenticate(1 * 4, data.uid, key)) // .then(data => { console.log('auth', data) })\r\n//       // .then(data => bus.writeBlock(4, [1, 3, 6, 4])).then(data => { console.log('write op:', data) })\r\n//       // .then(data => { console.time('reading 2 sector'); return data })\r\n//       .then(data => bus.readSector(1))\r\n//       .then(data => {\r\n//         LED1.write(1)\r\n//         return data\r\n//       }) // .then(data => { console.log('sector 2:', data); return data })\r\n//       .then(data => data.reduce((buffer, data) => [...buffer, ...[].slice.call(data.chunk, 0)], []))\r\n//       .then(console.log)\r\n//       // .then(data => { console.timeEnd('reading 2 sector'); return data })\r\n//       // .then(data => bus.readBlock(4)).then(data => { console.log('block 4:', data) })\r\n//       // .then(data => bus.readBlock(5)).then(data => { console.log('block 5:', data) })\r\n//       // .then(data => bus.readBlock(6)).then(data => { console.log('block 6:', data) })\r\n//       // .then(data => bus.readBlock(7)).then(data => { console.log('block 7:', data) })\r\n//       .catch(err => {\r\n//         LED1.write(1)\r\n//         console.error('Error:', err)\r\n//       })\r\n//       .then(() => {\r\n//         setTimeout(() => {\r\n//           poll()\r\n//         }, 500)\r\n//       })\r\n//   })()\r\n// }, 1000)\r\n"],"names":["Buffer","Error","EventEmitter","_listeners","_duplicateEvent","event","this","BufferState","options","assign","_resetWatcher","watcher","Object","_resetActive","_busState","active","emit","_decrementActive","_nextPattern","patternIndex","list","length","nextPattern","byteIndex","currentPattern","call","slice","err","watching","chunk","buffer","nodeIndex","callback","pattern","forEach","_Bus","transport","type","_setup","setup","bind","_read","read","undefined","_this2","highWaterMark","_write","write","DEFAULT_HIGHWATERMARK","console","time","timers","label","Date","now","timeEnd","log","toFixed","error","ON","OFF","process","env","CHIP","toUpperCase","once","led","timeout","cb","target","args","i","obj","key","_defProp","defineProperty","prop","descriptor","e","desc","get","value","defineProperties","descriptors","_copyChain","Extended","ProtoChain","chainPropName","ignoreExtended","prototype","isExtended","Proto","PROTOTYPE_IS_EXTENDED_PROP","hasSameChain","alreadyInChain","some","P","shouldBePushed","push","_extend","SUPER_CHAIN_APPLY_PROP","Super","apply","super","static","Child","name","f","proto","SUPER_CHAIN_PROTO_PROP","indexOf","concat","concatenated","arguments","j","Promise","race","promises","Array","TypeError","resolve","reject","promise","then","from","iterable","offset","parsed","c","charCodeAt","Uint8Array","ArrayBuffer","_list","_totalLength","totalLength","reduce","array","buf","set","loop","queue","immediatePush","tick","asyncFlush","stage","exec","splice","asyncCall","setImmediate","listener","on","removeListener","_listener","node","_buffer","next","unshift","count","nodes","_this","index","to","callee","firstNode","lastNode","at","configured","ticker","currentChunkIndex","watcherIndex","isEqual","byte","isArray","expected","RangeError","ReferenceError","_this4","watch","unwatch","binary","Bus","check","values","sum","CHECKSUM","frame","INFO","PN532_PREAMBLE","PN532_STARTCODE1","PN532_STARTCODE2","ERR","ACK","NACK","command","PN532_HOST_TO_PN532","checksum","parseInfo","parseBlockData","data","body","code","cmd","info","parsers","done","fail","expect","parse","send","catch","makeTransaction","uid","block","PN532_COMMAND_INDATAEXCHANGE","MIFARE_COMMAND_AUTH_A","MIFARE_COMMAND_WRITE_16","sector","readBlocksArr","arr","aborted","res","readBlock","start","sam","bus","Serial1","wakeup","LED1","Blink","rx","tx","msg","readFrom","writeTo"],"mappings":"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"}