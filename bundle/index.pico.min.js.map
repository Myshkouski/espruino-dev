{"version":3,"file":"index.pico.min.js","sources":["../globals/buffer.js","../modules/events.js","../modules/stream/bufferState.js","../modules/bus.js","../modules/nfc/bus.js","../globals/console.js","../globals/array.js","../globals/promise.js","../globals/arrayBuffer.js","../globals/object.js","../modules/blink.js","../globals/extend/index.js","../globals/namedFunction.js","../globals/event-loop.js","../modules/nfc/frames.js","../helpers/series.js","../src/index.js"],"sourcesContent":["// import Uint8Array from './Uint8Array'\n// import { toBuffer } from './utils/to'\n\n// function copy(target) {\n// \tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\n// \t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\n// \t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\n//\n// \tlet copied = 0\n//\n// \tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\n// \t\ttarget.set([ this[sourceIndex] ], targetIndex)\n//\n// \treturn copied\n// }\n\nconst Proto = Uint8Array\n\nfunction Buffer() {\n  throw new Error('Buffer proto is deprecated. Use Buffer.from() instead.')\n}\n\nBuffer.isBuffer = function (value) {\n  return value instanceof Proto\n}\n\nBuffer.from = function from(iterable, offset, length) {\n  if (typeof iterable == 'string') {\n    const parsed = []\n\n    for (let c in iterable) {\n      parsed[c] = iterable.charCodeAt(c)\n    }\n\n    return new Proto(parsed)\n  } else if (Array.isArray(iterable) || this.isBuffer(iterable)) {\n    return new Proto(iterable)\n  } else if (iterable instanceof ArrayBuffer) {\n    offset = offset !== undefined ? offset : 0\n    length = length !== undefined ? length : iterable.byteLength\n    return new Proto(iterable.slice(offset, offset + length))\n  } else {\n    throw new TypeError('Cannot create buffer from', typeof iterable)\n  }\n}\n\nBuffer.concat = function concat(_list, _totalLength) {\n  const list = _list || [],\n    totalLength = _totalLength !== undefined ? _totalLength : list.reduce((totalLength, array) => totalLength + array.length, 0),\n    buffer = this.from([], 0, totalLength)\n\n  list.reduce((offset, buf) => {\n    buffer.set(buf, offset)\n    return offset + buf.length\n  }, 0)\n\n  return buffer\n}\n\nmodule.exports = Buffer\n","function EventEmitter() {\r\n  this._listeners = {}\r\n}\r\n\r\n//_named('EventEmitter', EventEmitter)\r\n\r\nfunction _duplicateEvent(event) {\r\n  if(event) {\r\n    if(`#${ event }` in this) {\r\n      this._listeners[event] = this[`#${ event }`]\r\n    } else {\r\n      delete this._listeners[event]\r\n    }\r\n  }\r\n}\r\n\r\nEventEmitter.prototype = {\r\n  on(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n\r\n    // this._listeners[event]\r\n    //   ? this._listeners[event].push(listener)\r\n    //   : this._listeners[event] = [listener]\r\n\r\n    return this\r\n  },\r\n\r\n  removeListener(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n    // if(!event) {\r\n    //   this._listeners = {}\r\n    // } else {\r\n    //   if(listener && this._listeners[event]) {\r\n    //     const index = this._listeners[event].indexOf(listener)\r\n    //\r\n    //     if(~index) {\r\n    //       this._listeners[event].splice(index, 1)\r\n    //     }\r\n    //   }\r\n    //\r\n    //   if(!listener || !this._listeners[event]) {\r\n    //     delete this._listeners[event]\r\n    //   }\r\n    // }\r\n    return this\r\n  },\r\n\r\n  once(event, listener) {\r\n    function once() {\r\n      this.removeListener(event, _listener)\r\n      return listener.apply(this, arguments)\r\n    }\r\n\r\n    return this.on(event, once)\r\n  }\r\n}\r\n\r\nexport default EventEmitter\r\n","const bufferFrom = require('buffer-from')\n\nfunction BufferState(options = {}) {\n  Object.assign(this, {\n    _buffer: [],\n    length: 0\n  }, options)\n}\n\nfunction createNode(chunk) {\n  return {\n    chunk: bufferFrom(chunk),\n    encoding: 'binary',\n    next: null\n  }\n}\n\nBufferState.prototype = {\n  push(chunk) {\n    if (chunk.length) {\n      const node = createNode(chunk)\n\n      if (this._buffer.length) {\n        this._buffer[this._buffer.length - 1].next = node\n      }\n\n      this._buffer.push(node)\n      this.length += node.chunk.length\n    }\n\n    return this.length\n  },\n\n  unshift(chunk) {\n    const node = createNode(chunk)\n\n    if (this._buffer.length) {\n      node.next = this._buffer[0]\n    }\n\n    this._buffer.unshift(node)\n    this.length += node.chunk.length\n\n    return this.length\n  },\n\n  nodes(count) {\n    const nodes = this._buffer.splice(0, count)\n    nodes.forEach(node => this.length -= node.chunk.length)\n\n    return nodes\n  },\n\n  at(index) {\n    if (index >= this.length || index < 0) {\n      return\n    }\n\n    for (let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex++) {\n      const chunk = this._buffer[nodeIndex].chunk\n      if (index < chunk.length) {\n        return {\n          index,\n          nodeIndex,\n          value: chunk[index]\n        }\n      }\n\n      index -= chunk.length\n    }\n  },\n\n  for (from, to, callee) {\n    const firstNode = this._buffer[from.nodeIndex]\n    for (let index = from.nodeIndex; index < firstNode.chunk.length; index++) {\n      callee.call(this, firstNode.chunk[index])\n    }\n\n    for (let nodeIndex = 1 + from.nodeIndex; nodeIndex < to.nodeIndex; nodeIndex++) {\n      const node = this._buffer[nodeIndex]\n      for (let index = 0; index < node.chunk.length; index++) {\n        callee.call(this, node.chunk[index])\n      }\n    }\n\n    if (from.nodeIndex < to.nodeIndex) {\n      const lastNode = this._buffer[to.nodeIndex]\n      for (let index = 0; index <= to.index; index++) {\n        callee.call(this, lastNode.chunk[index])\n      }\n    }\n  },\n\n  slice(length) {\n    if (length === undefined) {\n      length = this.length\n    }\n\n    if (!length) {\n      return bufferFrom([])\n    }\n\n    if (length > this.length) {\n      length = this.length\n    }\n\n    let to\n\n    if (length) {\n      to = this.at(length)\n    }\n\n    if (!to) {\n      to = {\n        index: this.length - 1,\n        nodeIndex: this._buffer.length - 1\n      }\n    }\n\n    const buffer = bufferFrom(Array(length))\n\n    const offset = this._buffer.slice(to.nodeIndex - 1)\n      .reduce((offset, node) => {\n        buffer.set(node.chunk, offset)\n        return offset + node.chunk.length\n      }, 0)\n\n    if (offset < length) {\n      const node = this._buffer[to.nodeIndex]\n\n      buffer.set(node.chunk.slice(0, length - offset), offset)\n    }\n\n    return buffer\n  },\n\n  buffer(length) {\n    if (length === undefined) {\n      length = this.length\n    }\n\n    if (!length) {\n      return bufferFrom([])\n    }\n\n    if (length > this.length) {\n      length = this.length\n    }\n\n    let to\n\n    if (length) {\n      // console.time('at')\n      to = this.at(length)\n      // console.timeEnd('at')\n    }\n\n    if (!to) {\n      to = {\n        index: this.length - 1,\n        nodeIndex: this._buffer.length - 1\n      }\n    }\n    // console.time('from')\n    const buffer = bufferFrom(Array(length))\n    // console.timeEnd('from')\n    // console.time('offset')\n\n    // console.timeEnd('buffer')\n\n    const offset = this.nodes(to.nodeIndex)\n      .reduce((offset, node) => {\n        buffer.set(node.chunk, offset)\n        return offset + node.chunk.length\n      }, 0)\n    // console.timeEnd('offset')\n\n    if (offset < length) {\n      const node = this.nodes(1)[0]\n\n      buffer.set(node.chunk.slice(0, length - offset), offset)\n      if (length - offset < node.chunk.length) {\n        node.chunk = node.chunk.slice(length - offset)\n\n        this.unshift(node.chunk)\n      }\n    }\n\n    return buffer\n  }\n}\n\nexport default BufferState\n","import EventEmitter from 'events'\nimport BufferState from 'stream/bufferState'\n//import Schedule from 'schedule'\nimport series from 'series'\n\nconst DEFAULT_HIGHWATERMARK = 64\n\nfunction _resetWatcher(watcher) {\n  return Object.assign(watcher, {\n    active: false,\n    currentPattern: null,\n    length: 0,\n    offset: 0,\n    byteIndex: 0,\n    patternIndex: 0\n  })\n}\n\nfunction _resetActive() {\n  this._busState.active = 0\n  this.emit('inactive')\n}\n\nfunction _decrementActive() {\n  if (!--this._busState.active) {\n    this.emit('inactive')\n  }\n}\n\nfunction _found(watcher) {\n  const {\n    _busState\n  } = this\n  const {\n    watching\n  } = _busState\n  const chunk = _busState.buffer(watcher.length)\n  _busState.nodeIndex = -1\n  try {\n    // console.time( 'cb' )\n    watcher.callback(\n      chunk,\n      // frame.splice(-watcher.length),\n      watcher\n    )\n    // console.timeEnd( 'cb' )\n  } catch (err) {\n    this.emit('error', err)\n  }\n  // _busState.watching = []\n  // console.time( 'reset' )\n  watching.forEach(_resetWatcher)\n  _resetActive.call(this)\n  // console.timeEnd( 'reset' )\n}\n\nfunction _nextPattern(watcher) {\n  if (1 + watcher.patternIndex < watcher.list.length) {\n    // console.time('next pattern')\n    const nextPattern = watcher.list[++watcher.patternIndex /* patternIndex has already been incremented when checked condition */ ]\n    watcher.byteIndex = 0\n\n    if (typeof nextPattern == 'function') {\n      try {\n        watcher.currentPattern = nextPattern.call(this, this._busState.slice(1 + watcher.length))\n      } catch (err) {\n        _resetWatcher(watcher)\n        _decrementActive.call(this)\n        this.emit('error', err)\n      }\n    } else {\n      watcher.currentPattern = nextPattern\n    }\n    // console.timeEnd('next pattern')\n  } else {\n    _found.call(this, watcher)\n  }\n}\n\nfunction _push() {\n  // console.log( '_push()' )\n  const {\n    _busState\n  } = this\n  const {\n    watching,\n    _buffer\n  } = _busState\n\n  for (; _busState.nodeIndex < _buffer.length; _busState.nodeIndex++) {\n    if (!watching.length) {\n      this.emit('error', {\n        msg: 'Unexpected incoming data',\n        data: _busState.buffer()\n      })\n      return\n    }\n\n    if (_busState.nodeIndex < 0) {\n      _busState.nodeIndex = 0\n    }\n\n    const {\n      chunk\n    } = _buffer[_busState.nodeIndex]\n    let currentChunkIndex = 0\n    let currentIncomingWatcherIndex = 0\n    let watcherIndex = 0\n    let isEqual = false\n    let isChunkCorrupted = false\n\n    if (!_busState.active) {\n      _busState.active = _busState.watching.reduce((active, watcher) => {\n        const {\n          list\n        } = watcher\n        try {\n          watcher.currentPattern = typeof list[0] == 'function' ? list[0].call(this, _busState.slice(watcher.length)) : list[0]\n          watcher.active = true\n          return 1 + active\n        } catch (err) {\n          this.emit('error', err)\n          return active\n        }\n      }, 0)\n    }\n\n    for (; currentChunkIndex < chunk.length; currentChunkIndex++) {\n      let isChunkCorrupted = false\n      const byte = chunk[currentChunkIndex]\n\n      for (watcherIndex = 0; watcherIndex < watching.length; watcherIndex++, isEqual = false) {\n        const watcher = watching[watcherIndex]\n        if (!watcher.active) {\n          continue\n        }\n\n        const {\n          currentPattern\n        } = watcher\n\n        if (Array.isArray(currentPattern) || ArrayBuffer.isView(currentPattern)) {\n          const expected = currentPattern[watcher.byteIndex]\n\n          if (expected === undefined || (typeof expected == 'number' && expected === byte)) {\n            isEqual = true\n          } else if (typeof expected == 'function') {\n            try {\n              isEqual = !!expected.call(this, byte, watcher.length - 1 /*i.e. index*/ , _busState.slice(1 + watcher.length /*i.e. actual length*/ ))\n            } catch (err) {\n              this.emit('error', err)\n            }\n          }\n\n          // if ( !isEqual ) {\n          //   console.log( 'current watching:', watcher.currentPattern )\n          //   console.log( 'current chunk:', chunk )\n          //   console.log( 'byte:', byte )\n          //   console.log( 'expected:', expected )\n          // }\n\n          if (isEqual) {\n            ++watcher.length\n\n            if (1 + watcher.byteIndex < currentPattern.length) {\n              ++watcher.byteIndex\n            } else {\n              _nextPattern.call(this, watcher)\n            }\n          } else {\n            _resetWatcher(watcher)\n            _decrementActive.call(this)\n\n            // console.log( 'active', _busState.active )\n\n            if (!_busState.active) {\n              this.emit('error', {\n                message: 'Unparsed chunk',\n                expected,\n                actual: byte,\n                pattern: currentPattern,\n                chunk: _busState.buffer(),\n                index: currentChunkIndex,\n                value: byte\n              })\n            }\n\n            // break\n          }\n        } else if (typeof currentPattern == 'number') {\n          if (currentPattern <= 0) {\n            throw Object.assign(new ReferenceError('Pattern length should be a positive integer'), {\n              pattern: currentPattern\n            })\n          }\n\n          if (watcher.offset <= 0) {\n            watcher.offset = currentPattern\n          }\n\n          watcher.length++\n\n          if (--watcher.offset < 1) {\n            _nextPattern.call(this, watcher)\n          }\n        } else {\n          throw new TypeError(`Cannot parse pattern of ${ typeof currentPattern } type`)\n        }\n      }\n    }\n  }\n\n  if (_busState.active) {\n    this.emit('drain')\n  }\n}\n\nfunction _Bus(options = {}) {\n  this.transport = options.transport\n  this.type = options.type\n  this._setup = options.setup.bind(this)\n  this._read = length => options.read.call(this, length === undefined ? length : this.options.highWaterMark)\n  this._write = options.write.bind(this)\n\n  this.options = {\n    highWaterMark: options.highWaterMark || DEFAULT_HIGHWATERMARK\n  }\n\n  this._busState = new BufferState({\n    watching: [],\n    active: 0,\n    nodeIndex: 0,\n    configured: false,\n    ticker: false\n  })\n}\n\n_Bus.prototype = {\n  setup() {\n    if (this._busState.configured) {\n      return Promise.reject('already configured')\n    }\n\n    this._busState.configured = true\n    return this._setup.apply(this, arguments)\n  },\n\n  push(chunk) {\n    // console.log( 'push()' )\n    // console.log( chunk )\n    if (chunk.length) {\n      this._busState.push(chunk)\n\n      if (!this._busState.ticker) {\n        this._busState.ticker = true\n        setImmediate(() => {\n          this._busState.ticker = false\n          _push.call(this)\n        })\n      }\n    }\n    // const highWaterMark = this.options.highWaterMark,\n    //       parse = _parse.bind(this)\n    //\n    // if(chunk.length > highWaterMark) {\n    //   const chunks = []\n    //   let subchunkIndex = 0\n    //\n    //   for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\n    //     const subchunk = chunk.slice(offset, offset += highWaterMark)\n    //     chunks.push(subchunk)\n    //   }\n    //\n    //   series(chunks, (next, subchunk) => {\n    //     parse(subchunk)\n    //     next()\n    //   })\n    // }\n    // else {\n    //   parse(chunk)\n    // }\n  },\n\n  watch(list, cb) {\n    const watcher = _resetWatcher({\n      list,\n      callback: cb.bind(this)\n    })\n\n    this._busState.watching.push(watcher)\n\n    return watcher\n  },\n\n  unwatch(watcher) {\n    if (watcher) {\n      const index = this._busState.watching.indexOf(watcher)\n\n      if (index >= 0) {\n        if (this._busState.watching[index].active) {\n          _resetWatcher(watcher)\n          _decrementActive.call(this)\n        }\n\n        this._busState.watching.splice(index, 1)\n      }\n    } else {\n      this._busState.watching.splice(0)\n      _resetActive.call(this)\n    }\n\n    return this\n  },\n\n  /**\n    @TODO Promise interface\n  */\n\n  expect(list, ...args) {\n    let cb, options = {}\n\n    if (typeof args[0] == 'function') {\n      cb = args[0]\n    } else if (typeof args[1] == 'function') {\n      cb = args[1]\n      Object.assign(options, args[0])\n    } else {\n      throw new ReferenceError('Callback is not provided')\n    }\n\n    let watcher\n    const setWatcher = () => {\n      watcher = this.watch(list, (...args) => {\n        this.unwatch(watcher)\n        cb.apply(this, args)\n      })\n      this._read(this.options.highWaterMark)\n    }\n\n    // if ( 'timeout' in options ) {\n    //   setTimeout( setWatcher, options.timeout )\n    // } else {\n    //\n    // }\n\n    setWatcher()\n\n    return watcher\n  },\n\n  send(binary, options = {}) {\n    if ('timeout' in options) {\n      setTimeout(() => {\n        this._write(binary)\n      }, options.timeout)\n    } else {\n      this._write(binary)\n    }\n\n    return this\n  },\n\n  reset() {\n    this._busState.watching.splice(0)\n    return this\n  }\n}\n\nconst Bus = _extend({\n  proto: [EventEmitter, _Bus],\n  apply: [EventEmitter, _Bus]\n})\n\nexport default Bus\n","import Bus from 'bus'\r\nimport {\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_WRITE_16,\r\n  PN532_BRTY_ISO14443A,\r\n  PN532_BRTY_ISO14443B\r\n} from './constants'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  ERR,\r\n  INFO\r\n} from './frames'\r\n\r\nimport series from 'series'\r\n\r\nconst sliceAck = chunk => chunk.slice( ACK.length )\r\n\r\nconst parseInfo = chunk => {\r\n  return {\r\n    raw: chunk,\r\n    code: chunk[ 6 ],\r\n    body: chunk.slice( 7, 5 + chunk[ 3 ] )\r\n  }\r\n}\r\n\r\nconst parseBlockData = data => {\r\n  if ( data.body.length == 1 ) {\r\n    throw {\r\n      cmd: data.code,\r\n      code: data.body[ 0 ]\r\n    }\r\n  } else {\r\n    return {\r\n      chunk: data.body.slice( 1 )\r\n    }\r\n  }\r\n}\r\n\r\nfunction _Bus() {}\r\n\r\n_Bus.prototype = {\r\n  makeTransaction( cmd, info, parsers ) {\r\n    return new Promise( ( done, fail ) => {\r\n        // Don't be silly again - info frame refers to index from beginning, i.e. to ACK\r\n        // this.expect([...ACK, ...info], chunk => done((parsers || [sliceAck, parseInfo]).reduce((data, parse) => parse(data), chunk)))\r\n        this.expect( ACK, () => {\r\n          this.expect( info, chunk => {\r\n            const _parsers = parsers || [ parseInfo ]\r\n            done( _parsers.reduce( ( data, parse ) => parse( data ), chunk ) )\r\n          } )\r\n        } )\r\n\r\n        this.expect( NACK, fail )\r\n        this.expect( ERR, fail )\r\n\r\n        this.send( command( cmd ) )\r\n      } )\r\n      .catch( err => {\r\n        this.unwatch()\r\n        throw err\r\n      } )\r\n      .then( data => {\r\n        this.unwatch()\r\n        return data\r\n      } )\r\n  },\r\n\r\n  findTargets( count, type ) {\r\n    if ( type == 'A' ) {\r\n      type = PN532_BRTY_ISO14443A\r\n    } else if ( type == 'B' ) {\r\n      type = PN532_BRTY_ISO14443B\r\n    } else {\r\n      throw new Error( 'Unknown ISO14443 type:', `\"${ type }\"` )\r\n    }\r\n\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INLISTPASSIVETARGET,\r\n      count,\r\n      type\r\n    ], INFO, [ chunk => {\r\n      const body = chunk.slice( 7, 5 + chunk[ 3 ] )\r\n      const uid = body.slice( 6, 6 + body[ 5 ] )\r\n      return {\r\n        code: chunk[ 6 ],\r\n        body,\r\n        count: body[ 0 ],\r\n        atqa: body.slice( 2, 4 ), // SENS_RES\r\n        sak: body[ 4 ],\r\n        uid\r\n      }\r\n    } ] )\r\n  },\r\n\r\n  authenticate( block, uid, key ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_AUTH_A,\r\n      block,\r\n      ...[].slice.call( key ),\r\n      ...[].slice.call( uid )\r\n    ], INFO )\r\n  },\r\n\r\n  readBlock( block ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_READ_16,\r\n      block\r\n    ], INFO, [ parseInfo, parseBlockData ] )\r\n  },\r\n\r\n  writeBlock( block, chunk ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_WRITE_16,\r\n      block,\r\n      ...[].slice.call( chunk )\r\n    ], INFO )\r\n  },\r\n\r\n  readSector( sector ) {\r\n    return new Promise( ( done, fail ) => {\r\n      const readBlocksArr = []\r\n      for ( let block = sector * 4; block < sector * 4 + 3; block++ ) {\r\n        readBlocksArr.push( block )\r\n      }\r\n\r\n      series( readBlocksArr, ( next, block, index ) => {\r\n        this.readBlock( block )\r\n          .then( data => {\r\n            readBlocksArr[ index ] = data\r\n            next()\r\n          } )\r\n          .catch( err => {\r\n            console.log( '!!!' )\r\n            next( err )\r\n          } )\r\n      }, err => err ? fail( err ) : done( readBlocksArr ) )\r\n    } )\r\n  },\r\n\r\n  writeSector( start, chunk ) {\r\n\r\n  }\r\n}\r\n\r\nexport default _extend( {\r\n  proto: [ Bus, _Bus ],\r\n  apply: [ Bus, _Bus ]\r\n} )\r\n","if(typeof console.time !== 'function') {\r\n  const timers = {}\r\n\r\n  console.time = label => {\r\n    timers[label] = Date.now()\r\n  }\r\n\r\n  console.timeEnd = label => {\r\n    if(label in timers) {\r\n      console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\r\n      delete timers[label]\r\n    }\r\n  }\r\n}\r\n\r\nif(typeof console.error !== 'function') {\r\n  console.error = console.log\r\n}\r\n\r\nexport default console\r\n","Array.prototype.concat = function () {\r\n  const concatenated = []\r\n\r\n  for(let i in this) {\r\n    concatenated.push(this[i])\r\n  }\r\n\r\n  for(let i in arguments) {\r\n    for(let j in arguments[i]) {\r\n      concatenated.push(arguments[i][j])\r\n    }\r\n  }\r\n\r\n  return concatenated\r\n}\r\n\r\nexport default Array\r\n","// var PENDING = 'pending'\r\n// var SEALED = 'sealed'\r\n// var FULFILLED = 'fulfilled'\r\n// var REJECTED = 'rejected'\r\n//\r\n// var NOOP = function() {}\r\n//\r\n// function invokeResolver(resolver, promise) {\r\n//   function resolvePromise(value) {\r\n//     resolve(promise, value)\r\n//   }\r\n//\r\n//   function rejectPromise(reason) {\r\n//     reject(promise, reason)\r\n//   }\r\n//\r\n//   try {\r\n//     resolver(resolvePromise, rejectPromise)\r\n//   } catch(e) {\r\n//     rejectPromise(e)\r\n//   }\r\n// }\r\n//\r\n// function invokeCallback(subscriber) {\r\n//   var owner = subscriber.owner\r\n//   var settled = owner.state_\r\n//   var value = owner.data_\r\n//   var callback = subscriber[settled]\r\n//   var promise = subscriber.then\r\n//\r\n//   if (typeof callback === 'function')\r\n//   {\r\n//     settled = FULFILLED\r\n//     try {\r\n//       value = callback(value)\r\n//     } catch(e) {\r\n//       reject(promise, e)\r\n//     }\r\n//   }\r\n//\r\n//   if (!handleThenable(promise, value))\r\n//   {\r\n//     if (settled === FULFILLED)\r\n//       resolve(promise, value)\r\n//\r\n//     if (settled === REJECTED)\r\n//       reject(promise, value)\r\n//   }\r\n// }\r\n//\r\n// function handleThenable(promise, value) {\r\n//   var resolved\r\n//\r\n//   try {\r\n//     if (promise === value)\r\n//       throw new TypeError('A promises callback cannot return that same promise.')\r\n//\r\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\r\n//     {\r\n//       var then = value.then  // then should be retrived only once\r\n//\r\n//       if (typeof then === 'function')\r\n//       {\r\n//         then.call(value, function(val){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             if (value !== val)\r\n//               resolve(promise, val)\r\n//             else\r\n//               fulfill(promise, val)\r\n//           }\r\n//         }, function(reason){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             reject(promise, reason)\r\n//           }\r\n//         })\r\n//\r\n//         return true\r\n//       }\r\n//     }\r\n//   } catch (e) {\r\n//     if (!resolved)\r\n//       reject(promise, e)\r\n//\r\n//     return true\r\n//   }\r\n//\r\n//   return false\r\n// }\r\n//\r\n// function resolve(promise, value){\r\n//   if (promise === value || !handleThenable(promise, value))\r\n//     fulfill(promise, value)\r\n// }\r\n//\r\n// function publish(promise) {\r\n//   var callbacks = promise.then_\r\n//   promise.then_ = undefined\r\n//\r\n//   for (var i = 0 i < callbacks.length i++) {\r\n//     invokeCallback(callbacks[i])\r\n//   }\r\n// }\r\n//\r\n// function fulfill(promise, value){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = value\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = FULFILLED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function reject(promise, reason){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = reason\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = REJECTED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function Promise(resolver) {\r\n//   if (typeof resolver !== 'function')\r\n//     throw new TypeError('Promise constructor takes a function argument')\r\n//\r\n//   if (this instanceof Promise === false)\r\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\r\n//\r\n//   this.then_ = []\r\n//\r\n//   invokeResolver(resolver, this)\r\n// }\r\n//\r\n// Promise.prototype = {\r\n//   constructor: Promise,\r\n//\r\n//   state_: PENDING,\r\n//   then_: null,\r\n//   data_: undefined,\r\n//\r\n//   then: function(onFulfillment, onRejection){\r\n//     var subscriber = {\r\n//       owner: this,\r\n//       then: new this.constructor(NOOP),\r\n//       fulfilled: onFulfillment,\r\n//       rejected: onRejection\r\n//     }\r\n//\r\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\r\n//     {\r\n//       // already resolved, call callback async\r\n//       setImmediate(() => {invokeCallback(subscriber)})\r\n//     }\r\n//     else\r\n//     {\r\n//       // subscribe\r\n//       this.then_.push(subscriber)\r\n//     }\r\n//\r\n//     return subscriber.then\r\n//   },\r\n//\r\n//   'catch': function(onRejection) {\r\n//     return this.then(null, onRejection)\r\n//   }\r\n// }\r\n\r\n// Promise.all = function(promises) {\r\n//   if (!(promises instanceof Array)) {\r\n//     throw new TypeError('You must pass an array to Promise.all().')\r\n//   }\r\n//\r\n//   return new Promise((resolve, reject) => {\r\n//     var results = []\r\n//     var remaining = 0\r\n//\r\n//     function resolver(index) {\r\n//       remaining++\r\n//       return function(value) {\r\n//         results[index] = value\r\n//         if (!--remaining) {\r\n//           resolve(results)\r\n//         }\r\n//       }\r\n//     }\r\n//\r\n//     for (var i = 0, promise; i < promises.length; i++) {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function') {\r\n//         promise.then(resolver(i), reject)\r\n//       }\r\n//       else {\r\n//         results[i] = promise\r\n//       }\r\n//     }\r\n//\r\n//     if (!remaining) {\r\n//       resolve(results)\r\n//     }\r\n//   })\r\n// }\r\n\r\nPromise.race = function(promises){\r\n  var Class = this\r\n\r\n  if (!(promises instanceof Array))\r\n    throw new TypeError('You must pass an array to Promise.race().')\r\n\r\n  return new Class((resolve, reject) => {\r\n    for (var i = 0, promise; i < promises.length; i++)\r\n    {\r\n      promise = promises[i]\r\n\r\n      if (promise && typeof promise.then === 'function')\r\n        promise.then(resolve, reject)\r\n      else\r\n        resolve(promise)\r\n    }\r\n  })\r\n}\r\n\r\n// Promise.resolve = function(value) {\r\n//   var Class = this\r\n//\r\n//   if (value && typeof value === 'object' && value.constructor === Class)\r\n//     return value\r\n//\r\n//   return new Class(function(resolve){\r\n//     resolve(value)\r\n//   })\r\n// }\r\n//\r\n// Promise.reject = function(reason){\r\n//   var Class = this\r\n//\r\n//   return new Class(function(resolve, reject){\r\n//     reject(reason)\r\n//   })\r\n// }\r\n//\r\n\r\nexport default Promise\r\n","const arrayBufferViewInstances = [\r\n  Int8Array,\r\n  Uint8Array,\r\n  Uint8ClampedArray,\r\n  Int16Array,\r\n  Uint16Array,\r\n  Int32Array,\r\n  Uint32Array,\r\n  Float32Array,\r\n  Float64Array,\r\n  DataView\r\n]\r\n\r\nArrayBuffer.isView = value => typeof value === 'object' && value.buffer instanceof ArrayBuffer // arrayBufferViewInstances.some( ArrayBufferView => value instanceof ArrayBufferView )\r\n\r\nexport default ArrayBuffer\r\n","Object.assign = ( target, ...args ) => {\r\n  for ( let i in args ) {\r\n    const obj = args[ i ]\r\n    if ( obj instanceof Object ) {\r\n      for ( let key in obj ) {\r\n        target[ key ] = obj[ key ]\r\n      }\r\n    }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\nconst _defProp = Object.defineProperty\r\n\r\nObject.defineProperty = ( obj, prop, descriptor ) => {\r\n  try {\r\n    return _defProp( obj, prop, descriptor )\r\n  } catch ( e ) {\r\n    if ( descriptor.get ) {\r\n      obj.value = descriptor.get()\r\n    } else if ( descriptor.value ) {\r\n      obj[ prop ] = descriptor.value\r\n    }\r\n\r\n    return obj\r\n  }\r\n}\r\n\r\nObject.defineProperties = ( obj, descriptors ) => {\r\n  for ( let prop in descriptors ) {\r\n    const descriptor = descriptors[ prop ]\r\n    Object.defineProperty( obj, prop, descriptor )\r\n  }\r\n  return obj\r\n}\r\n\r\n\r\nexport default Object\r\n","let defaultLed\r\nlet ON = 1,\r\n  OFF = 0\r\n\r\nif (process.env.CHIP && process.env.CHIP.toUpperCase() == 'ESP32') {\r\n  defaultLed = D5\r\n  ON = 0\r\n  OFF = 1\r\n} else {\r\n  defaultLed = LED2\r\n}\r\n\r\nlet status = false\r\nconst defaultTimeout = 20\r\n\r\nexport const once = (led, timeout, cb) => {\r\n  // D5.write(0)\r\n  // console.log('on')\r\n  led.write(ON)\r\n  setTimeout(() => {\r\n    // D5.write(1)\r\n    // console.log('off')\r\n    led.write(OFF)\r\n    cb && cb()\r\n  }, timeout || defaultTimeout)\r\n}\r\n\r\nexport const start = led => {\r\n  if (!led) {\r\n    led = defaultLed\r\n  }\r\n  if (!status) {\r\n    status = true\r\n\r\n    once(led, defaultTimeout, function cb() {\r\n      if (status) {\r\n        setTimeout(() => {\r\n          once(led, defaultTimeout, cb)\r\n        }, 1000 - defaultTimeout)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport const stop = () => {\r\n  if (status) {\r\n    status = false\r\n  }\r\n}\r\n","import {\r\n  SUPER_CHAIN_PROTO_PROP,\r\n  SUPER_CHAIN_APPLY_PROP,\r\n  PROTOTYPE_IS_EXTENDED_PROP\r\n} from './props'\r\n\r\nexport const _copyChain = ( Extended, ProtoChain, chainPropName, ignoreExtended ) => {\r\n  //if chain on [Extended] has not been created yet\r\n  if ( !Extended.prototype[ chainPropName ] ) {\r\n    Object.defineProperty( Extended.prototype, chainPropName, {\r\n      value: []\r\n    } )\r\n  }\r\n\r\n  ProtoChain.forEach( Proto => {\r\n    //console.log(!!Proto.prototype['__extended__'], Proto)\r\n    //if [Proto] has been '__extended__' and has same-named proto chain, copy the Proto chain to Extended chain\r\n    const isExtended = !!Proto.prototype[ PROTOTYPE_IS_EXTENDED_PROP ],\r\n      hasSameChain = !!Proto.prototype[ chainPropName ]\r\n\r\n    const alreadyInChain = Extended.prototype[ chainPropName ].some( P => P === Proto ),\r\n      shouldBePushed = ( !isExtended || !ignoreExtended ) && !alreadyInChain,\r\n      shouldCopyChain = isExtended && hasSameChain\r\n\r\n    if ( shouldCopyChain )\r\n      Proto.prototype[ chainPropName ].forEach( Proto => {\r\n        //avoid pushing twice\r\n        if ( !Extended.prototype[ chainPropName ].some( P => P === Proto ) ) {\r\n          //console.log('pushed', Proto)\r\n          Extended.prototype[ chainPropName ].push( Proto )\r\n        }\r\n      } )\r\n\r\n    if ( shouldBePushed ) {\r\n      Extended.prototype[ chainPropName ].push( Proto )\r\n    }\r\n  } )\r\n\r\n  //console.log(Extended.prototype[chainPropName])\r\n}\r\n\r\nexport const _extend = ( options = {} ) => {\r\n  if ( !options.apply )\r\n    options.apply = []\r\n  if ( !options.proto )\r\n    options.proto = []\r\n  // if ( !options.static )\r\n  //   options.static = []\r\n\r\n  const Child = options.proto[ 0 ]\r\n\r\n  if ( !options.name )\r\n    options.name = Child.name\r\n\r\n  function Extended() {\r\n    Extended.prototype[ SUPER_CHAIN_APPLY_PROP ].forEach( Super => {\r\n      if ( Super !== Extended ) {\r\n        Super.apply( this, arguments )\r\n      }\r\n    } )\r\n  }\r\n\r\n  _named( options.name, Extended )\r\n\r\n  // for ( let i in options.static ) {\r\n  //   for ( let prop in options.static[ i ] ) {\r\n  //     if ( 'prototype' != prop ) {\r\n  //       Object.defineProperty( Extended, prop, {\r\n  //         value: proto[ prop ],\r\n  //         enumerable: true,\r\n  //         writable: true\r\n  //       } )\r\n  //     }\r\n  //   }\r\n  // }\r\n\r\n  Object.defineProperty( Extended, 'prototype', {\r\n    value: {}\r\n  } )\r\n  Object.defineProperty( Extended.prototype, 'constructor', {\r\n    value: Child\r\n  } )\r\n  Object.defineProperty( Extended.prototype, PROTOTYPE_IS_EXTENDED_PROP, {\r\n    value: true\r\n  } )\r\n\r\n  for ( let i in options.proto ) {\r\n    function Proto() {}\r\n    Proto.prototype = options.proto[ i ].prototype\r\n    const proto = new Proto()\r\n\r\n    for ( let prop in proto ) {\r\n      if ( [ 'constructor', PROTOTYPE_IS_EXTENDED_PROP, SUPER_CHAIN_PROTO_PROP, SUPER_CHAIN_APPLY_PROP ].indexOf( prop ) < 0 ) {\r\n        Object.defineProperty( Extended.prototype, prop, {\r\n          value: proto[ prop ],\r\n          enumerable: true,\r\n          writable: true\r\n        } )\r\n      }\r\n    }\r\n  }\r\n\r\n  _copyChain( Extended, options.proto, SUPER_CHAIN_PROTO_PROP, false )\r\n  _copyChain( Extended, options.apply, SUPER_CHAIN_APPLY_PROP, true )\r\n\r\n  return Extended\r\n}\r\n\r\nexport const extend = ( ...args ) => _extend( {\r\n  super: args.slice( 1 ),\r\n  apply: args\r\n} )\r\n","export default (name, f) => Object.defineProperty(f, 'name', { value: name })\r\n","const loop = [\r\n  // immediate\r\n  { queue: [], immediatePush: true, tick: false },\r\n  // timeout\r\n  { queue: [], immediatePush: false, tick: false }\r\n]\r\n\r\nlet tick = false\r\n\r\nconst asyncFlush = () => {\r\n  for (let stage in loop) {\r\n    if(loop[stage].queue.length) {\r\n      if(loop[stage].immediatePush) {\r\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\r\n          loop[stage].queue[exec]()\r\n        }\r\n        loop[stage].queue.splice(0)\r\n      } else {\r\n        const queue = loop[stage].queue.splice(0)\r\n        for (let exec = 0; exec < queue.length; exec ++) {\r\n          queue[exec]()\r\n        }\r\n      }\r\n    }\r\n\r\n    loop[stage].tick = tick = false\r\n  }\r\n}\r\n\r\nconst asyncCall = stage => cb => {\r\n  loop[stage].queue.push(cb)\r\n\r\n  if (!tick && !loop[stage].tick) {\r\n    loop[stage].tick = tick = true\r\n\r\n    setTimeout(asyncFlush)\r\n  }\r\n}\r\n\r\nconst setImmediate = asyncCall(/* .immediate */0)\r\n\r\nconst timeoutCall = asyncCall(/* .timeeout */1)\r\n\r\nexport const _setTimeout = (cb, timeout) => setTimeout(() => { timeoutCall(cb) }, timeout)\r\n\r\nexport const _setInterval = (cb, timeout) => (function setTimer() {\r\n  return _setTimeout(() => {\r\n    setTimer()\r\n    cb()\r\n  }, timeout)\r\n})()\r\n\r\nexport {\r\n  setImmediate,\r\n  _setTimeout as setTimeout,\r\n  _setInterval as setInterval\r\n}\r\n","import {\r\n  PN532_PREAMBLE,\r\n  PN532_STARTCODE1,\r\n  PN532_STARTCODE2,\r\n  PN532_HOST_TO_PN532,\r\n  PN532_PN532_TO_HOST,\r\n  PN532_POSTAMBLE\r\n} from './constants'\r\n\r\nconst check = values => !( 0xff & ( -values.reduce( ( sum, value ) => sum + value, 0 ) ) )\r\n\r\nconst LCS = ( byte, length, frame ) => check( frame.slice( -2 ) )\r\n\r\nconst EXTENDED_LCS = ( byte, length, frame ) => check( [ frame[ 5 ] * 256 + frame[ 6 ], frame[ 7 ] ] )\r\n\r\nconst CHECKSUM = ( byte, length, frame ) => check( frame.slice( 5 ) )\r\n\r\nconst EXTENDED_CHECKSUM = ( byte, length, frame ) => check( frame.slice( 8 ) )\r\n\r\nconst BODY = frame => frame[ 3 ] - 1 /* response code + payload */\r\n\r\nconst EXTENDED_BODY = frame => 256 * frame[ 5 ] + frame[ 6 ]\r\n\r\nexport const INFO = [\r\n  [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, undefined, LCS, PN532_PN532_TO_HOST ],\r\n  BODY, [ CHECKSUM, PN532_POSTAMBLE ]\r\n]\r\n\r\nexport const XINFO = [\r\n  [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0xff ], 2, [ EXTENDED_LCS, PN532_PN532_TO_HOST ],\r\n  EXTENDED_BODY, [ EXTENDED_CHECKSUM, PN532_POSTAMBLE ]\r\n]\r\n\r\nexport const ERR = [\r\n  [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x01, 0xff, undefined, CHECKSUM, PN532_POSTAMBLE ]\r\n]\r\n\r\nexport const ACK = [\r\n  new Uint8Array( [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x00, 0xff, PN532_POSTAMBLE ] )\r\n]\r\n\r\nexport const NACK = [\r\n  new Uint8Array( [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0x00, PN532_POSTAMBLE ] )\r\n]\r\n\r\nexport const command = command =>\r\n  new Uint8Array( [\r\n    PN532_PREAMBLE,\r\n    PN532_STARTCODE1,\r\n    PN532_STARTCODE2,\r\n    0xff & ( command.length + 1 ),\r\n    0xff & ( ~command.length ),\r\n    PN532_HOST_TO_PN532,\r\n    ...command,\r\n    // checksum\r\n    0xff & ( -command.reduce( ( checksum, byte ) => checksum + byte, PN532_HOST_TO_PN532 ) ),\r\n    PN532_POSTAMBLE\r\n  ] )\r\n","export default function series( arr, cb, done ) {\r\n  let i = 0\r\n  let aborted = false;\r\n  ( function next( res ) {\r\n    if ( !aborted ) {\r\n      if ( typeof res !== 'undefined' || i >= arr.length ) {\r\n        done && done( res )\r\n      } else {\r\n        setImmediate( () => {\r\n          try {\r\n            cb( next, arr[ i ], i++, arr )\r\n          } catch ( err ) {\r\n            next( err )\r\n            aborted = true\r\n          }\r\n        } )\r\n      }\r\n    }\r\n  } )()\r\n}\r\n","// import Bus from 'bus'\r\n//\r\n// const preamble = [ 1, 2, 3 ]\r\n// const postamble = [ 4, ( {\r\n//   getFrame,\r\n//   getAbsoluteIndex,\r\n//   getRelativeIndex\r\n// } ) => {\r\n//   console.log( getAbsoluteIndex( 1 ), getRelativeIndex( 0 ) )\r\n//   return true\r\n// }, 6 ]\r\n//\r\n// const bus = new Bus( {\r\n//   read() {},\r\n//   write() {},\r\n//   setup() {}\r\n// } )\r\n//\r\n// bus.on( 'error', console.error )\r\n//\r\n// bus.expect( [\r\n//   preamble,\r\n//   postamble\r\n// ], console.log )\r\n//\r\n// bus.push( preamble )\r\n// bus.push( postamble )\r\n\r\n// import Bus from 'bus'\r\n// import Schedule from 'schedule'\r\nimport * as Blink from 'blink'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  ERR,\r\n  INFO,\r\n  XINFO\r\n} from 'nfc'\r\nimport Bus from 'nfc/bus'\r\nimport {\r\n  PN532_I2C_ADDRESS,\r\n  PN532_COMMAND_SAMCONFIGURATION,\r\n  PN532_SAM_NORMAL_MODE,\r\n  PN532_COMMAND_WRITEGPIO,\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  PN532_COMMAND_GETFIRMWAREVERSION,\r\n  PN532_COMMAND_WAKEUP,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_AUTH_B,\r\n  MIFARE_COMMAND_WRITE_4,\r\n  MIFARE_COMMAND_WRITE_16\r\n} from 'nfc/constants'\r\n\r\nimport {\r\n  encodeMessage,\r\n  decodeMessage,\r\n  textRecord\r\n} from 'esp-ndef'\r\n\r\n// let usbConsole = true\r\n// let consoleBus = null\r\n// let log = ''\r\n//\r\n//\r\n// function toggleConsole() {\r\n//   usbConsole = !usbConsole\r\n//   if (usbConsole) {\r\n//     consoleBus = null\r\n//     USB.removeAllListeners()\r\n//   } else {\r\n//     consoleBus = new Bus({\r\n//       setup() {\r\n//         USB.on('data', data => {\r\n//           this.parse.call(this, data)\r\n//           USB.setup()\r\n//           // USB.write(Buffer.from(['!', ...[].slice.call(data, 0)]))\r\n//         })\r\n//       },\r\n//       read() {},\r\n//       write() {}\r\n//     })\r\n//\r\n//     consoleBus.expect([Buffer.from('/on')], () => {\r\n//       Blink.once(LED1)\r\n//       USB.write(JSON.stringify(consoleBus._busState))\r\n//       // toggleConsole()\r\n//     })\r\n//\r\n//     // consoleBus.expect([Buffer.from('/off')], () => {\r\n//     //   LED1.write(1)\r\n//     //   // USB.write('/off\\r\\n')\r\n//     //   // toggleConsole()\r\n//     // })\r\n//     //\r\n//     // consoleBus.on('error', err => {\r\n//     //   Blink.once(LED1, 200)\r\n//     // })\r\n//\r\n//     consoleBus.setup()\r\n//   }\r\n//\r\n//   usbConsole ?\r\n//     USB.setConsole(false) :\r\n//     LoopbackA.setConsole(false)\r\n// }\r\n//\r\n// toggleConsole()\r\n\r\n// setWatch( toggleConsole, BTN1, {\r\n//   repeat: true,\r\n//   edge: 'rising',\r\n//   debounce: 50\r\n// } )\r\n//\r\n// Blink.start( LED2 )\r\n//\r\n// const encoded = encodeMessage( [\r\n//   textRecord( '2enhello world!' )\r\n// ] )\r\n//\r\n// import fs from 'fs'\r\n\r\n// [0, 0, 255, 0, 255, 0]\r\n// [0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0]\r\n\r\n// [0, 0, 255, 0, 255, 0, 2, 42, 1, 6, 7, 232, 0, 0, 0, ]\r\n\r\n// [1, 0, 0, 255, 0, 255, 0, 2, 42, 0, 0, 0, 0, 0, 0, 0]\r\n// [1, 0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0, 0, 0]\r\n\r\nfunction parseTypeATargetData( raw ) {\r\n  return {\r\n    targetNumber: raw[ 0 ],\r\n    baudrate: 0x00,\r\n    SENS_RES: raw.slice( 1, 3 ), // ATQA\r\n    SEL_RES: raw[ 3 ], // SAK\r\n    NFCID1: raw.slice( 4, 4 + raw[ 4 ] )\r\n  }\r\n}\r\n\r\nfunction parseTypeBTargetData( raw ) {\r\n  return {\r\n    targetNumber: raw[ 0 ],\r\n    baudrate: 0x00,\r\n    ATQB: raw.slice( 1, 13 ),\r\n    ATTRIB_RES: raw.slice( 14, 14 + raw[ 13 ] )\r\n  }\r\n}\r\n\r\nfunction parse212or424TargetData( raw ) {\r\n  const parsed = {\r\n    targetNumber: raw[ 0 ],\r\n    code: raw[ 2 ],\r\n    NFCID2t: raw.slice( 3, 11 ),\r\n    pad: raw.slice( 11, 19 )\r\n  }\r\n\r\n  if ( raw[ 1 ] == 20 ) {\r\n    parsed.SYST_CODE = raw.slice( 19, 21 )\r\n  }\r\n\r\n  return parsed\r\n}\r\n\r\nfunction parseInnovisionJewelTargetData( raw ) {\r\n  return {\r\n    targetNumber: raw[ 0 ],\r\n    baudrate: 0x00,\r\n    SENS_RES: raw.slice( 1, 3 ),\r\n    JEWELID: raw.slice( 3, 7 )\r\n  }\r\n}\r\n\r\nfunction parseDEP( targetRaw, targetData ) {\r\n  let offset = 0\r\n  if ( targetData.type == 0x00 ) {\r\n    offset = 5 + targetRaw[ 4 ]\r\n    Object.assign( targetData, parseTypeATargetData( targetRaw.slice( 0, offset ) ) )\r\n  } else if ( targetData.type == 0x03 ) {\r\n    offset = 14 + targetRaw[ 13 ]\r\n    Object.assign( targetData, parseTypeBTargetData( targetRaw.slice( 0, offset ) ) )\r\n  } else if ( targetData.type == 0x01 || targetData.type == 0x02 ) {\r\n    offset = 1 + targetRaw[ 1 ]\r\n    Object.assign( targetData, parse212or424TargetData( targetRaw.slice( 0, offset ) ), {\r\n      baudrate: targetData.type\r\n    } )\r\n  } else if ( targetData.type == 0x04 ) {\r\n    offset = 7\r\n    Object.assign( targetData, parseInnovisionJewelTargetData( targetRaw.slice( 0, offset ) ) )\r\n  } else {\r\n    throw new TypeError( 'Unknown type', targetType.type )\r\n  }\r\n  return offset\r\n}\r\n\r\nfunction setup() {\r\n  if ( this.type == 'serial' ) {\r\n    this.transport.setup( 115200 )\r\n\r\n    this.transport.on( 'data', data => {\r\n      console.log( Buffer.from( data ) )\r\n      this.push( data )\r\n    } )\r\n\r\n    this.transport.write( PN532_COMMAND_WAKEUP )\r\n\r\n    console.log( 'configuring sam' )\r\n    this.send( command( [ PN532_COMMAND_SAMCONFIGURATION, 0x01, 20, 0 ] ) )\r\n    this.expect( ACK, () => {\r\n      console.log( 'sam ACK' )\r\n    } )\r\n    this.expect( INFO, () => {\r\n      console.log( 'sam configured' )\r\n\r\n      Blink.once( LED1, 20, () => {\r\n        setTimeout( () => Blink.once( LED1, 20 ), 200 )\r\n      } )\r\n    } )\r\n  } else if ( this.type == 'i2c' ) {\r\n    this.transport.setup( {\r\n      bitrate: 400 * 1000\r\n    } )\r\n\r\n    this.on( 'drain', () => {\r\n      this._read()\r\n    } )\r\n\r\n    try {\r\n      this.send( 1 )\r\n    } catch ( err ) {\r\n      console.log( 'Handled', err.msg )\r\n      console.log( 'Continue...' )\r\n    }\r\n\r\n    this.send( command( [ PN532_COMMAND_GETFIRMWAREVERSION ] ) )\r\n\r\n    this.expect( [\r\n      ...ACK,\r\n      ...INFO\r\n    ], {\r\n      timeout: 10\r\n    }, frame => {\r\n      console.log( 'frame' )\r\n      console.log( frame )\r\n    } )\r\n  }\r\n}\r\n\r\nconst bus = new Bus( {\r\n  transport: Serial1,\r\n  type: 'serial',\r\n  setup,\r\n  read( length ) {\r\n    if ( this.type == 'i2c' ) {\r\n      while ( true ) {\r\n        if ( this.transport.readFrom( PN532_I2C_ADDRESS, 1 )[ 0 ] ) {\r\n          const chunk = this.transport.readFrom( PN532_I2C_ADDRESS, 1 + length )\r\n          this.push( chunk )\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n    } else if ( this.type == 'serial' ) {\r\n      // const chunk = this.transport.read(length)\r\n      // this.push(chunk)\r\n    }\r\n  },\r\n  write( chunk ) {\r\n    if ( this.type == 'serial' ) {\r\n      this.transport.write( chunk )\r\n    } else if ( this.type == 'i2c' ) {\r\n      this.transport.writeTo( PN532_I2C_ADDRESS, chunk )\r\n    }\r\n  },\r\n  highWaterMark: 16\r\n} )\r\n\r\nbus.on( 'error', err => {\r\n  console.error( 'BusError:', err )\r\n} )\r\n\r\nbus.setup()\r\n\r\nconst key = new Uint8Array( Array( 6 )\r\n  .fill( 0xff ) )\r\n\r\nconst NFCID3 = [ 0x01, 0xFE, 0x0F, 0xBB, 0xBA, 0xA6, 0xC9, 0x89, 0x00, 0x00 ]\r\n\r\nconst toHexString = arr => [].slice.call( arr )\r\n  .reduce( ( arr, v ) => {\r\n    const str = v.toString( 16 )\r\n      .toUpperCase()\r\n    arr.push( '0x' + ( str.length > 1 ? '' : '0' ) + str )\r\n    return arr\r\n  }, [] )\r\n  .join( ', ' )\r\n\r\nsetTimeout( () => {\r\n  Promise.resolve()\r\n    .then( () => {\r\n      ( function poll() {\r\n        const sector = 1\r\n        console.log( process.memory()\r\n          .free )\r\n        console.log( bus._busState.watching.length )\r\n        Promise.resolve()\r\n          .then( () => bus.findTargets( 2, 'A' ) )\r\n          .then( data => {\r\n            console.log( 'found target', data )\r\n            LED1.write( 1 )\r\n            return data\r\n          } )\r\n          .then( data => {\r\n            return bus.authenticate( sector * 4, data.uid, key )\r\n          } )\r\n          .then( data => {\r\n            console.log( 'auth', data )\r\n          } )\r\n          // .then( data => bus.writeBlock( 4, [ 1, 3, 6, 4 ] ) )\r\n          // .then( data => {\r\n          //   console.log( 'write op:', data )\r\n          // } )\r\n          .then( data => {\r\n            console.log( 'reading', sector, 'sector' );\r\n            return data\r\n          } )\r\n          .then( data => bus.readSector( sector ) )\r\n          .then( data => {\r\n            console.log( 'after init', data )\r\n            return data\r\n          } )\r\n          // .then( () => new Promise( ( done, fail ) => {\r\n          //   console.log( 'COMMAND InAutoPoll' )\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'ACK InAutoPoll' )\r\n          //     bus.expect( INFO, frame => {\r\n          //       let index = 7\r\n          //       // console.log( 'RESPONSE ( raw ) InAutoPoll', frame )\r\n          //       const data = {\r\n          //         count: frame[ index ],\r\n          //         targets: []\r\n          //       }\r\n          //       for ( let i = 0; i < data.count; i++ ) {\r\n          //         const type = frame[ ++index ]\r\n          //         const length = frame[ ++index ]\r\n          //\r\n          //         const targetRaw = frame.slice( ++index, index += length )\r\n          //\r\n          //         // console.log( 'targetRaw', targetRaw )\r\n          //\r\n          //         const targetData = {\r\n          //           type: type & 7,\r\n          //           br106A: ( type & 7 ) == 0,\r\n          //           br106B: ( type & 7 ) == 3,\r\n          //           br212: ( type & 7 ) == 1,\r\n          //           br424: ( type & 7 ) == 2,\r\n          //\r\n          //           mifareOrFelica: !!( type & 16 ),\r\n          //           isoCompilant: !!( type & 32 ),\r\n          //           dep: !!( type & 64 ),\r\n          //           active: !!( type & 128 )\r\n          //         }\r\n          //\r\n          //         if ( targetData.dep ) {\r\n          //           let offset = 0\r\n          //\r\n          //           if ( !targetData.active ) {\r\n          //             offset = parseDEP( targetRaw, targetData )\r\n          //           }\r\n          //\r\n          //           Object.assign( targetData, {\r\n          //             NFCID3t: targetRaw.slice( offset, offset + 10 ),\r\n          //             DIDt: frame[ offset + 10 ],\r\n          //             BSt: frame[ offset + 11 ],\r\n          //             BRt: frame[ offset + 12 ],\r\n          //             TO: frame[ offset + 13 ],\r\n          //             PPt: frame[ offset + 14 ],\r\n          //             Gt: targetRaw.slice( offset + 15, targetRaw.length )\r\n          //           } )\r\n          //         } else {\r\n          //           parseDEP( targetRaw, targetData )\r\n          //         }\r\n          //\r\n          //         data.targets.push( targetData )\r\n          //       }\r\n          //\r\n          //       console.log( 'RESPONSE InAutoPoll', data )\r\n          //\r\n          //       done( data )\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x60,\r\n          //     0xff, // poll n\r\n          //     0x01, // period = n * 150 ms\r\n          //     0x42, 0x82\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( found => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'initAsTarget ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       const data = {\r\n          //         mode: {\r\n          //           baudrate: ( frame[ 8 ] & 112 ) >> 4,\r\n          //           picc: !!( frame[ 8 ] & 15 ),\r\n          //           dep: !!( frame[ 8 ] & 4 ),\r\n          //           framingType: frame[ 8 ] & 3\r\n          //         },\r\n          //         initiatorCommand: frame.slice( 9, -2 )\r\n          //       }\r\n          //\r\n          //       console.log( 'initAsTarget RESPONSE', data )\r\n          //       console.log( 'initAsTarget COMMAND', toHexString( data.initiatorCommand ) )\r\n          //\r\n          //       done( data )\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   const c = command( [\r\n          //     0x8c,\r\n          //     1,\r\n          //\r\n          //     0x00, 0x00, //SENS_RES\r\n          //     ...NFCID3.slice( 0, 3 ), //NFCID1\r\n          //     0x40, //SEL_RES\r\n          //\r\n          //     0x01, 0xFE, 0x0F, 0xBB, 0xBA, 0xA6, 0xC9, 0x89, // POL_RES\r\n          //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n          //     0xFF, 0xFF,\r\n          //\r\n          //     ...NFCID3,\r\n          //\r\n          //     13, // length gt\r\n          //\r\n          //     0x46, 0x66, 0x6d,\r\n          //     0x01, 0x01, 0x11,\r\n          //     0x03, 0x02, 0x00, 0x13,\r\n          //     0x04, 0x01, 0x96,\r\n          //\r\n          //     0 // Tk length\r\n          //   ] )\r\n          //\r\n          //   // console.log( c )\r\n          //\r\n          //   bus.send( c )\r\n          // } ) )\r\n          // .then( data => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'TgResponseToInitiator ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'TgResponseToInitiator RESPONSE', frame )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x90,\r\n          //     0x1f,\r\n          //     0xd5, 0x01,\r\n          //     ...NFCID3,\r\n          //     0,\r\n          //     0,\r\n          //     0,\r\n          //     0x0e,\r\n          //     0x32,\r\n          //\r\n          //     0x46, 0x66, 0x6D,\r\n          //     0x01, 0x01, 0x12,\r\n          //     0x03, 0x02, 0x00, 0x13,\r\n          //     0x04, 0x01, 0x64\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( data => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'TgGetInitiatorCommand ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'TgGetInitiatorCommand RESPONSE', toHexString( frame ) )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x88\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( data => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'TgResponseToInitiator ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'TgResponseToInitiator RESPONSE', toHexString( frame ) )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x90,\r\n          //     0x06,\r\n          //     0xd4, 0x06,\r\n          //     0x00,\r\n          //     0x00, 0x00\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( () => new Promise( ( done, fail ) => {\r\n          //   const nack = setTimeout( () => {\r\n          //     bus.send( ...ACK )\r\n          //     bus.unwatch()\r\n          //\r\n          //     fail( 'no answer for tgGetTargetStatus!' )\r\n          //   }, 1000 )\r\n          //\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'tgGetTargetStatus ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //       clearTimeout( nack )\r\n          //       bus.unwatch()\r\n          //       console.log( 'tgGetTargetStatus RESPONSE:' )\r\n          //       console.log( toHexString( frame ) )\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.send( command( [ 0x8a ] ) )\r\n          // } ) )\r\n          // .then( found => {\r\n          //   return found.targets[ 0 ]\r\n          // } )\r\n          // .then( target => new Promise( ( done, fail ) => {\r\n          //   console.log( 'requesting DEP exchange...' )\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'injumpfordep ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //       const data = {\r\n          //         code: frame[ 6 ],\r\n          //         status: frame[ 7 ],\r\n          //         targetNumber: frame[ 8 ],\r\n          //         NFCID3t: frame.slice( 9, 19 ),\r\n          //         DIDt: frame[ 19 ],\r\n          //         BSt: frame[ 20 ],\r\n          //         BRt: frame[ 21 ],\r\n          //         TO: frame[ 22 ],\r\n          //         PPt: frame[ 23 ],\r\n          //         Gt: frame.slice( 24, -2 )\r\n          //       }\r\n          //\r\n          //       console.log( 'injumpfordep RESPONSE', data )\r\n          //       console.log( 'general bytes:', toHexString( data.Gt ) )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       done( data )\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   let payload = [\r\n          //     0x56,\r\n          //     target.active ? 0x00 : 0x01, // active\r\n          //     target.baudrate\r\n          //   ]\r\n          //\r\n          //   if ( !target.active ) {\r\n          //     payload = [\r\n          //       ...payload,\r\n          //       6,\r\n          //\r\n          //       ...NFCID3,\r\n          //\r\n          //       // 0x25, // len,\r\n          //       // 0xd4, 0x00, // atr req\r\n          //       // 0x00,\r\n          //       // 0x00,\r\n          //       // 0x00,\r\n          //       // 0x32,\r\n          //\r\n          //       0x46, 0x66, 0x6D,\r\n          //       0x01, 0x01, 0x12,\r\n          //       0x02, 0x02, 0x07, 0x80, // TLV: MIUX = 128 + MIU 1920\r\n          //       0x03, 0x02, 0x00, 0x03, // TLV: Services\r\n          //       0x04, 0x01, 0x64,\r\n          //       0x07, 0x01, 0x03\r\n          //     ]\r\n          //   } else {\r\n          //     payload = [\r\n          //       ...payload,\r\n          //       1,\r\n          //\r\n          //       0x01, 0x02, 0x03, 0x04, 0x05\r\n          //     ]\r\n          //   }\r\n          //\r\n          //   console.log( payload )\r\n          //\r\n          //   bus.send( command( payload ) )\r\n          // } ) )\r\n          // .then( target => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'indataexchange ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'indataexchange RESPONSE', frame )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       done( target )\r\n          //\r\n          //       // if ( frame[ 7 ] == frame[ 8 ] == frame[ 9 ] == 0x00 ) {\r\n          //       //   console.log( 'SYMM received' )\r\n          //       //   done( target )\r\n          //       // } else {\r\n          //       //   console.log( 'SYMM does not received' )\r\n          //       //   fail()\r\n          //       // }\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x40,\r\n          //     // target.targetNumber,\r\n          //     0x06, // len\r\n          //     0xd4, 0x06, // dep_req\r\n          //     0x00, // PFB\r\n          //     0x00, 0x00 // SYMM PDU\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( target => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'indataexchange ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'indataexchange RESPONSE', frame )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //\r\n          //       if ( frame[ 7 ] == frame[ 8 ] == frame[ 9 ] == 0x00 ) {\r\n          //         console.log( 'SYMM_RES received' )\r\n          //         done( target )\r\n          //       } else {\r\n          //         console.log( 'SYMM_RES does not received' )\r\n          //         fail()\r\n          //       }\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x40,\r\n          //     target.targetNumber,\r\n          //     0x06, // len\r\n          //     0xd4, 0x06, // dep_req\r\n          //     0x01, // PFB\r\n          //     0x00, 0x00 // SYMM PDU\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( target => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'indataexchange ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'indataexchange RESPONSE', frame )\r\n          //       console.log( 'CONNECT PDU' )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //\r\n          //       done( target )\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x40,\r\n          //     target.targetNumber,\r\n          //     0x1e, // len\r\n          //     0x04, 0x06, // DEP_RES\r\n          //     0x01, // info_pdu, pni 0\r\n          //     0x05, 0x20, // CONNECT PDU\r\n          //     0x06, // service name\r\n          //     0x0f, // len\r\n          //     ...[].slice.call( Buffer.from( 'urn:nfc:sn:snep' ) ),\r\n          //     0x02, 0x02, 0x07, 0x80, // TLV MIUX\r\n          //     0x05, 0x01, 0x04 // TLV RWS\r\n          //   ] ) )\r\n          // } ) )\r\n          // // .then( found => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'tgGetData ack' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'tgGetData response', frame )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x86\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( data => bus.authenticate( 4, data.uid, key ) )\r\n          // .then( data => {\r\n          //   console.log( 'auth', data )\r\n          // } )\r\n          // .then( found => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'indataexchange ack' )\r\n          //     bus.expect( INFO, frame => {\r\n          //       console.log( 'indataexchange response', frame )\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x40,\r\n          //     1\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then(data => { console.log('sector 2:', data); return data })\r\n          // .then( data => data.reduce( ( buffer, data ) => [ ...buffer, ...[].slice.call( data.chunk, 0 ) ], [] ) )\r\n          // .then( console.log )\r\n          // .then(data => { console.timeEnd('reading 2 sector'); return data })\r\n          // .then(data => bus.readBlock(4)).then(data => { console.log('block 4:', data) })\r\n          // .then(data => bus.readBlock(5)).then(data => { console.log('block 5:', data) })\r\n          // .then(data => bus.readBlock(6)).then(data => { console.log('block 6:', data) })\r\n          // .then(data => bus.readBlock(7)).then(data => { console.log('block 7:', data) })\r\n          .catch( err => {\r\n            console.error( 'Error:', err )\r\n          } )\r\n          .then( () => {\r\n            LED1.write( 0 )\r\n            LED2.write( 0 )\r\n\r\n            bus.send( ...ACK )\r\n            bus.unwatch()\r\n\r\n            setTimeout( () => {\r\n              poll()\r\n            }, 500 )\r\n          } )\r\n      } )()\r\n    } )\r\n    .catch( console.error )\r\n}, 1000 )\r\n"],"names":["Buffer","Error","EventEmitter","_listeners","_duplicateEvent","event","this","BufferState","options","assign","createNode","chunk","bufferFrom","_resetWatcher","watcher","Object","_resetActive","_busState","active","emit","_decrementActive","_nextPattern","patternIndex","list","length","nextPattern","byteIndex","currentPattern","call","slice","err","watching","buffer","nodeIndex","callback","forEach","_Bus","transport","type","_setup","setup","bind","_read","read","undefined","_this2","highWaterMark","_write","write","DEFAULT_HIGHWATERMARK","console","time","timers","label","Date","now","timeEnd","log","toFixed","error","concat","concatenated","i","push","arguments","j","Promise","race","promises","Array","TypeError","resolve","reject","promise","then","ArrayBuffer","isView","value","Proto","Uint8Array","isBuffer","from","iterable","offset","parsed","c","charCodeAt","isArray","byteLength","_list","_totalLength","totalLength","reduce","array","buf","set","target","args","obj","key","_defProp","defineProperty","prop","descriptor","e","get","defineProperties","descriptors","ON","OFF","process","env","CHIP","toUpperCase","once","led","timeout","cb","_copyChain","Extended","ProtoChain","chainPropName","ignoreExtended","prototype","isExtended","PROTOTYPE_IS_EXTENDED_PROP","hasSameChain","alreadyInChain","some","P","shouldBePushed","_extend","SUPER_CHAIN_APPLY_PROP","Super","apply","proto","Child","name","f","SUPER_CHAIN_PROTO_PROP","indexOf","loop","queue","immediatePush","tick","asyncFlush","stage","exec","splice","asyncCall","setImmediate","listener","on","removeListener","_listener","require","node","_buffer","next","unshift","count","nodes","_this","index","to","callee","firstNode","lastNode","at","configured","ticker","currentChunkIndex","watcherIndex","isEqual","byte","expected","ReferenceError","_this4","watch","unwatch","binary","Bus","check","values","sum","CHECKSUM","frame","INFO","PN532_PREAMBLE","PN532_STARTCODE1","PN532_STARTCODE2","ERR","ACK","NACK","command","PN532_HOST_TO_PN532","checksum","parseInfo","parseBlockData","data","body","code","cmd","info","parsers","done","fail","expect","parse","send","catch","makeTransaction","uid","block","PN532_COMMAND_INDATAEXCHANGE","MIFARE_COMMAND_AUTH_A","MIFARE_COMMAND_WRITE_16","sector","readBlocksArr","arr","aborted","res","readBlock","start","bus","Serial1","LED1","Blink","msg","readFrom","writeTo","fill","setTimeout","poll","memory","free","findTargets","authenticate","readSector"],"mappings":"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"}