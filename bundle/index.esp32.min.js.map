{"version":3,"file":"index.esp32.min.js","sources":["../globals/buffer.js","../lib/stream/bufferState.js","../lib/bus.js","../globals/console.js","../globals/array.js","../globals/promise.js","../lib/blink.js","../lib/nfc/index.js","../globals/object.js","../globals/event-loop.js","../lib/nfc/bus.js","../helpers/series.js","../src/index.js"],"sourcesContent":["// import Uint8Array from './Uint8Array'\n// import { toBuffer } from './utils/to'\n\n// function copy(target) {\n// \tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\n// \t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\n// \t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\n//\n// \tlet copied = 0\n//\n// \tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\n// \t\ttarget.set([ this[sourceIndex] ], targetIndex)\n//\n// \treturn copied\n// }\n//\nfunction Buffer() {\n\tthrow new Error()\n}\n\n//Buffer.from = (iterable, offset, length) => E.toUint8Array(iterable)\n\nBuffer.from = (_iterable, _offset, _length) => {\n\tlet iterable = []\n\tif(typeof _iterable == 'string') {\n    for(let c in _iterable) {\n\t\t\titerable[c] = _iterable.charCodeAt(c)\n\t\t}\n  } else if(_iterable instanceof Uint8Array || _iterable instanceof Array) {\n\t\titerable = _iterable\n\t}\n\n\tconst offset = _offset !== undefined ? _offset : 0\n\tconst length = _length !== undefined ? _length : iterable.length\n\n\treturn new Uint8Array([...[].fill(0, 0, offset), ...[].slice.call(iterable, 0), ...[].fill(0, iterable.length + offset, length)])\n}\n\nBuffer.concat = (_list, _totalLength) => {\n\tconst list = _list || [],\n\t\t\t\ttotalLength = _totalLength !== undefined ? _totalLength : list.reduce((totalLength, array) => totalLength + array.length, 0),\n\t\t\t\tbuffer = Buffer.from([], 0, totalLength)\n\n\tlist.reduce((offset, buf) => {\n\t\tbuffer.set(buf, offset)\n\t\treturn offset + buf.length\n\t}, 0)\n\n\treturn buffer\n}\n\nexport default Buffer\n","function BufferState(options = {}) {\n  Object.assign(this, {\n\t\t_buffer: [],\n\t\tlength: 0\n\t}, options)\n}\n\nBufferState.prototype = {\n  push(chunk) {\n    if(chunk.length) {\n      const node = {\n    \t\tchunk: Buffer.from(chunk),\n        encoding: 'binary',\n    \t\tnext: null\n    \t}\n\n      if(this._buffer.length) {\n        this._buffer[this._buffer.length - 1].next = node\n      }\n\n      this._buffer.push(node)\n      this.length += node.chunk.length\n    }\n\n    return this.length\n  },\n\n  unshift(chunk) {\n    const node = {\n  \t\tchunk: Buffer.from(chunk),\n      encoding: 'binary',\n  \t\tnext: null\n  \t}\n\n    if(this._buffer.length) {\n      node.next = this._buffer[0]\n    }\n\n    this._buffer.unshift(node)\n    this.length += node.chunk.length\n\n    return this.length\n  },\n\n  nodes(count) {\n    const nodes = this._buffer.splice(0, count)\n    nodes.forEach(node => this.length -= node.chunk.length)\n\n    return nodes\n  },\n\n  at(index) {\n    if(index >= this.length || index < 0) {\n      return\n    }\n\n    for(let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex ++) {\n      const chunk = this._buffer[nodeIndex].chunk\n      if(index < chunk.length) {\n        return {\n          index,\n          nodeIndex,\n          value: chunk[index]\n        }\n      }\n\n      index -= chunk.length\n    }\n  },\n\n  for(from, to, callee) {\n    const firstNode = this._buffer[from.nodeIndex]\n    for(let index = from.nodeIndex; index < firstNode.chunk.length; index ++) {\n      callee.call(this, firstNode.chunk[index])\n    }\n\n    for(let nodeIndex = 1 + from.nodeIndex; nodeIndex < to.nodeIndex; nodeIndex ++) {\n      const node = this._buffer[nodeIndex]\n      for(let index = 0; index < node.chunk.length; index ++) {\n        callee.call(this, node.chunk[index])\n      }\n    }\n\n    if(from.nodeIndex < to.nodeIndex) {\n      const lastNode = this._buffer[to.nodeIndex]\n      for(let index = 0; index <= to.index; index ++) {\n        callee.call(this, lastNode.chunk[index])\n      }\n    }\n  },\n\n  slice(length) {\n    if(length === undefined) {\n      length = this.length\n    }\n\n    if(!length) {\n      return Buffer.from([])\n    }\n\n    if(length > this.length) {\n      length = this.length\n    }\n\n    let to\n\n    if(length) {\n      to = this.at(length)\n    }\n\n    if(!to) {\n      to = {\n        index: this.length - 1,\n        nodeIndex: this._buffer.length - 1\n      }\n    }\n\n    const buffer = Buffer.from([], 0, length)\n\n    const offset = this._buffer.slice(0, to.nodeIndex).reduce((offset, node) => {\n      buffer.set(node.chunk, offset)\n      return offset + node.chunk.length\n    }, 0)\n\n    if(offset < length) {\n      const node = this._buffer[to.nodeIndex]\n\n      buffer.set(node.chunk.slice(0, length - offset), offset)\n    }\n\n    return buffer\n  },\n\n  buffer(length) {\n    if(length === undefined) {\n      length = this.length\n    }\n\n    if(!length) {\n      return Buffer.from([])\n    }\n\n    if(length > this.length) {\n      length = this.length\n    }\n\n    let to\n\n    if(length) {\n      // console.time('at')\n      to = this.at(length)\n      // console.timeEnd('at')\n    }\n\n    if(!to) {\n      to = {\n        index: this.length - 1,\n        nodeIndex: this._buffer.length - 1\n      }\n    }\n    // console.time('from')\n    const buffer = Buffer.from([], 0, length)\n    // console.timeEnd('from')\n    // console.time('offset')\n\n    // console.timeEnd('buffer')\n    const offset = this.nodes(to.nodeIndex).reduce((offset, node) => {\n      buffer.set(node.chunk, offset)\n      return offset + node.chunk.length\n    }, 0)\n    // console.timeEnd('offset')\n    if(offset < length) {\n      const node = this.nodes(1)[0]\n\n      buffer.set(node.chunk.slice(0, length - offset), offset)\n      node.chunk = node.chunk.slice(length - offset)\n\n      this.unshift(node.chunk)\n    }\n\n    return buffer\n\n    // return from.nodeIndex == to.nodeIndex\n    //   ? this._buffer[from.nodeIndex].chunk.slice(from.index, to.index)\n    //   : Buffer.concat([\n    //       this._buffer[from.nodeIndex].chunk.slice(from.index),\n    //       ...this._buffer.slice(1 + from.nodeIndex, to.nodeIndex).map(node => node.chunk),\n    //       this._buffer[to.nodeIndex].chunk.slice(0, to.index)\n    //     ])\n  }\n}\n\nexport default BufferState\n","//import { Writable } from 'stream'\nimport BufferState from 'stream/bufferState'\n//import Schedule from 'schedule'\nimport series from 'series'\n\nconst DEFAULT_HIGHWATERMARK = 64\n// const defaultWatcher = {\n//   cache: {},\n//   currentPattern: null,\n//   arrayOffset: 0,\n//   patternIndex: 0,\n//   byteIndex: 0,\n//   length: 0,\n//   active: false\n// }\n\nfunction _resetWatcher( watcher ) {\n  watcher.currentPattern = null\n  watcher.arrayOffset =\n    watcher.patternIndex =\n    watcher.byteIndex =\n    watcher.length = 0\n  watcher.active = false\n  return watcher\n\n  // return Object.assign(watcher, defaultWatcher)\n}\n\nfunction _parse() {\n  const {\n    watching,\n    frame,\n    _buffer\n  } = this._busState\n\n  if ( !watching.length ) {\n    this.emit( 'error', {\n      msg: 'Unexpected watching data',\n      data: this._busState.buffer()\n    } )\n    return\n  }\n\n  if ( this._busState.nodeIndex < 0 ) {\n    this._busState.nodeIndex = 0\n  }\n\n  for ( ; this._busState.nodeIndex < _buffer.length; this._busState.nodeIndex++ ) {\n    const {\n      chunk\n    } = _buffer[ this._busState.nodeIndex ]\n    let currentChunkIndex = currentIncomingWatcherIndex = watcherIndex = 0,\n      isEqual = isChunkCorrupted = false\n\n    for ( ; currentChunkIndex < chunk.length; currentChunkIndex++ ) {\n      if ( !this._busState.active ) {\n        this._busState.active = this._busState.watching.reduce( ( active, watcher ) => {\n          const {\n            patterns\n          } = watcher\n          try {\n            watcher.currentPattern = typeof patterns[ 0 ] == 'function' ? patterns[ 0 ]( Buffer.from( [] ) ) : patterns[ 0 ],\n              watcher.active = true\n            return active + 1\n          } catch ( err ) {\n            this.emit( 'error', err )\n            return active\n          }\n        }, 0 )\n      }\n\n      const byte = chunk[ currentChunkIndex ]\n\n      for ( watcherIndex = 0; watcherIndex < watching.length; watcherIndex++, isEqual = false ) {\n        const watcher = watching[ watcherIndex ]\n\n        if ( !watcher.active ) {\n          continue\n        }\n\n        const expected = watcher.currentPattern[ watcher.byteIndex ]\n\n        // console.log('current watching:', watcher.currentPattern)\n        // console.log('current chunk:', chunk)\n        // console.log('byte:', byte)\n        // console.log('expected:', expected)\n\n        if ( expected === undefined || expected === byte ) {\n          isEqual = true\n        } else if ( Array.isArray( expected ) ) {\n          if ( watcher.arrayOffset <= 0 && expected[ 0 ] > 0 ) {\n            watcher.arrayOffset = expected[ 0 ]\n          }\n\n          if ( --watcher.arrayOffset > 0 ) {\n            watcher.length++\n              continue\n          }\n\n          isEqual = true\n        } else if ( typeof expected == 'function' ) {\n          try {\n            isEqual = !!expected.call( this, byte, watcher.length, this._busState.slice( 1 + watcher.length ) )\n          } catch ( err ) {\n            isEqual = false\n            this.emit( 'error', err )\n          }\n        }\n\n        if ( isEqual ) {\n          watcher.length++\n\n            if ( ++watcher.byteIndex >= watcher.currentPattern.length ) {\n              if ( ++watcher.patternIndex >= watcher.patterns.length ) {\n                // console.time( 'buffer' )\n                // console.log(watcher.callback)\n                const chunk = this._busState.buffer( watcher.length )\n                // console.timeEnd( 'buffer' )\n                this._busState.nodeIndex = -1\n                try {\n                  // console.time( 'cb' )\n                  watcher.callback(\n                    chunk,\n                    // frame.splice(-watcher.length),\n                    watcher.pattern\n                  )\n                  // console.timeEnd( 'cb' )\n                } catch ( err ) {\n                  this.emit( 'error', err )\n                }\n                // this._busState.watching = []\n                // console.time( 'reset' )\n                watching.forEach( _resetWatcher )\n                this._busState.active = 0\n                // console.timeEnd( 'reset' )\n              } else {\n                // console.time('next pattern')\n                const nextPattern = watcher.patterns[ watcher.patternIndex ]\n                watcher.byteIndex = 0\n\n                try {\n                  if ( typeof nextPattern == 'function' ) {\n                    watcher.currentPattern = nextPattern.call( this, this._busState.slice( watcher.length ) )\n                  } else {\n                    watcher.currentPattern = nextPattern\n                  }\n                } catch ( err ) {\n                  _resetWatcher( watcher )\n                  this._busState.active--\n                  this.emit( 'error', err )\n                }\n                // console.timeEnd('next pattern')\n              }\n            }\n        } else {\n          _resetWatcher( watcher )\n          this._busState.active--\n\n          if ( !watching.length && this._busState.length ) {\n            this.emit( 'error', {\n              msg: 'Unparsed chunk',\n              data: this._busState.buffer() // frame.splice(0)\n            } )\n            /*\n            if(!isChunkCorrupted) {\n              isChunkCorrupted = true\n              setImmediate(() => {\n                isChunkCorrupted = false\n                this.emit('error', {\n                  msg: 'Unparsed chunk',\n                  data: frame.splice(0)\n                })\n              })\n            }*/\n          }\n        }\n\n        // console.timeEnd('isEqual')\n      }\n    }\n  }\n}\n\nfunction _Bus( options = {} ) {\n  this._setup = options.setup.bind( this )\n  this._read = options.read.bind( this )\n  this._write = options.write.bind( this )\n\n  this.options = {\n    highWaterMark: options.highWaterMark || DEFAULT_HIGHWATERMARK\n  }\n\n  this._busState = new BufferState( {\n    watching: [],\n    active: 0,\n    nodeIndex: 0,\n    configured: false,\n    ticker: false\n  } )\n}\n\n_Bus.prototype = {\n  setup() {\n    if ( this._busState.configured ) {\n      return Promise.reject( 'already configured' )\n    }\n\n    this._busState.configured = true\n    return this._setup.apply( this, arguments )\n  },\n\n  parse( chunk ) {\n    this._busState.push( chunk )\n\n    if ( !this._busState.ticker ) {\n      this._busState.ticker = true\n      setImmediate( () => {\n        this._busState.ticker = false\n        _parse.call( this )\n      } )\n    }\n    // const highWaterMark = this.options.highWaterMark,\n    //       parse = _parse.bind(this)\n    //\n    // if(chunk.length > highWaterMark) {\n    //   const chunks = []\n    //   let subchunkIndex = 0\n    //\n    //   for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\n    //     const subchunk = chunk.slice(offset, offset += highWaterMark)\n    //     chunks.push(subchunk)\n    //   }\n    //\n    //   series(chunks, (next, subchunk) => {\n    //     parse(subchunk)\n    //     next()\n    //   })\n    // }\n    // else {\n    //   parse(chunk)\n    // }\n  },\n\n  watch( patterns, cb ) {\n    const watcher = _resetWatcher( {\n      patterns,\n      callback: cb.bind( this )\n    } )\n\n    this._busState.watching.push( watcher )\n\n    return watcher\n  },\n\n  unwatch( watcher ) {\n    if ( watcher ) {\n      const index = this._busState.watching.indexOf( watcher )\n\n      if ( index >= 0 ) {\n        this._busState.watching.splice( index, 1 )\n      }\n    } else {\n      this._busState.watching.splice( 0 )\n    }\n\n    return this\n  },\n\n  /**\n    @TODO Promise interface\n  */\n\n  rx( patterns, cb ) {\n    const watcher = this.watch( patterns, cb )\n    this._read()\n    return watcher\n  },\n\n  tx( binary, options = {} ) {\n    if ( 'timeout' in options ) {\n      setTimeout( () => {\n        this._write( binary )\n      }, options.timeout )\n    } else {\n      this._write( binary )\n    }\n\n    return this\n  },\n\n  reset() {\n    this._busState.watching.splice( 0 )\n    return this\n  }\n}\n\nexport default _Bus\n","if(typeof console.time !== 'function') {\n  const timers = {}\n\n  console.time = label => {\n    timers[label] = Date.now()\n  }\n\n  console.timeEnd = label => {\n    if(label in timers) {\n      console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\n      delete timers[label]\n    }\n  }\n}\n\nif(typeof console.error !== 'function') {\n  console.error = console.log\n}\n\nexport default console\n","Array.prototype.concat = function () {\n  const concatenated = []\n\n  for(let i in this) {\n    concatenated.push(this[i])\n  }\n\n  for(let i in arguments) {\n    for(let j in arguments[i]) {\n      concatenated.push(arguments[i][j])\n    }\n  }\n\n  return concatenated\n}\n\nexport default Array\n","// var PENDING = 'pending'\n// var SEALED = 'sealed'\n// var FULFILLED = 'fulfilled'\n// var REJECTED = 'rejected'\n//\n// var NOOP = function() {}\n//\n// function invokeResolver(resolver, promise) {\n//   function resolvePromise(value) {\n//     resolve(promise, value)\n//   }\n//\n//   function rejectPromise(reason) {\n//     reject(promise, reason)\n//   }\n//\n//   try {\n//     resolver(resolvePromise, rejectPromise)\n//   } catch(e) {\n//     rejectPromise(e)\n//   }\n// }\n//\n// function invokeCallback(subscriber) {\n//   var owner = subscriber.owner\n//   var settled = owner.state_\n//   var value = owner.data_\n//   var callback = subscriber[settled]\n//   var promise = subscriber.then\n//\n//   if (typeof callback === 'function')\n//   {\n//     settled = FULFILLED\n//     try {\n//       value = callback(value)\n//     } catch(e) {\n//       reject(promise, e)\n//     }\n//   }\n//\n//   if (!handleThenable(promise, value))\n//   {\n//     if (settled === FULFILLED)\n//       resolve(promise, value)\n//\n//     if (settled === REJECTED)\n//       reject(promise, value)\n//   }\n// }\n//\n// function handleThenable(promise, value) {\n//   var resolved\n//\n//   try {\n//     if (promise === value)\n//       throw new TypeError('A promises callback cannot return that same promise.')\n//\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\n//     {\n//       var then = value.then  // then should be retrived only once\n//\n//       if (typeof then === 'function')\n//       {\n//         then.call(value, function(val){\n//           if (!resolved)\n//           {\n//             resolved = true\n//\n//             if (value !== val)\n//               resolve(promise, val)\n//             else\n//               fulfill(promise, val)\n//           }\n//         }, function(reason){\n//           if (!resolved)\n//           {\n//             resolved = true\n//\n//             reject(promise, reason)\n//           }\n//         })\n//\n//         return true\n//       }\n//     }\n//   } catch (e) {\n//     if (!resolved)\n//       reject(promise, e)\n//\n//     return true\n//   }\n//\n//   return false\n// }\n//\n// function resolve(promise, value){\n//   if (promise === value || !handleThenable(promise, value))\n//     fulfill(promise, value)\n// }\n//\n// function publish(promise) {\n//   var callbacks = promise.then_\n//   promise.then_ = undefined\n//\n//   for (var i = 0 i < callbacks.length i++) {\n//     invokeCallback(callbacks[i])\n//   }\n// }\n//\n// function fulfill(promise, value){\n//   if (promise.state_ === PENDING)\n//   {\n//     promise.state_ = SEALED\n//     promise.data_ = value\n//\n//     setImmediate(() => {\n//       promise.state_ = FULFILLED\n//       publish(promise)\n//     })\n//   }\n// }\n//\n// function reject(promise, reason){\n//   if (promise.state_ === PENDING)\n//   {\n//     promise.state_ = SEALED\n//     promise.data_ = reason\n//\n//     setImmediate(() => {\n//       promise.state_ = REJECTED\n//       publish(promise)\n//     })\n//   }\n// }\n//\n// function Promise(resolver) {\n//   if (typeof resolver !== 'function')\n//     throw new TypeError('Promise constructor takes a function argument')\n//\n//   if (this instanceof Promise === false)\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\n//\n//   this.then_ = []\n//\n//   invokeResolver(resolver, this)\n// }\n//\n// Promise.prototype = {\n//   constructor: Promise,\n//\n//   state_: PENDING,\n//   then_: null,\n//   data_: undefined,\n//\n//   then: function(onFulfillment, onRejection){\n//     var subscriber = {\n//       owner: this,\n//       then: new this.constructor(NOOP),\n//       fulfilled: onFulfillment,\n//       rejected: onRejection\n//     }\n//\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\n//     {\n//       // already resolved, call callback async\n//       setImmediate(() => {invokeCallback(subscriber)})\n//     }\n//     else\n//     {\n//       // subscribe\n//       this.then_.push(subscriber)\n//     }\n//\n//     return subscriber.then\n//   },\n//\n//   'catch': function(onRejection) {\n//     return this.then(null, onRejection)\n//   }\n// }\n\n// Promise.all = function(promises) {\n//   if (!(promises instanceof Array)) {\n//     throw new TypeError('You must pass an array to Promise.all().')\n//   }\n//\n//   return new Promise((resolve, reject) => {\n//     var results = []\n//     var remaining = 0\n//\n//     function resolver(index) {\n//       remaining++\n//       return function(value) {\n//         results[index] = value\n//         if (!--remaining) {\n//           resolve(results)\n//         }\n//       }\n//     }\n//\n//     for (var i = 0, promise; i < promises.length; i++) {\n//       promise = promises[i]\n//\n//       if (promise && typeof promise.then === 'function') {\n//         promise.then(resolver(i), reject)\n//       }\n//       else {\n//         results[i] = promise\n//       }\n//     }\n//\n//     if (!remaining) {\n//       resolve(results)\n//     }\n//   })\n// }\n\nPromise.race = function(promises){\n  var Class = this\n\n  if (!(promises instanceof Array))\n    throw new TypeError('You must pass an array to Promise.race().')\n\n  return new Class((resolve, reject) => {\n    for (var i = 0, promise; i < promises.length; i++)\n    {\n      promise = promises[i]\n\n      if (promise && typeof promise.then === 'function')\n        promise.then(resolve, reject)\n      else\n        resolve(promise)\n    }\n  })\n}\n\n// Promise.resolve = function(value) {\n//   var Class = this\n//\n//   if (value && typeof value === 'object' && value.constructor === Class)\n//     return value\n//\n//   return new Class(function(resolve){\n//     resolve(value)\n//   })\n// }\n//\n// Promise.reject = function(reason){\n//   var Class = this\n//\n//   return new Class(function(resolve, reject){\n//     reject(reason)\n//   })\n// }\n//\n\nexport default Promise\n","let defaultLed\nlet ON = 1,\n  OFF = 0\n\nif (process.env.CHIP.toUpperCase() == 'ESP32') {\n  defaultLed = D5\n  ON = 0\n  OFF = 1\n} else {\n  defaultLed = LED2\n}\n\nlet status = false\nconst defaultTimeout = 20\n\nexport const once = (led, timeout, cb) => {\n  // D5.write(0)\n  // console.log('on')\n  led.write(ON)\n  setTimeout(() => {\n    // D5.write(1)\n    // console.log('off')\n    led.write(OFF)\n    cb && cb()\n  }, timeout || defaultTimeout)\n}\n\nexport const start = led => {\n  if (!led) {\n    led = defaultLed\n  }\n  if (!status) {\n    status = true\n\n    once(led, defaultTimeout, function cb() {\n      if (status) {\n        setTimeout(() => {\n          once(led, defaultTimeout, cb)\n        }, 1000 - defaultTimeout)\n      }\n    })\n  }\n}\n\nexport const stop = () => {\n  if (status) {\n    status = false\n  }\n}\n","import {\n  PN532_PREAMBLE,\n  PN532_STARTCODE1,\n  PN532_STARTCODE2,\n  PN532_HOST_TO_PN532,\n  PN532_PN532_TO_HOST,\n  PN532_POSTAMBLE\n} from './constants'\n\nconst check = values => !(0xff & (-values.reduce((sum, value) => sum + value, 0)))\n\nconst LCS_std = (byte, length, frame) => check(frame.slice(-2))\n\nconst LCS_ext = (byte, length, frame) => check([frame[5] * 256 + frame[6], frame[7]])\n\nconst CHECKSUM_std = (byte, length, frame) => check(frame.slice(5))\n\nconst CHECKSUM_ext = (byte, length, frame) => check(frame.slice(8))\n\nconst BODY_std = frame => {\n  return [[frame[3] - 1]]\n}\n\nconst BODY_ext = frame => {\n  return [[256 * frame[5] + frame[6]]]\n}\n\nexport const INFO = [\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, undefined, LCS_std, PN532_PN532_TO_HOST],\n  BODY_std,\n  [CHECKSUM_std, PN532_POSTAMBLE]\n]\n\nexport const XINFO = [\n  [PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0xff, undefined, undefined, LCS_ext, PN532_PN532_TO_HOST],\n  BODY_ext,\n  [CHECKSUM_ext, PN532_POSTAMBLE]\n]\n\nexport const ERR = [\n  [PN532_PREAMBLE, PN532_STARTCODE1 , PN532_STARTCODE2, 0x01, 0xff, undefined, CHECKSUM_std, PN532_POSTAMBLE]\n]\n\nexport const ACK = [\n  new Uint8ClampedArray([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x00, 0xff, PN532_POSTAMBLE])\n]\n\nexport const NACK = [\n  new Uint8ClampedArray([PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0x00, PN532_POSTAMBLE])\n]\n\nexport const command = command =>\n  new Uint8ClampedArray([\n    PN532_PREAMBLE,\n    PN532_STARTCODE1,\n    PN532_STARTCODE2,\n    0xff & (command.length + 1),\n    0xff & (~command.length),\n    PN532_HOST_TO_PN532,\n    ...command,\n    // checksum\n    0xff & (-command.reduce((checksum, byte) => checksum + byte, PN532_HOST_TO_PN532)),\n    PN532_POSTAMBLE\n  ])\n","Object.assign = (target, ...args) => {\n  for(let i in args) {\n    const obj = args[i]\n    if(obj instanceof Object) {\n      for(let key in obj) {\n        target[key] = obj[key]\n      }\n    }\n  }\n\n  return target\n}\n\nexport default Object\n","const PUSH_TO_QUEUE_IMMEDIATE = 0,\n      PUSH_AT_NEXT_STAGE = 1,\n      loop = [\n        // nextTick\n        { queue: [], immediatePush: true, tick: false },\n        // immediate\n        { queue: [], immediatePush: true, tick: false },\n        // timeout\n        { queue: [], immediatePush: false, tick: false }\n      ]\n\nlet tick = false,\n    timers = {}\n\nconst asyncFlush = () => {\n  for (let stage in loop) {\n    if(loop[stage].queue.length) {\n      if(loop[stage].immediatePush) {\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\n          loop[stage].queue[exec]()\n        }\n        loop[stage].queue.splice(0)\n      } else {\n        const queue = loop[stage].queue.splice(0)\n        for (let exec = 0; exec < queue.length; exec ++) {\n          queue[exec]()\n        }\n      }\n    }\n\n    loop[stage].tick = tick = false\n  }\n}\n\nconst asyncCall = stage => cb => {\n  loop[stage].queue.push(cb)\n\n  if (!tick && !loop[stage].tick) {\n    loop[stage].tick = tick = true\n\n    setTimeout(asyncFlush)\n  }\n}\n\nconst nextTick = asyncCall(/* .nextTick */0)\n\nconst setImmediate = asyncCall(/* .immediate */1)\n\nconst timeoutCall = asyncCall(/* .timeeout */2)\n\nexport const _setTimeout = (cb, timeout) => {\n  // let index = 0\n  // while(timers[index]) {\n  //   index++\n  // }\n  // timers[index] = setTimeout(() => {\n  //   if(timers[index]) {\n  //     delete timers[index]\n  //     timeoutCall(cb)\n  //   }\n  // }, timeout)\n  //\n  // return index\n\n  return setTimeout(() => {\n    timeoutCall(cb)\n  }, timeout)\n}\n\nexport const _setInterval = (cb, timeout) => {\n  return (function setTimer() {\n    return _setTimeout(() => {\n      setTimer()\n      cb()\n    }, timeout)\n  })()\n}\n\nexport {\n  nextTick,\n  setImmediate,\n  _setTimeout as setTimeout,\n  _setInterval as setInterval\n}\n","import Bus from 'bus'\nimport {\n  command,\n  ACK,\n  NACK,\n  ERR,\n  INFO\n} from './'\nimport {\n  PN532_COMMAND_INLISTPASSIVETARGET,\n  PN532_COMMAND_INDATAEXCHANGE,\n  MIFARE_COMMAND_AUTH_A,\n  MIFARE_COMMAND_READ_16,\n  MIFARE_COMMAND_WRITE_16,\n  PN532_BRTY_ISO14443A,\n  PN532_BRTY_ISO14443B\n} from './constants'\n\nimport series from 'series'\n\nconst sliceAck = chunk => chunk.slice( ACK.length )\n\nconst parseInfo = chunk => {\n  return {\n    raw: chunk,\n    code: chunk[ 6 ],\n    body: Buffer.from( chunk.slice( 7, 5 + chunk[ 3 ] ) )\n  }\n}\n\nconst parseBlockData = data => {\n  if ( data.body.length == 1 ) {\n    throw {\n      cmd: data.code,\n      errCode: data.body[ 0 ]\n    }\n  } else {\n    return {\n      chunk: data.body.slice( 1 )\n    }\n  }\n}\n\nconst NfcBus = {\n  makeTransaction( cmd, info, parsers ) {\n    return new Promise( ( done, fail ) => {\n        // Don't be silly again - info frame refers to index from beginning, i.e. to ACK\n        // this.rx([...ACK, ...info], chunk => done((parsers || [sliceAck, parseInfo]).reduce((data, parse) => parse(data), chunk)))\n        this.rx( ACK, () => {\n          this.rx( info, chunk => done( ( parsers || [ parseInfo ] )\n            .reduce( ( data, parse ) => parse( data ), chunk ) ) )\n        } )\n\n        this.rx( NACK, fail )\n        this.rx( ERR, fail )\n\n        this.tx( command( cmd ) )\n      } )\n      .catch( err => {\n        this.unwatch()\n        throw err\n      } )\n      .then( data => {\n        this.unwatch()\n        return data\n      } )\n  },\n\n  findTargets( count, type ) {\n    if ( type == 'A' ) {\n      type = PN532_BRTY_ISO14443A\n    } else if ( type == 'B' ) {\n      type = PN532_BRTY_ISO14443B\n    } else {\n      throw new Error( 'Unknown ISO14443 type:', type )\n    }\n\n    return this.makeTransaction( [\n      PN532_COMMAND_INLISTPASSIVETARGET,\n      count,\n      type\n    ], INFO, [ chunk => {\n      const body = chunk.slice( 7, 5 + chunk[ 3 ] )\n      const uid = body.slice( 6, 6 + body[ 5 ] )\n      return {\n        code: chunk[ 6 ],\n        body,\n        count: body[ 0 ],\n        atqa: body.slice( 2, 4 ), // SENS_RES\n        sak: body[ 4 ],\n        uid\n      }\n    } ] )\n  },\n\n  authenticate( block, uid, key ) {\n    return this.makeTransaction( [\n      PN532_COMMAND_INDATAEXCHANGE,\n      1,\n      MIFARE_COMMAND_AUTH_A,\n      block,\n      ...[].slice.call( key ),\n      ...[].slice.call( uid )\n    ], INFO )\n  },\n\n  readBlock( block ) {\n    return this.makeTransaction( [\n      PN532_COMMAND_INDATAEXCHANGE,\n      1,\n      MIFARE_COMMAND_READ_16,\n      block\n    ], INFO, [ parseInfo, parseBlockData ] )\n  },\n\n  writeBlock( block, chunk ) {\n    return this.makeTransaction( [\n      PN532_COMMAND_INDATAEXCHANGE,\n      1,\n      MIFARE_COMMAND_WRITE_16,\n      block,\n      ...[].slice.call( chunk )\n    ], INFO )\n  },\n\n  readSector( sector ) {\n    return new Promise( ( done, fail ) => {\n      const readBlocksArr = []\n      for ( let block = sector * 4; block < sector * 4 + 3; block++ ) {\n        readBlocksArr.push( block )\n      }\n\n      series( readBlocksArr, ( next, block, index ) => {\n        this.readBlock( block )\n          .then( data => {\n            readBlocksArr[ index ] = data\n            next()\n          } )\n          .catch( err => {\n            console.log( '!!!' )\n            next( err )\n          } )\n      }, err => err ? fail( err ) : done( readBlocksArr ) )\n    } )\n  },\n\n  writeSector( start, chunk ) {\n\n  }\n}\n\nexport default options => Object.assign( new Bus( options ), NfcBus )","export default function series( arr, cb, done ) {\n  let i = 0\n  let aborted = false;\n  ( function next( res ) {\n    if ( !aborted ) {\n      if ( typeof res !== 'undefined' || i >= arr.length ) {\n        done && done( res )\n      } else {\n        setImmediate( () => {\n          try {\n            cb( next, arr[ i ], i++, arr )\n          } catch ( err ) {\n            next( err )\n            aborted = true\n          }\n        } )\n      }\n    }\n  } )()\n}\n","// import Bus from 'bus'\n// import Schedule from 'schedule'\nimport * as Blink from 'blink'\nimport {\n  command,\n  ACK,\n  NACK,\n  INFO,\n  XINFO\n} from 'nfc'\nimport Bus from 'nfc/bus'\nimport {\n  PN532_COMMAND_SAMCONFIGURATION,\n  PN532_SAM_NORMAL_MODE,\n  PN532_COMMAND_WRITEGPIO,\n  PN532_COMMAND_INLISTPASSIVETARGET,\n  PN532_COMMAND_INDATAEXCHANGE,\n  PN532_COMMAND_GETFIRMWAREVERSION,\n  PN532_COMMAND_WAKEUP,\n  MIFARE_COMMAND_READ_16,\n  MIFARE_COMMAND_AUTH_A,\n  MIFARE_COMMAND_AUTH_B,\n  MIFARE_COMMAND_WRITE_4,\n  MIFARE_COMMAND_WRITE_16\n} from 'nfc/constants'\n\nimport {\n  encodeMessage,\n  decodeMessage,\n  textRecord\n} from 'esp-ndef'\n\nlet usbConsole = true\nlet consoleBus = null\nlet log = ''\n\nconst USB = Serial1\nconst LED1 = D5\n\n// function toggleConsole() {\n//   usbConsole = !usbConsole\n//   if (usbConsole) {\n//     consoleBus = null\n//     USB.removeAllListeners()\n//   } else {\n//     consoleBus = new Bus({\n//       setup() {\n//         USB.on('data', data => {\n//           this.parse.call(this, data)\n//           USB.setup()\n//           // USB.write(Buffer.from(['!', ...[].slice.call(data, 0)]))\n//         })\n//       },\n//       read() {},\n//       write() {}\n//     })\n//\n//     consoleBus.rx([Buffer.from('/on')], () => {\n//       Blink.once(LED1)\n//       USB.write(JSON.stringify(consoleBus._busState))\n//       // toggleConsole()\n//     })\n//\n//     // consoleBus.rx([Buffer.from('/off')], () => {\n//     //   LED1.write(1)\n//     //   // USB.write('/off\\r\\n')\n//     //   // toggleConsole()\n//     // })\n//     //\n//     // consoleBus.on('error', err => {\n//     //   Blink.once(LED1, 200)\n//     // })\n//\n//     consoleBus.setup()\n//   }\n//\n//   usbConsole ?\n//     USB.setConsole(false) :\n//     LoopbackA.setConsole(false)\n// }\n//\n// toggleConsole()\n\n// setWatch( toggleConsole, BTN1, {\n//   repeat: true,\n//   edge: 'rising',\n//   debounce: 50\n// } )\n//\n// Blink.start( LED2 )\n//\n// const encoded = encodeMessage( [\n//   textRecord( '2enhello world!' )\n// ] )\n//\nconst wakeup = command( [ PN532_COMMAND_WAKEUP ] )\nconst sam = command( [ PN532_COMMAND_SAMCONFIGURATION, PN532_SAM_NORMAL_MODE, 20, 0 ] )\n\nconst serial = Serial2\nUSB.setConsole(true)\n\n\nfunction setup( done ) {\n  serial.setup( 115200 )\n\n  serial.write( wakeup )\n  serial.write( sam )\n\n  setTimeout( () => {\n    serial.read()\n    serial.on( 'data', data => bus.parse( data ) )\n    Blink.once( LED1, 20, () => setTimeout( () => Blink.once( LED1, 20 ), 200 ) )\n  }, 50 )\n}\n\nconst bus = new Bus( {\n  setup,\n  read() {},\n  write( chunk ) {\n    serial.write( chunk )\n  },\n  highWaterMark: 64\n} )\n\nbus.on( 'error', err => {\n  console.error( 'BusError:', err )\n} )\n\nbus.setup()\n\nconst key = new Uint8Array( [].fill( 0xff, 0, 6 ) )\n\nsetTimeout( () => {\n  ( function poll() {\n    // console.log(process.memory().free)\n    // console.log(bus._busState.watching.length)\n    Promise.resolve()\n      .then( () => bus.findTargets( 1, 'A' ) ) // .then(data => { console.log('found card', data.uid); return data })\n      .then( data => {\n        LED1.write( true )\n        return data\n      } )\n      // .then(data => bus.authenticate(4, data.uid, key).then(data => { console.log('auth op 4:', data) }).then(() => bus.authenticate(3, data.uid, key).then(data => { console.log('auth op:', data) })))\n      .then( data => bus.authenticate( 1 * 4, data.uid, key ) ) // .then(data => { console.log('auth', data) })\n      // .then(data => bus.writeBlock(4, [1, 3, 6, 4])).then(data => { console.log('write op:', data) })\n      // .then(data => { console.time('reading 2 sector'); return data })\n      .then( data => bus.readSector( 1 ) )\n      .then( data => {\n        LED1.write( false )\n        return data\n      } ) // .then(data => { console.log('sector 2:', data); return data })\n      .then( data => data.reduce( ( buffer, data ) => [ ...buffer, ...[].slice.call( data.chunk, 0 ) ], [] ) )\n      .then( console.log )\n      // .then(data => { console.timeEnd('reading 2 sector'); return data })\n      // .then(data => bus.readBlock(4)).then(data => { console.log('block 4:', data) })\n      // .then(data => bus.readBlock(5)).then(data => { console.log('block 5:', data) })\n      // .then(data => bus.readBlock(6)).then(data => { console.log('block 6:', data) })\n      // .then(data => bus.readBlock(7)).then(data => { console.log('block 7:', data) })\n      .catch( err => {\n        LED1.write( false )\n        console.error( 'Error:', err )\n      } )\n      .then( () => {\n        setTimeout( () => {\n          poll()\n        }, 500 )\n      } )\n  } )()\n}, 1000 )\n"],"names":["Buffer","Error","BufferState","options","assign","this","_resetWatcher","watcher","currentPattern","arrayOffset","patternIndex","byteIndex","length","active","_Bus","_setup","setup","bind","_read","read","_write","write","highWaterMark","DEFAULT_HIGHWATERMARK","_busState","console","time","timers","label","Date","now","timeEnd","log","toFixed","error","concat","concatenated","i","push","arguments","j","Promise","race","promises","Array","TypeError","resolve","reject","promise","then","ON","OFF","process","env","CHIP","toUpperCase","once","led","timeout","cb","check","values","reduce","sum","value","CHECKSUM_std","byte","frame","slice","INFO","PN532_PREAMBLE","PN532_STARTCODE1","PN532_STARTCODE2","undefined","ERR","ACK","Uint8ClampedArray","NACK","command","PN532_HOST_TO_PN532","checksum","Object","target","args","obj","key","from","_iterable","_offset","_length","iterable","c","charCodeAt","Uint8Array","offset","fill","call","_list","_totalLength","list","totalLength","array","buffer","buf","set","loop","queue","immediatePush","tick","asyncFlush","stage","exec","splice","asyncCall","setImmediate","prototype","chunk","node","_buffer","next","unshift","count","nodes","forEach","_this","index","nodeIndex","to","callee","firstNode","lastNode","at","configured","apply","ticker","watching","currentChunkIndex","currentIncomingWatcherIndex","watcherIndex","isEqual","isChunkCorrupted","patterns","err","emit","expected","isArray","callback","pattern","nextPattern","indexOf","watch","binary","parseInfo","parseBlockData","data","body","code","NfcBus","cmd","info","parsers","done","fail","rx","parse","tx","catch","unwatch","type","makeTransaction","uid","block","PN532_COMMAND_INDATAEXCHANGE","MIFARE_COMMAND_AUTH_A","MIFARE_COMMAND_WRITE_16","sector","readBlocksArr","arr","aborted","res","readBlock","start","USB","Serial1","LED1","D5","wakeup","sam","serial","Serial2","setConsole","bus","Bus","on","setTimeout","Blink","poll","findTargets","authenticate","readSector"],"mappings":"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"}