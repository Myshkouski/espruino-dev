{"version":3,"file":"index.esp32.min.js","sources":["../globals/buffer.js","../lib/events.js","../lib/stream/bufferState.js","../lib/bus.js","../globals/console.js","../globals/object.js","../globals/namedFunction.js","../globals/extend/index.js","../globals/array.js","../globals/promise.js","../globals/event-loop.js","../src/index.js"],"sourcesContent":["// import Uint8Array from './Uint8Array'\r\n// import { toBuffer } from './utils/to'\r\n\r\n// function copy(target) {\r\n// \tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\r\n// \t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\r\n// \t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\r\n//\r\n// \tlet copied = 0\r\n//\r\n// \tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\r\n// \t\ttarget.set([ this[sourceIndex] ], targetIndex)\r\n//\r\n// \treturn copied\r\n// }\r\n//\r\nfunction Buffer() {\r\n  throw new Error()\r\n}\r\n\r\n//Buffer.from = (iterable, offset, length) => E.toUint8Array(iterable)\r\n\r\nBuffer.from = (iterable, offset, length) => {\r\n  if (typeof iterable == 'string') {\r\n    const parsed = []\r\n\r\n    for (let c in iterable) {\r\n      parsed[c] = iterable.charCodeAt(c)\r\n    }\r\n\r\n    return new Uint8Array(parsed)\r\n  } else if (iterable instanceof ArrayBuffer) {\r\n    return new Uint8Array(iterable.slice(offset !== undefined ? offset : 0, offset + (length !== undefined ? length : iterable.length)))\r\n  } else if (iterable instanceof Array || iterable instanceof Uint8Array) {\r\n    return new Uint8Array(iterable)\r\n  } else {\r\n    throw new TypeError('Cannot create buffer from', typeof iterable)\r\n  }\r\n}\r\n\r\nBuffer.concat = (_list, _totalLength) => {\r\n  const list = _list || [],\r\n    totalLength = _totalLength !== undefined ? _totalLength : list.reduce((totalLength, array) => totalLength + array.length, 0),\r\n    buffer = Buffer.from([], 0, totalLength)\r\n\r\n  list.reduce((offset, buf) => {\r\n    buffer.set(buf, offset)\r\n    return offset + buf.length\r\n  }, 0)\r\n\r\n  return buffer\r\n}\r\n\r\nexport default Buffer\r\n","function EventEmitter() {\r\n  this._listeners = {}\r\n}\r\n\r\n//_named('EventEmitter', EventEmitter)\r\n\r\nfunction _duplicateEvent(event) {\r\n  if(event) {\r\n    if(`#${ event }` in this) {\r\n      this._listeners[event] = this[`#${ event }`]\r\n    } else {\r\n      delete this._listeners[event]\r\n    }\r\n  }\r\n}\r\n\r\nEventEmitter.prototype = {\r\n  on(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n\r\n    // this._listeners[event]\r\n    //   ? this._listeners[event].push(listener)\r\n    //   : this._listeners[event] = [listener]\r\n\r\n    return this\r\n  },\r\n\r\n  removeListener(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n    // if(!event) {\r\n    //   this._listeners = {}\r\n    // } else {\r\n    //   if(listener && this._listeners[event]) {\r\n    //     const index = this._listeners[event].indexOf(listener)\r\n    //\r\n    //     if(~index) {\r\n    //       this._listeners[event].splice(index, 1)\r\n    //     }\r\n    //   }\r\n    //\r\n    //   if(!listener || !this._listeners[event]) {\r\n    //     delete this._listeners[event]\r\n    //   }\r\n    // }\r\n    return this\r\n  },\r\n\r\n  once(event, listener) {\r\n    function once() {\r\n      this.removeListener(event, _listener)\r\n      return listener.apply(this, arguments)\r\n    }\r\n\r\n    return this.on(event, once)\r\n  }\r\n}\r\n\r\nexport default EventEmitter\r\n","function BufferState(options = {}) {\r\n  Object.assign(this, {\r\n\t\t_buffer: [],\r\n\t\tlength: 0\r\n\t}, options)\r\n}\r\n\r\nBufferState.prototype = {\r\n  push(chunk) {\r\n    if(chunk.length) {\r\n      const node = {\r\n    \t\tchunk: Buffer.from(chunk),\r\n        encoding: 'binary',\r\n    \t\tnext: null\r\n    \t}\r\n\r\n      if(this._buffer.length) {\r\n        this._buffer[this._buffer.length - 1].next = node\r\n      }\r\n\r\n      this._buffer.push(node)\r\n      this.length += node.chunk.length\r\n    }\r\n\r\n    return this.length\r\n  },\r\n\r\n  unshift(chunk) {\r\n    const node = {\r\n  \t\tchunk: Buffer.from(chunk),\r\n      encoding: 'binary',\r\n  \t\tnext: null\r\n  \t}\r\n\r\n    if(this._buffer.length) {\r\n      node.next = this._buffer[0]\r\n    }\r\n\r\n    this._buffer.unshift(node)\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  nodes(count) {\r\n    const nodes = this._buffer.splice(0, count)\r\n    nodes.forEach(node => this.length -= node.chunk.length)\r\n\r\n    return nodes\r\n  },\r\n\r\n  at(index) {\r\n    if(index >= this.length || index < 0) {\r\n      return\r\n    }\r\n\r\n    for(let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex ++) {\r\n      const chunk = this._buffer[nodeIndex].chunk\r\n      if(index < chunk.length) {\r\n        return {\r\n          index,\r\n          nodeIndex,\r\n          value: chunk[index]\r\n        }\r\n      }\r\n\r\n      index -= chunk.length\r\n    }\r\n  },\r\n\r\n  for(from, to, callee) {\r\n    const firstNode = this._buffer[from.nodeIndex]\r\n    for(let index = from.nodeIndex; index < firstNode.chunk.length; index ++) {\r\n      callee.call(this, firstNode.chunk[index])\r\n    }\r\n\r\n    for(let nodeIndex = 1 + from.nodeIndex; nodeIndex < to.nodeIndex; nodeIndex ++) {\r\n      const node = this._buffer[nodeIndex]\r\n      for(let index = 0; index < node.chunk.length; index ++) {\r\n        callee.call(this, node.chunk[index])\r\n      }\r\n    }\r\n\r\n    if(from.nodeIndex < to.nodeIndex) {\r\n      const lastNode = this._buffer[to.nodeIndex]\r\n      for(let index = 0; index <= to.index; index ++) {\r\n        callee.call(this, lastNode.chunk[index])\r\n      }\r\n    }\r\n  },\r\n\r\n  slice(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      to = this.at(length)\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n\r\n    const buffer = Buffer.from(Array(length))\r\n\r\n    const offset = this._buffer.slice(0, to.nodeIndex).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset + node.chunk.length\r\n    }, 0)\r\n\r\n    if(offset < length) {\r\n      const node = this._buffer[to.nodeIndex]\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n    }\r\n\r\n    return buffer\r\n  },\r\n\r\n  buffer(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      // console.time('at')\r\n      to = this.at(length)\r\n      // console.timeEnd('at')\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n    // console.time('from')\r\n    const buffer = Buffer.from(Array(length))\r\n    // console.timeEnd('from')\r\n    // console.time('offset')\r\n\r\n    // console.timeEnd('buffer')\r\n\r\n    const offset = this.nodes(1 + to.nodeIndex).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset + node.chunk.length\r\n    }, 0)\r\n    // console.timeEnd('offset')\r\n    if(offset < length) {\r\n      const node = this.nodes(1)[0]\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n      node.chunk = node.chunk.slice(length - offset)\r\n\r\n      this.unshift(node.chunk)\r\n    }\r\n\r\n    return buffer\r\n\r\n    // return from.nodeIndex == to.nodeIndex\r\n    //   ? this._buffer[from.nodeIndex].chunk.slice(from.index, to.index)\r\n    //   : Buffer.concat([\r\n    //       this._buffer[from.nodeIndex].chunk.slice(from.index),\r\n    //       ...this._buffer.slice(1 + from.nodeIndex, to.nodeIndex).map(node => node.chunk),\r\n    //       this._buffer[to.nodeIndex].chunk.slice(0, to.index)\r\n    //     ])\r\n  }\r\n}\r\n\r\nexport default BufferState\r\n","import EventEmitter from 'events'\r\nimport BufferState from 'stream/bufferState'\r\n//import Schedule from 'schedule'\r\nimport series from 'series'\r\n\r\nconst DEFAULT_HIGHWATERMARK = 64\r\n\r\nfunction _resetWatcher(watcher) {\r\n  watcher.currentPattern = null\r\n  watcher.arrayOffset =\r\n    watcher.patternIndex =\r\n    watcher.byteIndex =\r\n    watcher.index = 0\r\n  watcher.active = false\r\n\r\n  return watcher\r\n\r\n  // return Object.assign(watcher, defaultWatcher)\r\n}\r\n\r\n// function Watcher(bus) {\r\n//   _resetWatcher(this)\r\n//\r\n//\r\n// }\r\n//\r\n// Watcher.prototype = {\r\n//   rx() {\r\n//\r\n//   }\r\n// }\r\n\r\nfunction decrementActive() {\r\n  if(!--this._busState.active) {\r\n    this.emit('inactive')\r\n  }\r\n}\r\n\r\nfunction _push() {\r\n  const {\r\n    watching,\r\n    frame,\r\n    _buffer\r\n  } = this._busState\r\n\r\n  if (!watching.length) {\r\n    this.emit('error', {\r\n      msg: 'Unexpected watching data',\r\n      data: this._busState.buffer()\r\n    })\r\n    return\r\n  }\r\n\r\n  if (this._busState.nodeIndex < 0) {\r\n    this._busState.nodeIndex = 0\r\n  }\r\n\r\n  for (; this._busState.nodeIndex < _buffer.length; this._busState.nodeIndex++) {\r\n    const {\r\n      chunk\r\n    } = _buffer[this._busState.nodeIndex]\r\n    let currentChunkIndex = 0\r\n    let currentIncomingWatcherIndex = 0\r\n    let watcherIndex = 0\r\n    let isEqual = false\r\n    let isChunkCorrupted = false\r\n\r\n    for (; currentChunkIndex < chunk.length; currentChunkIndex++) {\r\n      let isChunkCorrupted = false\r\n      if (!this._busState.active) {\r\n        this._busState.active = this._busState.watching.reduce((active, watcher) => {\r\n          const {\r\n            patterns\r\n          } = watcher\r\n          try {\r\n            watcher.currentPattern = typeof patterns[0] == 'function' ? patterns[0](Buffer.from([])) : patterns[0],\r\n              watcher.active = true\r\n            return active + 1\r\n          } catch (err) {\r\n            this.emit('error', err)\r\n            return active\r\n          }\r\n        }, 0)\r\n      }\r\n\r\n      const byte = chunk[currentChunkIndex]\r\n\r\n      for (watcherIndex = 0; watcherIndex < watching.length; watcherIndex++, isEqual = false) {\r\n        const watcher = watching[watcherIndex]\r\n\r\n        if (!watcher.active) {\r\n          continue\r\n        }\r\n\r\n        const expected = watcher.currentPattern[watcher.byteIndex]\r\n\r\n        // console.log('current watching:', watcher.currentPattern)\r\n        // console.log('current chunk:', chunk)\r\n        // console.log('byte:', byte)\r\n        // console.log('expected:', expected)\r\n\r\n        if (expected === undefined || expected === byte) {\r\n          isEqual = true\r\n        } else if (Array.isArray(expected)) {\r\n          if (watcher.arrayOffset <= 0 && expected[0] > 0) {\r\n            watcher.arrayOffset = expected[0]\r\n          }\r\n\r\n          if (--watcher.arrayOffset > 0) {\r\n            watcher.index++\r\n              continue\r\n          }\r\n\r\n          isEqual = true\r\n        } else if (typeof expected == 'function') {\r\n          try {\r\n            isEqual = !!expected.call(this, byte, watcher.index /*i.e. index*/, this._busState.slice(watcher.index /*i.e. actual length*/))\r\n          } catch (err) {\r\n            isEqual = false\r\n            this.emit('error', err)\r\n          }\r\n        }\r\n\r\n        if (isEqual) {\r\n          watcher.index++\r\n\r\n          if (++watcher.byteIndex >= watcher.currentPattern.length) {\r\n            if (++watcher.patternIndex >= watcher.patterns.length) {\r\n              // console.time( 'buffer' )\r\n              // console.log(watcher.callback)\r\n              const chunk = this._busState.buffer(watcher.index)\r\n              // console.timeEnd( 'buffer' )\r\n              this._busState.nodeIndex = -1\r\n              try {\r\n                // console.time( 'cb' )\r\n                watcher.callback(\r\n                  chunk,\r\n                  // frame.splice(-watcher.index),\r\n                  watcher.pattern\r\n                )\r\n                // console.timeEnd( 'cb' )\r\n              } catch (err) {\r\n                this.emit('error', err)\r\n              }\r\n              // this._busState.watching = []\r\n              // console.time( 'reset' )\r\n              watching.forEach(watcher => {\r\n                _resetWatcher(watcher)\r\n                decrementActive.call(this)\r\n              })\r\n              // console.timeEnd( 'reset' )\r\n            } else {\r\n              // console.time('next pattern')\r\n              const nextPattern = watcher.patterns[watcher.patternIndex]\r\n              watcher.byteIndex = 0\r\n\r\n              try {\r\n                if (typeof nextPattern == 'function') {\r\n                  watcher.currentPattern = nextPattern.call(this, this._busState.slice(watcher.index))\r\n                } else {\r\n                  watcher.currentPattern = nextPattern\r\n                }\r\n              } catch (err) {\r\n                _resetWatcher(watcher)\r\n                decrementActive.call(this)\r\n                this.emit('error', err)\r\n              }\r\n              // console.timeEnd('next pattern')\r\n            }\r\n          }\r\n        } else {\r\n          _resetWatcher(watcher)\r\n          decrementActive.call(this)\r\n\r\n          if (!this._busState.active) {\r\n              this.emit('error', {\r\n                msg: 'Unparsed chunk',\r\n                data: this._busState.buffer() // frame.splice(0)\r\n              })\r\n            //\r\n            // if(!isChunkCorrupted) {\r\n            //   isChunkCorrupted = true\r\n            //   setImmediate(() => {\r\n            //     isChunkCorrupted = false\r\n            //     this.emit('error', {\r\n            //       msg: 'Unparsed chunk',\r\n            //       data: frame.splice(0)\r\n            //     })\r\n            //   })\r\n            // }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if(this._busState.active) {\r\n    this.emit('drain')\r\n  }\r\n}\r\n\r\nfunction _Bus(options = {}) {\r\n  this.transport = options.transport\r\n  this.type = options.type\r\n  this._setup = options.setup.bind(this)\r\n  this._read = length => options.read.call(this, length === undefined ? length : this.options.highWaterMark)\r\n  this._write = options.write.bind(this)\r\n\r\n  this.options = {\r\n    highWaterMark: options.highWaterMark || DEFAULT_HIGHWATERMARK\r\n  }\r\n\r\n  this._busState = new BufferState({\r\n    watching: [],\r\n    active: 0,\r\n    nodeIndex: 0,\r\n    configured: false,\r\n    ticker: false\r\n  })\r\n}\r\n\r\n_Bus.prototype = {\r\n  setup() {\r\n    if (this._busState.configured) {\r\n      return Promise.reject('already configured')\r\n    }\r\n\r\n    this._busState.configured = true\r\n    return this._setup.apply(this, arguments)\r\n  },\r\n\r\n  push(chunk) {\r\n    if (chunk.length) {\r\n      this._busState.push(chunk)\r\n\r\n      if (!this._busState.ticker) {\r\n        this._busState.ticker = true\r\n        setImmediate(() => {\r\n          this._busState.ticker = false\r\n          _push.call(this)\r\n        })\r\n      }\r\n    }\r\n    // const highWaterMark = this.options.highWaterMark,\r\n    //       parse = _parse.bind(this)\r\n    //\r\n    // if(chunk.length > highWaterMark) {\r\n    //   const chunks = []\r\n    //   let subchunkIndex = 0\r\n    //\r\n    //   for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\r\n    //     const subchunk = chunk.slice(offset, offset += highWaterMark)\r\n    //     chunks.push(subchunk)\r\n    //   }\r\n    //\r\n    //   series(chunks, (next, subchunk) => {\r\n    //     parse(subchunk)\r\n    //     next()\r\n    //   })\r\n    // }\r\n    // else {\r\n    //   parse(chunk)\r\n    // }\r\n  },\r\n\r\n  watch(patterns, cb) {\r\n    const watcher = _resetWatcher({\r\n      patterns,\r\n      callback: cb.bind(this)\r\n    })\r\n\r\n    this._busState.watching.push(watcher)\r\n\r\n    return watcher\r\n  },\r\n\r\n  unwatch(watcher) {\r\n    if (watcher) {\r\n      const index = this._busState.watching.indexOf(watcher)\r\n\r\n      if (index >= 0) {\r\n        this._busState.watching.splice(index, 1)\r\n      }\r\n    } else {\r\n      this._busState.watching.splice(0)\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  /**\r\n    @TODO Promise interface\r\n  */\r\n\r\n  rx(patterns, ...args) {\r\n    let cb, options = {}\r\n\r\n    if (typeof args[0] == 'function') {\r\n      cb = args[0]\r\n    } else if (typeof args[1] == 'function') {\r\n      cb = args[1]\r\n      Object.assign(options, args[0])\r\n    } else {\r\n      throw new ReferenceError('Callback is not provided')\r\n    }\r\n\r\n    let watcher\r\n    const setWatcher = () => {\r\n      watcher = this.watch(patterns, cb)\r\n      this._read(this.options.highWaterMark)\r\n    }\r\n\r\n    if ('timeout' in options) {\r\n      setTimeout(setWatcher, options.timeout)\r\n    } else {\r\n      setWatcher()\r\n    }\r\n\r\n    return watcher\r\n  },\r\n\r\n  tx(binary, options = {}) {\r\n    if ('timeout' in options) {\r\n      setTimeout(() => {\r\n        this._write(binary)\r\n      }, options.timeout)\r\n    } else {\r\n      this._write(binary)\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  reset() {\r\n    this._busState.watching.splice(0)\r\n    return this\r\n  }\r\n}\r\n\r\nconst Bus = _extend({\r\n  super: [_Bus, EventEmitter],\r\n  apply: [_Bus, EventEmitter]\r\n})\r\n\r\nexport default Bus\r\n","if(typeof console.time !== 'function') {\r\n  const timers = {}\r\n\r\n  console.time = label => {\r\n    timers[label] = Date.now()\r\n  }\r\n\r\n  console.timeEnd = label => {\r\n    if(label in timers) {\r\n      console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\r\n      delete timers[label]\r\n    }\r\n  }\r\n}\r\n\r\nif(typeof console.error !== 'function') {\r\n  console.error = console.log\r\n}\r\n\r\nexport default console\r\n","Object.assign = (target, ...args) => {\r\n  for(let i in args) {\r\n    const obj = args[i]\r\n    if(obj instanceof Object) {\r\n      for(let key in obj) {\r\n        target[key] = obj[key]\r\n      }\r\n    }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\nconst _defProp = Object.defineProperty\r\n\r\nObject.defineProperty = (obj, prop, descriptor) => {\r\n  try {\r\n    return _defProp(obj, prop, descriptor)\r\n  } catch(e) {\r\n    if(desc.get) {\r\n      obj.value = descriptor.get()\r\n    }\r\n    else if(desc.value) {\r\n      obj[prop] = descriptor.value\r\n    }\r\n\r\n    return obj\r\n  }\r\n}\r\n\r\nObject.defineProperties = (obj, descriptors) => {\r\n  for(let prop in descriptors) {\r\n    const descriptor = descriptors[prop]\r\n    Object.defineProperty(obj, prop, descriptor)\r\n  }\r\n  return obj\r\n}\r\n\r\n\r\nexport default Object\r\n","export default (name, f) => Object.defineProperty(f, 'name', { value: name })\r\n","import {\r\n  SUPER_CHAIN_PROTO_PROP,\r\n  SUPER_CHAIN_APPLY_PROP,\r\n  PROTOTYPE_IS_EXTENDED_PROP\r\n} from './props'\r\n\r\nexport const _copyChain = (Extended, ProtoChain, chainPropName, ignoreExtended) => {\r\n  //if chain on [Extended] has not been created yet\r\n  if(!Extended.prototype[chainPropName]) {\r\n    Object.defineProperty(Extended.prototype, chainPropName, { value: [] })\r\n  }\r\n\r\n  ProtoChain.forEach(Proto => {\r\n    //console.log(!!Proto.prototype['__extended__'], Proto)\r\n    //if [Proto] has been '__extended__' and has same-named proto chain, copy the Proto chain to Extended chain\r\n    const isExtended = !!Proto.prototype[PROTOTYPE_IS_EXTENDED_PROP],\r\n          hasSameChain = !!Proto.prototype[chainPropName]\r\n\r\n    const alreadyInChain = Extended.prototype[chainPropName].some(P => P === Proto),\r\n          shouldBePushed = (!isExtended || !ignoreExtended) && !alreadyInChain,\r\n          shouldCopyChain = isExtended && hasSameChain\r\n\r\n    if(shouldCopyChain)\r\n      Proto.prototype[chainPropName].forEach(Proto => {\r\n        //avoid pushing twice\r\n        if(!Extended.prototype[chainPropName].some(P => P === Proto) ) {\r\n          //console.log('pushed', Proto)\r\n          Extended.prototype[chainPropName].push(Proto)\r\n        }\r\n      })\r\n\r\n    if(shouldBePushed) {\r\n      Extended.prototype[chainPropName].push(Proto)\r\n    }\r\n  })\r\n\r\n  //console.log(Extended.prototype[chainPropName])\r\n}\r\n\r\nexport const _extend = (options = {}) => {\r\n  if(!options.apply)\r\n    options.apply = []\r\n  if(!options.super)\r\n    options.super = []\r\n  if(!options.static)\r\n    options.static = []\r\n\r\n  const Child = options.super[0]\r\n\r\n  if(!options.name)\r\n    options.name = Child.name\r\n\r\n  function Extended() {\r\n    Extended.prototype[SUPER_CHAIN_APPLY_PROP].forEach(Super => {\r\n      if(Super !== Extended) {\r\n        Super.apply(this, arguments)\r\n      }\r\n    })\r\n  }\r\n\r\n  _named(options.name, Extended)\r\n\r\n  for(let i in options.static) {\r\n    for(let prop in options.static[i]) {\r\n      if('prototype' != prop) {\r\n        Object.defineProperty(Extended, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  Object.defineProperty(Extended, 'prototype', { value: {} })\r\n  Object.defineProperty(Extended.prototype, 'constructor', { value: Child })\r\n  Object.defineProperty(Extended.prototype, PROTOTYPE_IS_EXTENDED_PROP, { value: true })\r\n\r\n  for(let i in options.super) {\r\n    function Proto() {}\r\n    Proto.prototype = options.super[i].prototype\r\n    const proto = new Proto()\r\n\r\n    for(let prop in proto) {\r\n      if(['constructor', PROTOTYPE_IS_EXTENDED_PROP, SUPER_CHAIN_PROTO_PROP, SUPER_CHAIN_APPLY_PROP].indexOf(prop) < 0) {\r\n        Object.defineProperty(Extended.prototype, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  _copyChain(Extended, options.super, SUPER_CHAIN_PROTO_PROP, false)\r\n  _copyChain(Extended, options.apply, SUPER_CHAIN_APPLY_PROP, true)\r\n\r\n  return Extended\r\n}\r\n\r\nexport const extend = (...args) => _extend({ super: args.slice(1), apply: args })\r\n","Array.prototype.concat = function () {\r\n  const concatenated = []\r\n\r\n  for(let i in this) {\r\n    concatenated.push(this[i])\r\n  }\r\n\r\n  for(let i in arguments) {\r\n    for(let j in arguments[i]) {\r\n      concatenated.push(arguments[i][j])\r\n    }\r\n  }\r\n\r\n  return concatenated\r\n}\r\n\r\nexport default Array\r\n","// var PENDING = 'pending'\r\n// var SEALED = 'sealed'\r\n// var FULFILLED = 'fulfilled'\r\n// var REJECTED = 'rejected'\r\n//\r\n// var NOOP = function() {}\r\n//\r\n// function invokeResolver(resolver, promise) {\r\n//   function resolvePromise(value) {\r\n//     resolve(promise, value)\r\n//   }\r\n//\r\n//   function rejectPromise(reason) {\r\n//     reject(promise, reason)\r\n//   }\r\n//\r\n//   try {\r\n//     resolver(resolvePromise, rejectPromise)\r\n//   } catch(e) {\r\n//     rejectPromise(e)\r\n//   }\r\n// }\r\n//\r\n// function invokeCallback(subscriber) {\r\n//   var owner = subscriber.owner\r\n//   var settled = owner.state_\r\n//   var value = owner.data_\r\n//   var callback = subscriber[settled]\r\n//   var promise = subscriber.then\r\n//\r\n//   if (typeof callback === 'function')\r\n//   {\r\n//     settled = FULFILLED\r\n//     try {\r\n//       value = callback(value)\r\n//     } catch(e) {\r\n//       reject(promise, e)\r\n//     }\r\n//   }\r\n//\r\n//   if (!handleThenable(promise, value))\r\n//   {\r\n//     if (settled === FULFILLED)\r\n//       resolve(promise, value)\r\n//\r\n//     if (settled === REJECTED)\r\n//       reject(promise, value)\r\n//   }\r\n// }\r\n//\r\n// function handleThenable(promise, value) {\r\n//   var resolved\r\n//\r\n//   try {\r\n//     if (promise === value)\r\n//       throw new TypeError('A promises callback cannot return that same promise.')\r\n//\r\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\r\n//     {\r\n//       var then = value.then  // then should be retrived only once\r\n//\r\n//       if (typeof then === 'function')\r\n//       {\r\n//         then.call(value, function(val){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             if (value !== val)\r\n//               resolve(promise, val)\r\n//             else\r\n//               fulfill(promise, val)\r\n//           }\r\n//         }, function(reason){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             reject(promise, reason)\r\n//           }\r\n//         })\r\n//\r\n//         return true\r\n//       }\r\n//     }\r\n//   } catch (e) {\r\n//     if (!resolved)\r\n//       reject(promise, e)\r\n//\r\n//     return true\r\n//   }\r\n//\r\n//   return false\r\n// }\r\n//\r\n// function resolve(promise, value){\r\n//   if (promise === value || !handleThenable(promise, value))\r\n//     fulfill(promise, value)\r\n// }\r\n//\r\n// function publish(promise) {\r\n//   var callbacks = promise.then_\r\n//   promise.then_ = undefined\r\n//\r\n//   for (var i = 0 i < callbacks.length i++) {\r\n//     invokeCallback(callbacks[i])\r\n//   }\r\n// }\r\n//\r\n// function fulfill(promise, value){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = value\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = FULFILLED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function reject(promise, reason){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = reason\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = REJECTED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function Promise(resolver) {\r\n//   if (typeof resolver !== 'function')\r\n//     throw new TypeError('Promise constructor takes a function argument')\r\n//\r\n//   if (this instanceof Promise === false)\r\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\r\n//\r\n//   this.then_ = []\r\n//\r\n//   invokeResolver(resolver, this)\r\n// }\r\n//\r\n// Promise.prototype = {\r\n//   constructor: Promise,\r\n//\r\n//   state_: PENDING,\r\n//   then_: null,\r\n//   data_: undefined,\r\n//\r\n//   then: function(onFulfillment, onRejection){\r\n//     var subscriber = {\r\n//       owner: this,\r\n//       then: new this.constructor(NOOP),\r\n//       fulfilled: onFulfillment,\r\n//       rejected: onRejection\r\n//     }\r\n//\r\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\r\n//     {\r\n//       // already resolved, call callback async\r\n//       setImmediate(() => {invokeCallback(subscriber)})\r\n//     }\r\n//     else\r\n//     {\r\n//       // subscribe\r\n//       this.then_.push(subscriber)\r\n//     }\r\n//\r\n//     return subscriber.then\r\n//   },\r\n//\r\n//   'catch': function(onRejection) {\r\n//     return this.then(null, onRejection)\r\n//   }\r\n// }\r\n\r\n// Promise.all = function(promises) {\r\n//   if (!(promises instanceof Array)) {\r\n//     throw new TypeError('You must pass an array to Promise.all().')\r\n//   }\r\n//\r\n//   return new Promise((resolve, reject) => {\r\n//     var results = []\r\n//     var remaining = 0\r\n//\r\n//     function resolver(index) {\r\n//       remaining++\r\n//       return function(value) {\r\n//         results[index] = value\r\n//         if (!--remaining) {\r\n//           resolve(results)\r\n//         }\r\n//       }\r\n//     }\r\n//\r\n//     for (var i = 0, promise; i < promises.length; i++) {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function') {\r\n//         promise.then(resolver(i), reject)\r\n//       }\r\n//       else {\r\n//         results[i] = promise\r\n//       }\r\n//     }\r\n//\r\n//     if (!remaining) {\r\n//       resolve(results)\r\n//     }\r\n//   })\r\n// }\r\n\r\nPromise.race = function(promises){\r\n  var Class = this\r\n\r\n  if (!(promises instanceof Array))\r\n    throw new TypeError('You must pass an array to Promise.race().')\r\n\r\n  return new Class((resolve, reject) => {\r\n    for (var i = 0, promise; i < promises.length; i++)\r\n    {\r\n      promise = promises[i]\r\n\r\n      if (promise && typeof promise.then === 'function')\r\n        promise.then(resolve, reject)\r\n      else\r\n        resolve(promise)\r\n    }\r\n  })\r\n}\r\n\r\n// Promise.resolve = function(value) {\r\n//   var Class = this\r\n//\r\n//   if (value && typeof value === 'object' && value.constructor === Class)\r\n//     return value\r\n//\r\n//   return new Class(function(resolve){\r\n//     resolve(value)\r\n//   })\r\n// }\r\n//\r\n// Promise.reject = function(reason){\r\n//   var Class = this\r\n//\r\n//   return new Class(function(resolve, reject){\r\n//     reject(reason)\r\n//   })\r\n// }\r\n//\r\n\r\nexport default Promise\r\n","const loop = [\r\n  // immediate\r\n  { queue: [], immediatePush: true, tick: false },\r\n  // timeout\r\n  { queue: [], immediatePush: false, tick: false }\r\n]\r\n\r\nlet tick = false\r\n\r\nconst asyncFlush = () => {\r\n  for (let stage in loop) {\r\n    if(loop[stage].queue.length) {\r\n      if(loop[stage].immediatePush) {\r\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\r\n          loop[stage].queue[exec]()\r\n        }\r\n        loop[stage].queue.splice(0)\r\n      } else {\r\n        const queue = loop[stage].queue.splice(0)\r\n        for (let exec = 0; exec < queue.length; exec ++) {\r\n          queue[exec]()\r\n        }\r\n      }\r\n    }\r\n\r\n    loop[stage].tick = tick = false\r\n  }\r\n}\r\n\r\nconst asyncCall = stage => cb => {\r\n  loop[stage].queue.push(cb)\r\n\r\n  if (!tick && !loop[stage].tick) {\r\n    loop[stage].tick = tick = true\r\n\r\n    setTimeout(asyncFlush)\r\n  }\r\n}\r\n\r\nconst setImmediate = asyncCall(/* .immediate */0)\r\n\r\nconst timeoutCall = asyncCall(/* .timeeout */1)\r\n\r\nexport const _setTimeout = (cb, timeout) => setTimeout(() => { timeoutCall(cb) }, timeout)\r\n\r\nexport const _setInterval = (cb, timeout) => (function setTimer() {\r\n  return _setTimeout(() => {\r\n    setTimer()\r\n    cb()\r\n  }, timeout)\r\n})()\r\n\r\nexport {\r\n  setImmediate,\r\n  _setTimeout as setTimeout,\r\n  _setInterval as setInterval\r\n}\r\n","import Bus from 'bus'\r\n\r\nconst preamble = [1, 2, 3]\r\nconst postamble = [4, (...args) => {\r\n  console.log(args)\r\n  return true\r\n}, 6]\r\n\r\nconst bus = new Bus({ read() {}, write() {}, setup() {} })\r\n\r\nbus.on('error', console.error)\r\n\r\nbus.rx([\r\n  preamble,\r\n  postamble\r\n], console.log)\r\n\r\nbus.push(preamble)\r\n\r\n// // import Bus from 'bus'\r\n// // import Schedule from 'schedule'\r\n// import * as Blink from 'blink'\r\n// import {\r\n//   command,\r\n//   ACK,\r\n//   NACK,\r\n//   INFO,\r\n//   XINFO\r\n// } from 'nfc'\r\n// import Bus from 'nfc/bus'\r\n// import {\r\n//   PN532_I2C_ADDRESS,\r\n//   PN532_COMMAND_SAMCONFIGURATION,\r\n//   PN532_SAM_NORMAL_MODE,\r\n//   PN532_COMMAND_WRITEGPIO,\r\n//   PN532_COMMAND_INLISTPASSIVETARGET,\r\n//   PN532_COMMAND_INDATAEXCHANGE,\r\n//   PN532_COMMAND_GETFIRMWAREVERSION,\r\n//   PN532_COMMAND_WAKEUP,\r\n//   MIFARE_COMMAND_READ_16,\r\n//   MIFARE_COMMAND_AUTH_A,\r\n//   MIFARE_COMMAND_AUTH_B,\r\n//   MIFARE_COMMAND_WRITE_4,\r\n//   MIFARE_COMMAND_WRITE_16\r\n// } from 'nfc/constants'\r\n//\r\n// import {\r\n//   encodeMessage,\r\n//   decodeMessage,\r\n//   textRecord\r\n// } from 'esp-ndef'\r\n//\r\n// // let usbConsole = true\r\n// // let consoleBus = null\r\n// // let log = ''\r\n// //\r\n// //\r\n// // function toggleConsole() {\r\n// //   usbConsole = !usbConsole\r\n// //   if (usbConsole) {\r\n// //     consoleBus = null\r\n// //     USB.removeAllListeners()\r\n// //   } else {\r\n// //     consoleBus = new Bus({\r\n// //       setup() {\r\n// //         USB.on('data', data => {\r\n// //           this.parse.call(this, data)\r\n// //           USB.setup()\r\n// //           // USB.write(Buffer.from(['!', ...[].slice.call(data, 0)]))\r\n// //         })\r\n// //       },\r\n// //       read() {},\r\n// //       write() {}\r\n// //     })\r\n// //\r\n// //     consoleBus.rx([Buffer.from('/on')], () => {\r\n// //       Blink.once(LED1)\r\n// //       USB.write(JSON.stringify(consoleBus._busState))\r\n// //       // toggleConsole()\r\n// //     })\r\n// //\r\n// //     // consoleBus.rx([Buffer.from('/off')], () => {\r\n// //     //   LED1.write(1)\r\n// //     //   // USB.write('/off\\r\\n')\r\n// //     //   // toggleConsole()\r\n// //     // })\r\n// //     //\r\n// //     // consoleBus.on('error', err => {\r\n// //     //   Blink.once(LED1, 200)\r\n// //     // })\r\n// //\r\n// //     consoleBus.setup()\r\n// //   }\r\n// //\r\n// //   usbConsole ?\r\n// //     USB.setConsole(false) :\r\n// //     LoopbackA.setConsole(false)\r\n// // }\r\n// //\r\n// // toggleConsole()\r\n//\r\n// // setWatch( toggleConsole, BTN1, {\r\n// //   repeat: true,\r\n// //   edge: 'rising',\r\n// //   debounce: 50\r\n// // } )\r\n// //\r\n// // Blink.start( LED2 )\r\n// //\r\n// // const encoded = encodeMessage( [\r\n// //   textRecord( '2enhello world!' )\r\n// // ] )\r\n// //\r\n// // import fs from 'fs'\r\n//\r\n// const wakeup = command([PN532_COMMAND_WAKEUP])\r\n// const sam = command([PN532_COMMAND_SAMCONFIGURATION, PN532_SAM_NORMAL_MODE, 20, 0])\r\n//\r\n// // [0, 0, 255, 0, 255, 0]\r\n// // [0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0]\r\n//\r\n// // [0, 0, 255, 0, 255, 0, 2, 42, 1, 6, 7, 232, 0, 0, 0, ]\r\n//\r\n// // [1, 0, 0, 255, 0, 255, 0, 2, 42, 0, 0, 0, 0, 0, 0, 0]\r\n// // [1, 0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0, 0, 0]\r\n//\r\n// function setup() {\r\n//   if(this.type == 'serial') {\r\n//     this.transport.setup(115200)\r\n//\r\n//     this.transport.write(wakeup)\r\n//     this.transport.write(sam)\r\n//\r\n//     setTimeout(() => {\r\n//       this.transport.on('data', data => this.push(data))\r\n//       console.log('Bus has been set up')\r\n//       Blink.once(LED1, 20, () => {\r\n//         setTimeout(() => Blink.once(LED1, 20), 200)\r\n//       })\r\n//\r\n//       this.rx([\r\n//         ...ACK,\r\n//         ...INFO\r\n//       ], frame => {\r\n//         console.log('frame')\r\n//         console.log(frame)\r\n//       })\r\n//\r\n//       this.tx(command([PN532_COMMAND_GETFIRMWAREVERSION]))\r\n//     }, 500)\r\n//   } else if (this.type == 'i2c') {\r\n//     this.transport.setup({ bitrate: 400*1000 })\r\n//\r\n//     this.on('drain', () => {\r\n//       this._read()\r\n//     })\r\n//\r\n//     try {\r\n//       this.tx(1)\r\n//     } catch(err) {\r\n//       console.log('Handled', err.msg)\r\n//       console.log('Continue...')\r\n//     }\r\n//\r\n//     this.tx(command([PN532_COMMAND_GETFIRMWAREVERSION]))\r\n//\r\n//     this.rx([\r\n//       ...ACK,\r\n//       ...INFO\r\n//     ], { timeout: 10 }, frame => {\r\n//       console.log('frame')\r\n//       console.log(frame)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// const bus = new Bus({\r\n//   transport: Serial1,\r\n//   type: 'serial',\r\n//   setup,\r\n//   read(length) {\r\n//     if(this.type == 'i2c') {\r\n//       while(true) {\r\n//         if(this.transport.readFrom(PN532_I2C_ADDRESS, 1)[0]) {\r\n//           const chunk = this.transport.readFrom(PN532_I2C_ADDRESS, 1 + length)\r\n//           this.push(chunk)\r\n//         } else {\r\n//           break\r\n//         }\r\n//       }\r\n//     } else if(this.type == 'serial') {\r\n//       // const chunk = this.transport.read(length)\r\n//       // this.push(chunk)\r\n//     }\r\n//   },\r\n//   write(chunk) {\r\n//     if(this.type == 'serial') {\r\n//       this.transport.write(chunk)\r\n//     } else if(this.type == 'i2c') {\r\n//       this.transport.writeTo(PN532_I2C_ADDRESS, chunk)\r\n//     }\r\n//   },\r\n//   highWaterMark: 16\r\n// })\r\n//\r\n// bus.on('error', err => {\r\n//   console.error('BusError:', err)\r\n// })\r\n//\r\n// bus.setup()\r\n//\r\n// // const key = new Uint8  Array(Array(6).fill(0xff))\r\n//\r\n// // console.log(key)\r\n//\r\n//\r\n// // setTimeout(() => {\r\n// //   (function poll() {\r\n// //     // console.log(process.memory().free)\r\n// //     // console.log(bus._busState.watching.length)\r\n// //     Promise.resolve()\r\n// //       .then(() => bus.findTargets(1, 'A')) // .then(data => { console.log('found card', data.uid); return data })\r\n// //       .then(data => {\r\n// //         LED1.write(0)\r\n// //         return data\r\n// //       })\r\n// //       // .then(data => bus.authenticate(4, data.uid, key).then(data => { console.log('auth op 4:', data) }).then(() => bus.authenticate(3, data.uid, key).then(data => { console.log('auth op:', data) })))\r\n// //       .then(data => bus.authenticate(1 * 4, data.uid, key)) // .then(data => { console.log('auth', data) })\r\n// //       // .then(data => bus.writeBlock(4, [1, 3, 6, 4])).then(data => { console.log('write op:', data) })\r\n// //       // .then(data => { console.time('reading 2 sector'); return data })\r\n// //       .then(data => bus.readSector(1))\r\n// //       .then(data => {\r\n// //         LED1.write(1)\r\n// //         return data\r\n// //       }) // .then(data => { console.log('sector 2:', data); return data })\r\n// //       .then(data => data.reduce((buffer, data) => [...buffer, ...[].slice.call(data.chunk, 0)], []))\r\n// //       .then(console.log)\r\n// //       // .then(data => { console.timeEnd('reading 2 sector'); return data })\r\n// //       // .then(data => bus.readBlock(4)).then(data => { console.log('block 4:', data) })\r\n// //       // .then(data => bus.readBlock(5)).then(data => { console.log('block 5:', data) })\r\n// //       // .then(data => bus.readBlock(6)).then(data => { console.log('block 6:', data) })\r\n// //       // .then(data => bus.readBlock(7)).then(data => { console.log('block 7:', data) })\r\n// //       .catch(err => {\r\n// //         LED1.write(1)\r\n// //         console.error('Error:', err)\r\n// //       })\r\n// //       .then(() => {\r\n// //         setTimeout(() => {\r\n// //           poll()\r\n// //         }, 500)\r\n// //       })\r\n// //   })()\r\n// // }, 1000)\r\n"],"names":["Buffer","Error","EventEmitter","_listeners","_duplicateEvent","event","this","BufferState","options","assign","_resetWatcher","watcher","currentPattern","arrayOffset","patternIndex","byteIndex","index","active","decrementActive","_busState","emit","_Bus","transport","type","_setup","setup","bind","_read","read","call","undefined","length","_this2","highWaterMark","_write","write","DEFAULT_HIGHWATERMARK","console","time","timers","label","Date","now","timeEnd","log","toFixed","error","Object","target","args","i","obj","key","_defProp","defineProperty","prop","descriptor","e","desc","get","value","defineProperties","descriptors","_copyChain","Extended","ProtoChain","chainPropName","ignoreExtended","prototype","forEach","isExtended","Proto","PROTOTYPE_IS_EXTENDED_PROP","hasSameChain","alreadyInChain","some","P","shouldBePushed","push","concat","concatenated","arguments","j","Promise","race","promises","Array","TypeError","resolve","reject","promise","then","from","iterable","offset","parsed","c","charCodeAt","Uint8Array","ArrayBuffer","slice","_list","_totalLength","list","totalLength","reduce","array","buffer","buf","set","loop","queue","immediatePush","tick","asyncFlush","stage","exec","splice","asyncCall","cb","setImmediate","listener","on","removeListener","_listener","apply","chunk","node","_buffer","next","unshift","count","nodes","_this","nodeIndex","to","callee","firstNode","lastNode","at","configured","ticker","watching","frame","currentChunkIndex","watcherIndex","isEqual","patterns","err","byte","expected","isArray","callback","pattern","nextPattern","indexOf","ReferenceError","setWatcher","_this4","watch","timeout","binary","preamble","postamble","bus","SUPER_CHAIN_APPLY_PROP","Super","super","static","Child","name","f","proto","SUPER_CHAIN_PROTO_PROP","_extend","rx"],"mappings":"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"}