{"version":3,"file":"index.esp32.min.js","sources":["../globals/buffer.js","../lib/events.js","../lib/stream/bufferState.js","../lib/bus.js","../globals/console.js","../lib/blink.js","../lib/nfc/index.js","../globals/object.js","../globals/array.js","../globals/promise.js","../globals/def.js","../globals/extend/index.js","../globals/event-loop.js","../globals/namedFunc.js","../lib/nfc/bus.js","../helpers/series.js","../src/index.js"],"sourcesContent":["// import Uint8Array from './Uint8Array'\r\n// import { toBuffer } from './utils/to'\r\n\r\n// function copy(target) {\r\n// \tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\r\n// \t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\r\n// \t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\r\n//\r\n// \tlet copied = 0\r\n//\r\n// \tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\r\n// \t\ttarget.set([ this[sourceIndex] ], targetIndex)\r\n//\r\n// \treturn copied\r\n// }\r\n//\r\nfunction Buffer() {\r\n  throw new Error()\r\n}\r\n\r\n//Buffer.from = (iterable, offset, length) => E.toUint8Array(iterable)\r\n\r\nBuffer.from = (iterable, offset, length) => {\r\n  if (typeof iterable == 'string') {\r\n    const parsed = []\r\n\r\n    for (let c in iterable) {\r\n      parsed[c] = iterable.charCodeAt(c)\r\n    }\r\n\r\n    return new Uint8Array(parsed)\r\n  } else if (iterable instanceof ArrayBuffer) {\r\n    return new Uint8Array(iterable.slice(offset !== undefined ? offset : 0, offset + (length !== undefined ? length : iterable.length)))\r\n  } else if (iterable instanceof Array || iterable instanceof Uint8Array) {\r\n    return new Uint8Array(iterable)\r\n  } else {\r\n    throw new TypeError('Cannot create buffer from', typeof iterable)\r\n  }\r\n}\r\n\r\nBuffer.concat = (_list, _totalLength) => {\r\n  const list = _list || [],\r\n    totalLength = _totalLength !== undefined ? _totalLength : list.reduce((totalLength, array) => totalLength + array.length, 0),\r\n    buffer = Buffer.from([], 0, totalLength)\r\n\r\n  list.reduce((offset, buf) => {\r\n    buffer.set(buf, offset)\r\n    return offset + buf.length\r\n  }, 0)\r\n\r\n  return buffer\r\n}\r\n\r\nexport default Buffer\r\n","function EventEmitter() {\r\n  this._listeners = {}\r\n}\r\n\r\n//_named('EventEmitter', EventEmitter)\r\n\r\nfunction _duplicateEvent(event) {\r\n  if(event) {\r\n    if(`#${ event }` in this) {\r\n      this._listeners[event] = this[`#${ event }`]\r\n    } else {\r\n      delete this._listeners[event]\r\n    }\r\n  }\r\n}\r\n\r\nEventEmitter.prototype = {\r\n  on(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n\r\n    // this._listeners[event]\r\n    //   ? this._listeners[event].push(listener)\r\n    //   : this._listeners[event] = [listener]\r\n\r\n    return this\r\n  },\r\n\r\n  removeListener(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n    // if(!event) {\r\n    //   this._listeners = {}\r\n    // } else {\r\n    //   if(listener && this._listeners[event]) {\r\n    //     const index = this._listeners[event].indexOf(listener)\r\n    //\r\n    //     if(~index) {\r\n    //       this._listeners[event].splice(index, 1)\r\n    //     }\r\n    //   }\r\n    //\r\n    //   if(!listener || !this._listeners[event]) {\r\n    //     delete this._listeners[event]\r\n    //   }\r\n    // }\r\n    return this\r\n  },\r\n\r\n  once(event, listener) {\r\n    function once() {\r\n      this.removeListener(event, _listener)\r\n      return listener.apply(this, arguments)\r\n    }\r\n\r\n    return this.on(event, once)\r\n  }\r\n}\r\n\r\nexport default EventEmitter\r\n","function BufferState(options = {}) {\r\n  Object.assign(this, {\r\n\t\t_buffer: [],\r\n\t\tlength: 0\r\n\t}, options)\r\n}\r\n\r\nBufferState.prototype = {\r\n  push(chunk) {\r\n    if(chunk.length) {\r\n      const node = {\r\n    \t\tchunk: Buffer.from(chunk),\r\n        encoding: 'binary',\r\n    \t\tnext: null\r\n    \t}\r\n\r\n      if(this._buffer.length) {\r\n        this._buffer[this._buffer.length - 1].next = node\r\n      }\r\n\r\n      this._buffer.push(node)\r\n      this.length += node.chunk.length\r\n    }\r\n\r\n    return this.length\r\n  },\r\n\r\n  unshift(chunk) {\r\n    const node = {\r\n  \t\tchunk: Buffer.from(chunk),\r\n      encoding: 'binary',\r\n  \t\tnext: null\r\n  \t}\r\n\r\n    if(this._buffer.length) {\r\n      node.next = this._buffer[0]\r\n    }\r\n\r\n    this._buffer.unshift(node)\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  nodes(count) {\r\n    const nodes = this._buffer.splice(0, count)\r\n    nodes.forEach(node => this.length -= node.chunk.length)\r\n\r\n    return nodes\r\n  },\r\n\r\n  at(index) {\r\n    if(index >= this.length || index < 0) {\r\n      return\r\n    }\r\n\r\n    for(let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex ++) {\r\n      const chunk = this._buffer[nodeIndex].chunk\r\n      if(index < chunk.length) {\r\n        return {\r\n          index,\r\n          nodeIndex,\r\n          value: chunk[index]\r\n        }\r\n      }\r\n\r\n      index -= chunk.length\r\n    }\r\n  },\r\n\r\n  for(from, to, callee) {\r\n    const firstNode = this._buffer[from.nodeIndex]\r\n    for(let index = from.nodeIndex; index < firstNode.chunk.length; index ++) {\r\n      callee.call(this, firstNode.chunk[index])\r\n    }\r\n\r\n    for(let nodeIndex = 1 + from.nodeIndex; nodeIndex < to.nodeIndex; nodeIndex ++) {\r\n      const node = this._buffer[nodeIndex]\r\n      for(let index = 0; index < node.chunk.length; index ++) {\r\n        callee.call(this, node.chunk[index])\r\n      }\r\n    }\r\n\r\n    if(from.nodeIndex < to.nodeIndex) {\r\n      const lastNode = this._buffer[to.nodeIndex]\r\n      for(let index = 0; index <= to.index; index ++) {\r\n        callee.call(this, lastNode.chunk[index])\r\n      }\r\n    }\r\n  },\r\n\r\n  slice(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      to = this.at(length)\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n\r\n    const buffer = Buffer.from(Array(length))\r\n\r\n    const offset = this._buffer.slice(0, to.nodeIndex).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset + node.chunk.length\r\n    }, 0)\r\n\r\n    if(offset < length) {\r\n      const node = this._buffer[to.nodeIndex]\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n    }\r\n\r\n    return buffer\r\n  },\r\n\r\n  buffer(length) {\r\n    if(length === undefined) {\r\n      length = this.length\r\n    }\r\n\r\n    if(!length) {\r\n      return Buffer.from([])\r\n    }\r\n\r\n    if(length > this.length) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if(length) {\r\n      // console.time('at')\r\n      to = this.at(length)\r\n      // console.timeEnd('at')\r\n    }\r\n\r\n    if(!to) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n    // console.time('from')\r\n    const buffer = Buffer.from(Array(length))\r\n    // console.timeEnd('from')\r\n    // console.time('offset')\r\n\r\n    // console.timeEnd('buffer')\r\n\r\n    const offset = this.nodes(1 + to.nodeIndex).reduce((offset, node) => {\r\n      buffer.set(node.chunk, offset)\r\n      return offset + node.chunk.length\r\n    }, 0)\r\n    // console.timeEnd('offset')\r\n    if(offset < length) {\r\n      const node = this.nodes(1)[0]\r\n\r\n      buffer.set(node.chunk.slice(0, length - offset), offset)\r\n      node.chunk = node.chunk.slice(length - offset)\r\n\r\n      this.unshift(node.chunk)\r\n    }\r\n\r\n    return buffer\r\n\r\n    // return from.nodeIndex == to.nodeIndex\r\n    //   ? this._buffer[from.nodeIndex].chunk.slice(from.index, to.index)\r\n    //   : Buffer.concat([\r\n    //       this._buffer[from.nodeIndex].chunk.slice(from.index),\r\n    //       ...this._buffer.slice(1 + from.nodeIndex, to.nodeIndex).map(node => node.chunk),\r\n    //       this._buffer[to.nodeIndex].chunk.slice(0, to.index)\r\n    //     ])\r\n  }\r\n}\r\n\r\nexport default BufferState\r\n","import EventEmitter from 'events'\r\nimport BufferState from 'stream/bufferState'\r\n//import Schedule from 'schedule'\r\nimport series from 'series'\r\n\r\nconst DEFAULT_HIGHWATERMARK = 64\r\n// const defaultWatcher = {\r\n//   cache: {},\r\n//   currentPattern: null,\r\n//   arrayOffset: 0,\r\n//   patternIndex: 0,\r\n//   byteIndex: 0,\r\n//   length: 0,\r\n//   active: false\r\n// }\r\n\r\nfunction decrementActive() {\r\n  if ( !--this._busState.active ) {\r\n    this.emit( 'inactive' )\r\n  }\r\n}\r\n\r\nfunction checkIndex( index, length ) {\r\n\r\n}\r\n\r\nfunction _resetWatcher( watcher ) {\r\n  watcher.currentPattern = null\r\n  watcher.arrayOffset =\r\n    watcher.patternIndex =\r\n    watcher.byteIndex =\r\n    watcher.length = 0\r\n\r\n  watcher.active = false\r\n\r\n  return watcher\r\n\r\n  // return Object.assign(watcher, defaultWatcher)\r\n}\r\n\r\nfunction _parse() {\r\n  const {\r\n    watching,\r\n    frame,\r\n    _buffer\r\n  } = this._busState\r\n\r\n  if ( !watching.length ) {\r\n    this.emit( 'error', {\r\n      msg: 'Unexpected watching data',\r\n      data: this._busState.buffer()\r\n    } )\r\n    return\r\n  }\r\n\r\n  if ( this._busState.nodeIndex < 0 ) {\r\n    this._busState.nodeIndex = 0\r\n  }\r\n\r\n  for ( ; this._busState.nodeIndex < _buffer.length; this._busState.nodeIndex++ ) {\r\n    const {\r\n      chunk\r\n    } = _buffer[ this._busState.nodeIndex ]\r\n    let currentChunkIndex = 0\r\n    let currentIncomingWatcherIndex = 0\r\n    let watcherIndex = 0\r\n    let isEqual = false\r\n    let isChunkCorrupted = false\r\n\r\n    for ( ; currentChunkIndex < chunk.length; currentChunkIndex++ ) {\r\n      let isChunkCorrupted = false\r\n      if ( !this._busState.active ) {\r\n        this._busState.active = this._busState.watching.reduce( ( active, watcher ) => {\r\n          const {\r\n            patterns\r\n          } = watcher\r\n          try {\r\n            watcher.currentPattern = typeof patterns[ 0 ] == 'function' ? patterns[ 0 ]( Buffer.from( [] ) ) : patterns[ 0 ],\r\n              watcher.active = true\r\n            return active + 1\r\n          } catch ( err ) {\r\n            this.emit( 'error', err )\r\n            return active\r\n          }\r\n        }, 0 )\r\n      }\r\n\r\n      const byte = chunk[ currentChunkIndex ]\r\n\r\n      for ( watcherIndex = 0; watcherIndex < watching.length; watcherIndex++, isEqual = false ) {\r\n        const watcher = watching[ watcherIndex ]\r\n\r\n        if ( !watcher.active ) {\r\n          continue\r\n        }\r\n\r\n        const expected = watcher.currentPattern[ watcher.byteIndex ]\r\n\r\n        // console.log('current watching:', watcher.currentPattern)\r\n        // console.log('current chunk:', chunk)\r\n        // console.log('byte:', byte)\r\n        // console.log('expected:', expected)\r\n\r\n        if ( expected === undefined || expected === byte ) {\r\n          isEqual = true\r\n        } else if ( Array.isArray( expected ) ) {\r\n          if ( watcher.arrayOffset <= 0 && expected[ 0 ] > 0 ) {\r\n            watcher.arrayOffset = expected[ 0 ]\r\n          }\r\n\r\n          if ( --watcher.arrayOffset > 0 ) {\r\n            watcher.length++\r\n              continue\r\n          }\r\n\r\n          isEqual = true\r\n        } else if ( typeof expected == 'function' ) {\r\n          try {\r\n            isEqual = !!expected.call( this, {\r\n              byte,\r\n              index: watcher.byteIndex,\r\n              getRelativeIndex: index => {\r\n                if ( typeof index != 'number' ) {\r\n                  throw TypeError( 'number' )\r\n                }\r\n\r\n                index += watcher.byteIndex\r\n\r\n                if ( index < 0 || index > watcher.currentPattern.length ) {\r\n                  throw ReferenceError( 'Illegal pattern boundaries' )\r\n                }\r\n\r\n                return index + watcher.length - watcher.byteIndex\r\n              },\r\n              getAbsoluteIndex: index => {\r\n                if ( typeof index != 'number' ) {\r\n                  throw TypeError( 'number' )\r\n                }\r\n\r\n                if ( index < 0 ) {\r\n                  index += watcher.currentPattern.length\r\n                }\r\n\r\n                if ( index < 0 || index > watcher.currentPattern.length ) {\r\n                  throw ReferenceError( 'Illegal pattern boundaries' )\r\n                }\r\n\r\n                return index + watcher.length - watcher.byteIndex\r\n              },\r\n              getFrame: () => this._busState.slice( 1 + watcher.length )\r\n            } )\r\n          } catch ( err ) {\r\n            isEqual = false\r\n            this.emit( 'error', err )\r\n          }\r\n        }\r\n\r\n        if ( isEqual ) {\r\n          watcher.length++\r\n\r\n            if ( ++watcher.byteIndex >= watcher.currentPattern.length ) {\r\n              if ( ++watcher.patternIndex >= watcher.patterns.length ) {\r\n                // console.time( 'buffer' )\r\n                // console.log(watcher.callback)\r\n                const chunk = this._busState.buffer( watcher.length )\r\n                // console.timeEnd( 'buffer' )\r\n                this._busState.nodeIndex = -1\r\n                try {\r\n                  // console.time( 'cb' )\r\n                  watcher.callback(\r\n                    chunk,\r\n                    // frame.splice(-watcher.length),\r\n                    watcher.pattern\r\n                  )\r\n                  // console.timeEnd( 'cb' )\r\n                } catch ( err ) {\r\n                  this.emit( 'error', err )\r\n                }\r\n                // this._busState.watching = []\r\n                // console.time( 'reset' )\r\n                watching.forEach( watcher => {\r\n                  _resetWatcher( watcher )\r\n                  decrementActive.call( this )\r\n                } )\r\n                // console.timeEnd( 'reset' )\r\n              } else {\r\n                // console.time('next pattern')\r\n                const nextPattern = watcher.patterns[ watcher.patternIndex ]\r\n                watcher.byteIndex = 0\r\n\r\n                try {\r\n                  if ( typeof nextPattern == 'function' ) {\r\n                    watcher.currentPattern = nextPattern.call( this, this._busState.slice( watcher.length ) )\r\n                  } else {\r\n                    watcher.currentPattern = nextPattern\r\n                  }\r\n                } catch ( err ) {\r\n                  _resetWatcher( watcher )\r\n                  decrementActive.call( this )\r\n                  this.emit( 'error', err )\r\n                }\r\n                // console.timeEnd('next pattern')\r\n              }\r\n            }\r\n        } else {\r\n          console.log( watcher )\r\n          _resetWatcher( watcher )\r\n          decrementActive.call( this )\r\n\r\n          if ( !this._busState.active ) {\r\n            this.emit( 'error', {\r\n              msg: 'Unparsed chunk',\r\n              data: this._busState.buffer() // frame.splice(0)\r\n            } )\r\n            //\r\n            // if(!isChunkCorrupted) {\r\n            //   isChunkCorrupted = true\r\n            //   setImmediate(() => {\r\n            //     isChunkCorrupted = false\r\n            //     this.emit('error', {\r\n            //       msg: 'Unparsed chunk',\r\n            //       data: frame.splice(0)\r\n            //     })\r\n            //   })\r\n            // }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if ( this._busState.active ) {\r\n    this.emit( 'drain' )\r\n  }\r\n}\r\n\r\nfunction _Bus( options = {} ) {\r\n  this.transport = options.transport\r\n  this.type = options.type\r\n  this._setup = options.setup.bind( this )\r\n  this._read = length => options.read.call( this, length === undefined ? length : this.options.highWaterMark )\r\n  this._write = options.write.bind( this )\r\n\r\n  this.options = {\r\n    highWaterMark: options.highWaterMark || DEFAULT_HIGHWATERMARK\r\n  }\r\n\r\n  this._busState = new BufferState( {\r\n    watching: [],\r\n    active: 0,\r\n    nodeIndex: 0,\r\n    configured: false,\r\n    ticker: false\r\n  } )\r\n}\r\n\r\n_Bus.prototype = {\r\n  setup() {\r\n    if ( this._busState.configured ) {\r\n      return Promise.reject( 'already configured' )\r\n    }\r\n\r\n    this._busState.configured = true\r\n    return this._setup.apply( this, arguments )\r\n  },\r\n\r\n  push( chunk ) {\r\n    if ( chunk.length ) {\r\n      this._busState.push( chunk )\r\n\r\n      if ( !this._busState.ticker ) {\r\n        this._busState.ticker = true\r\n        setImmediate( () => {\r\n          this._busState.ticker = false\r\n          _parse.call( this )\r\n        } )\r\n      }\r\n    }\r\n    // const highWaterMark = this.options.highWaterMark,\r\n    //       parse = _parse.bind(this)\r\n    //\r\n    // if(chunk.length > highWaterMark) {\r\n    //   const chunks = []\r\n    //   let subchunkIndex = 0\r\n    //\r\n    //   for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\r\n    //     const subchunk = chunk.slice(offset, offset += highWaterMark)\r\n    //     chunks.push(subchunk)\r\n    //   }\r\n    //\r\n    //   series(chunks, (next, subchunk) => {\r\n    //     parse(subchunk)\r\n    //     next()\r\n    //   })\r\n    // }\r\n    // else {\r\n    //   parse(chunk)\r\n    // }\r\n  },\r\n\r\n  watch( patterns, cb ) {\r\n    const watcher = _resetWatcher( {\r\n      patterns,\r\n      callback: cb.bind( this )\r\n    } )\r\n\r\n    this._busState.watching.push( watcher )\r\n\r\n    return watcher\r\n  },\r\n\r\n  unwatch( watcher ) {\r\n    if ( watcher ) {\r\n      const index = this._busState.watching.indexOf( watcher )\r\n\r\n      if ( index >= 0 ) {\r\n        this._busState.watching.splice( index, 1 )\r\n      }\r\n    } else {\r\n      this._busState.watching.splice( 0 )\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  /**\r\n    @TODO Promise interface\r\n  */\r\n\r\n  rx( patterns, ...args ) {\r\n    let cb, options = {}\r\n\r\n    if ( typeof args[ 0 ] == 'function' ) {\r\n      cb = args[ 0 ]\r\n    } else if ( typeof args[ 1 ] == 'function' ) {\r\n      cb = args[ 1 ]\r\n      Object.assign( options, args[ 0 ] )\r\n    } else {\r\n      throw new ReferenceError( 'Callback is not provided' )\r\n    }\r\n\r\n    let watcher\r\n    const setWatcher = () => {\r\n      watcher = this.watch( patterns, cb )\r\n      this._read( this.options.highWaterMark )\r\n    }\r\n\r\n    if ( 'timeout' in options ) {\r\n      setTimeout( setWatcher, options.timeout )\r\n    } else {\r\n      setWatcher()\r\n    }\r\n\r\n    return watcher\r\n  },\r\n\r\n  tx( binary, options = {} ) {\r\n    if ( 'timeout' in options ) {\r\n      setTimeout( () => {\r\n        this._write( binary )\r\n      }, options.timeout )\r\n    } else {\r\n      this._write( binary )\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  reset() {\r\n    this._busState.watching.splice( 0 )\r\n    return this\r\n  }\r\n}\r\n\r\nconst Bus = _extend( {\r\n  super: [ _Bus, EventEmitter ],\r\n  apply: [ _Bus, EventEmitter ]\r\n} )\r\n\r\nexport default Bus\r\n","if(typeof console.time !== 'function') {\r\n  const timers = {}\r\n\r\n  console.time = label => {\r\n    timers[label] = Date.now()\r\n  }\r\n\r\n  console.timeEnd = label => {\r\n    if(label in timers) {\r\n      console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\r\n      delete timers[label]\r\n    }\r\n  }\r\n}\r\n\r\nif(typeof console.error !== 'function') {\r\n  console.error = console.log\r\n}\r\n\r\nexport default console\r\n","let defaultLed\r\nlet ON = 1,\r\n  OFF = 0\r\n\r\nif (process.env.CHIP && process.env.CHIP.toUpperCase() == 'ESP32') {\r\n  defaultLed = D5\r\n  ON = 0\r\n  OFF = 1\r\n} else {\r\n  defaultLed = LED2\r\n}\r\n\r\nlet status = false\r\nconst defaultTimeout = 20\r\n\r\nexport const once = (led, timeout, cb) => {\r\n  // D5.write(0)\r\n  // console.log('on')\r\n  led.write(ON)\r\n  setTimeout(() => {\r\n    // D5.write(1)\r\n    // console.log('off')\r\n    led.write(OFF)\r\n    cb && cb()\r\n  }, timeout || defaultTimeout)\r\n}\r\n\r\nexport const start = led => {\r\n  if (!led) {\r\n    led = defaultLed\r\n  }\r\n  if (!status) {\r\n    status = true\r\n\r\n    once(led, defaultTimeout, function cb() {\r\n      if (status) {\r\n        setTimeout(() => {\r\n          once(led, defaultTimeout, cb)\r\n        }, 1000 - defaultTimeout)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport const stop = () => {\r\n  if (status) {\r\n    status = false\r\n  }\r\n}\r\n","import {\r\n  PN532_PREAMBLE,\r\n  PN532_STARTCODE1,\r\n  PN532_STARTCODE2,\r\n  PN532_HOST_TO_PN532,\r\n  PN532_PN532_TO_HOST,\r\n  PN532_POSTAMBLE\r\n} from './constants'\r\n\r\nconst check = values => !( 0xff & ( -values.reduce( ( sum, value ) => sum + value, 0 ) ) )\r\n\r\nconst LCS_std = ( {\r\n  getFrame,\r\n  getAbsoluteIndex,\r\n  getRelativeIndex\r\n} ) => check( getFrame()\r\n  .slice( -2 ) )\r\n\r\nconst LCS_ext = ( {\r\n  getFrame,\r\n  getAbsoluteIndex\r\n} ) => {\r\n  const frame = getFrame()\r\n  const lcsIndex = getAbsoluteIndex( 7 )\r\n\r\n  return check( [ frame[ lcsIndex - 2 ] * 256 + frame[ lcsIndex - 1 ], frame[ lcsIndex ] ] )\r\n}\r\n\r\nconst CHECKSUM_std = ( {\r\n  getFrame,\r\n  getAbsoluteIndex\r\n} ) => check( getFrame()\r\n  .slice( getAbsoluteIndex( 5 ) ) )\r\n\r\nconst CHECKSUM_ext = ( {\r\n  getFrame,\r\n  getAbsoluteIndex\r\n} ) => check( getFrame()\r\n  .slice( getAbsoluteIndex( 8 ) ) )\r\n\r\nconst BODY_std = ( {\r\n  getFrame,\r\n  getAbsoluteIndex\r\n} ) => {\r\n  return [ getFrame()[ getAbsoluteIndex( 3 ) ] - 1 ]\r\n}\r\n\r\nconst BODY_ext = frame => {\r\n  return [ 256 * frame[ 5 ] + frame[ 6 ] ]\r\n}\r\n\r\nexport const INFO = [\r\n  [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, undefined, LCS_std, PN532_PN532_TO_HOST,\r\n    BODY_std, CHECKSUM_std, PN532_POSTAMBLE\r\n  ]\r\n]\r\n\r\nexport const XINFO = [\r\n  [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0xff, undefined, undefined, LCS_ext, PN532_PN532_TO_HOST ],\r\n  BODY_ext, [ CHECKSUM_ext, PN532_POSTAMBLE ]\r\n]\r\n\r\nexport const ERR = [\r\n  [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x01, 0xff, undefined, CHECKSUM_std, PN532_POSTAMBLE ]\r\n]\r\n\r\nexport const ACK = [\r\n  new Uint8ClampedArray( [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x00, 0xff, PN532_POSTAMBLE ] )\r\n]\r\n\r\nexport const NACK = [\r\n  new Uint8ClampedArray( [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0x00, PN532_POSTAMBLE ] )\r\n]\r\n\r\nexport const command = command =>\r\n  new Uint8Array( [\r\n    PN532_PREAMBLE,\r\n    PN532_STARTCODE1,\r\n    PN532_STARTCODE2,\r\n    0xff & ( command.length + 1 ),\r\n    0xff & ( ~command.length ),\r\n    PN532_HOST_TO_PN532,\r\n    ...command,\r\n    // checksum\r\n    0xff & ( -command.reduce( ( checksum, byte ) => checksum + byte, PN532_HOST_TO_PN532 ) ),\r\n    PN532_POSTAMBLE\r\n  ] )\r\n","Object.assign = (target, ...args) => {\r\n  for(let i in args) {\r\n    const obj = args[i]\r\n    if(obj instanceof Object) {\r\n      for(let key in obj) {\r\n        target[key] = obj[key]\r\n      }\r\n    }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\nexport default Object\r\n","Array.prototype.concat = function () {\r\n  const concatenated = []\r\n\r\n  for(let i in this) {\r\n    concatenated.push(this[i])\r\n  }\r\n\r\n  for(let i in arguments) {\r\n    for(let j in arguments[i]) {\r\n      concatenated.push(arguments[i][j])\r\n    }\r\n  }\r\n\r\n  return concatenated\r\n}\r\n\r\nexport default Array\r\n","// var PENDING = 'pending'\r\n// var SEALED = 'sealed'\r\n// var FULFILLED = 'fulfilled'\r\n// var REJECTED = 'rejected'\r\n//\r\n// var NOOP = function() {}\r\n//\r\n// function invokeResolver(resolver, promise) {\r\n//   function resolvePromise(value) {\r\n//     resolve(promise, value)\r\n//   }\r\n//\r\n//   function rejectPromise(reason) {\r\n//     reject(promise, reason)\r\n//   }\r\n//\r\n//   try {\r\n//     resolver(resolvePromise, rejectPromise)\r\n//   } catch(e) {\r\n//     rejectPromise(e)\r\n//   }\r\n// }\r\n//\r\n// function invokeCallback(subscriber) {\r\n//   var owner = subscriber.owner\r\n//   var settled = owner.state_\r\n//   var value = owner.data_\r\n//   var callback = subscriber[settled]\r\n//   var promise = subscriber.then\r\n//\r\n//   if (typeof callback === 'function')\r\n//   {\r\n//     settled = FULFILLED\r\n//     try {\r\n//       value = callback(value)\r\n//     } catch(e) {\r\n//       reject(promise, e)\r\n//     }\r\n//   }\r\n//\r\n//   if (!handleThenable(promise, value))\r\n//   {\r\n//     if (settled === FULFILLED)\r\n//       resolve(promise, value)\r\n//\r\n//     if (settled === REJECTED)\r\n//       reject(promise, value)\r\n//   }\r\n// }\r\n//\r\n// function handleThenable(promise, value) {\r\n//   var resolved\r\n//\r\n//   try {\r\n//     if (promise === value)\r\n//       throw new TypeError('A promises callback cannot return that same promise.')\r\n//\r\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\r\n//     {\r\n//       var then = value.then  // then should be retrived only once\r\n//\r\n//       if (typeof then === 'function')\r\n//       {\r\n//         then.call(value, function(val){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             if (value !== val)\r\n//               resolve(promise, val)\r\n//             else\r\n//               fulfill(promise, val)\r\n//           }\r\n//         }, function(reason){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             reject(promise, reason)\r\n//           }\r\n//         })\r\n//\r\n//         return true\r\n//       }\r\n//     }\r\n//   } catch (e) {\r\n//     if (!resolved)\r\n//       reject(promise, e)\r\n//\r\n//     return true\r\n//   }\r\n//\r\n//   return false\r\n// }\r\n//\r\n// function resolve(promise, value){\r\n//   if (promise === value || !handleThenable(promise, value))\r\n//     fulfill(promise, value)\r\n// }\r\n//\r\n// function publish(promise) {\r\n//   var callbacks = promise.then_\r\n//   promise.then_ = undefined\r\n//\r\n//   for (var i = 0 i < callbacks.length i++) {\r\n//     invokeCallback(callbacks[i])\r\n//   }\r\n// }\r\n//\r\n// function fulfill(promise, value){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = value\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = FULFILLED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function reject(promise, reason){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = reason\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = REJECTED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function Promise(resolver) {\r\n//   if (typeof resolver !== 'function')\r\n//     throw new TypeError('Promise constructor takes a function argument')\r\n//\r\n//   if (this instanceof Promise === false)\r\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\r\n//\r\n//   this.then_ = []\r\n//\r\n//   invokeResolver(resolver, this)\r\n// }\r\n//\r\n// Promise.prototype = {\r\n//   constructor: Promise,\r\n//\r\n//   state_: PENDING,\r\n//   then_: null,\r\n//   data_: undefined,\r\n//\r\n//   then: function(onFulfillment, onRejection){\r\n//     var subscriber = {\r\n//       owner: this,\r\n//       then: new this.constructor(NOOP),\r\n//       fulfilled: onFulfillment,\r\n//       rejected: onRejection\r\n//     }\r\n//\r\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\r\n//     {\r\n//       // already resolved, call callback async\r\n//       setImmediate(() => {invokeCallback(subscriber)})\r\n//     }\r\n//     else\r\n//     {\r\n//       // subscribe\r\n//       this.then_.push(subscriber)\r\n//     }\r\n//\r\n//     return subscriber.then\r\n//   },\r\n//\r\n//   'catch': function(onRejection) {\r\n//     return this.then(null, onRejection)\r\n//   }\r\n// }\r\n\r\n// Promise.all = function(promises) {\r\n//   if (!(promises instanceof Array)) {\r\n//     throw new TypeError('You must pass an array to Promise.all().')\r\n//   }\r\n//\r\n//   return new Promise((resolve, reject) => {\r\n//     var results = []\r\n//     var remaining = 0\r\n//\r\n//     function resolver(index) {\r\n//       remaining++\r\n//       return function(value) {\r\n//         results[index] = value\r\n//         if (!--remaining) {\r\n//           resolve(results)\r\n//         }\r\n//       }\r\n//     }\r\n//\r\n//     for (var i = 0, promise; i < promises.length; i++) {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function') {\r\n//         promise.then(resolver(i), reject)\r\n//       }\r\n//       else {\r\n//         results[i] = promise\r\n//       }\r\n//     }\r\n//\r\n//     if (!remaining) {\r\n//       resolve(results)\r\n//     }\r\n//   })\r\n// }\r\n\r\nPromise.race = function(promises){\r\n  var Class = this\r\n\r\n  if (!(promises instanceof Array))\r\n    throw new TypeError('You must pass an array to Promise.race().')\r\n\r\n  return new Class((resolve, reject) => {\r\n    for (var i = 0, promise; i < promises.length; i++)\r\n    {\r\n      promise = promises[i]\r\n\r\n      if (promise && typeof promise.then === 'function')\r\n        promise.then(resolve, reject)\r\n      else\r\n        resolve(promise)\r\n    }\r\n  })\r\n}\r\n\r\n// Promise.resolve = function(value) {\r\n//   var Class = this\r\n//\r\n//   if (value && typeof value === 'object' && value.constructor === Class)\r\n//     return value\r\n//\r\n//   return new Class(function(resolve){\r\n//     resolve(value)\r\n//   })\r\n// }\r\n//\r\n// Promise.reject = function(reason){\r\n//   var Class = this\r\n//\r\n//   return new Class(function(resolve, reject){\r\n//     reject(reason)\r\n//   })\r\n// }\r\n//\r\n\r\nexport default Promise\r\n","const defProp = (obj, prop, desc) => {\r\n  try {\r\n    return Object.defineProperty(obj, prop, desc)\r\n  } catch(e) {\r\n    if(desc.get) {\r\n      obj.value = desc.get()\r\n    }\r\n    else if(desc.value) {\r\n      obj[prop] = desc.value\r\n    }\r\n\r\n    return obj\r\n  }\r\n}\r\n\r\nexport {\r\n  defProp\r\n}\r\n","import {\r\n  SUPER_CHAIN_PROTO_PROP,\r\n  SUPER_CHAIN_APPLY_PROP,\r\n  PROTOTYPE_IS_EXTENDED_PROP\r\n} from './props'\r\n\r\nconst _copyChain = (Extended, ProtoChain, chainPropName, ignoreExtended) => {\r\n  //if chain on [Extended] has not been created yet\r\n  if(!Extended.prototype[chainPropName]) {\r\n    Object.defineProperty(Extended.prototype, chainPropName, { value: [] })\r\n  }\r\n\r\n  ProtoChain.forEach(Proto => {\r\n    //console.log(!!Proto.prototype['__extended__'], Proto)\r\n    //if [Proto] has been '__extended__' and has same-named proto chain, copy the Proto chain to Extended chain\r\n    const isExtended = !!Proto.prototype[PROTOTYPE_IS_EXTENDED_PROP],\r\n          hasSameChain = !!Proto.prototype[chainPropName]\r\n\r\n    const alreadyInChain = Extended.prototype[chainPropName].some(P => P === Proto),\r\n          shouldBePushed = (!isExtended || !ignoreExtended) && !alreadyInChain,\r\n          shouldCopyChain = isExtended && hasSameChain\r\n\r\n    if(shouldCopyChain)\r\n      Proto.prototype[chainPropName].forEach(Proto => {\r\n        //avoid pushing twice\r\n        if(!Extended.prototype[chainPropName].some(P => P === Proto) ) {\r\n          //console.log('pushed', Proto)\r\n          Extended.prototype[chainPropName].push(Proto)\r\n        }\r\n      })\r\n\r\n    if(shouldBePushed) {\r\n      Extended.prototype[chainPropName].push(Proto)\r\n    }\r\n  })\r\n\r\n  //console.log(Extended.prototype[chainPropName])\r\n}\r\n\r\nconst _extend = (options = {}) => {\r\n  if(!options.apply)\r\n    options.apply = []\r\n  if(!options.super)\r\n    options.super = []\r\n  if(!options.static)\r\n    options.static = []\r\n\r\n  const Child = options.super[0]\r\n\r\n  if(!options.name)\r\n    options.name = Child.name\r\n\r\n  function Extended() {\r\n    Extended.prototype[SUPER_CHAIN_APPLY_PROP].forEach(Super => {\r\n      if(Super !== Extended) {\r\n        Super.apply(this, arguments)\r\n      }\r\n    })\r\n  }\r\n\r\n  _named(options.name, Extended)\r\n\r\n  for(let i in options.static) {\r\n    for(let prop in options.static[i]) {\r\n      if('prototype' != prop) {\r\n        Object.defineProperty(Extended, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  Extended.prototype = {}\r\n  Extended.prototype.constructor = Child\r\n  Extended.prototype[PROTOTYPE_IS_EXTENDED_PROP] = true\r\n\r\n  for(let i in options.super) {\r\n    function Proto() {}\r\n    Proto.prototype = options.super[i].prototype\r\n    const proto = new Proto()\r\n\r\n    for(let prop in proto) {\r\n      if(['constructor', PROTOTYPE_IS_EXTENDED_PROP, SUPER_CHAIN_PROTO_PROP, SUPER_CHAIN_APPLY_PROP].indexOf(prop) < 0) {\r\n        Object.defineProperty(Extended.prototype, prop, {\r\n          value: proto[prop],\r\n          enumerable: true,\r\n          writable: true\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  _copyChain(Extended, options.super, SUPER_CHAIN_PROTO_PROP, false)\r\n  _copyChain(Extended, options.apply, SUPER_CHAIN_APPLY_PROP, true)\r\n\r\n  return Extended\r\n}\r\n\r\nexport const extend = (...args) => _extend({ super: args.slice(1), apply: args })\r\n\r\nexport { _extend, _copyChain }\r\n","const PUSH_TO_QUEUE_IMMEDIATE = 0,\r\n      PUSH_AT_NEXT_STAGE = 1,\r\n      loop = [\r\n        // nextTick\r\n        { queue: [], immediatePush: true, tick: false },\r\n        // immediate\r\n        { queue: [], immediatePush: true, tick: false },\r\n        // timeout\r\n        { queue: [], immediatePush: false, tick: false }\r\n      ]\r\n\r\nlet tick = false,\r\n    timers = {}\r\n\r\nconst asyncFlush = () => {\r\n  for (let stage in loop) {\r\n    if(loop[stage].queue.length) {\r\n      if(loop[stage].immediatePush) {\r\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\r\n          loop[stage].queue[exec]()\r\n        }\r\n        loop[stage].queue.splice(0)\r\n      } else {\r\n        const queue = loop[stage].queue.splice(0)\r\n        for (let exec = 0; exec < queue.length; exec ++) {\r\n          queue[exec]()\r\n        }\r\n      }\r\n    }\r\n\r\n    loop[stage].tick = tick = false\r\n  }\r\n}\r\n\r\nconst asyncCall = stage => cb => {\r\n  loop[stage].queue.push(cb)\r\n\r\n  if (!tick && !loop[stage].tick) {\r\n    loop[stage].tick = tick = true\r\n\r\n    setTimeout(asyncFlush)\r\n  }\r\n}\r\n\r\nconst nextTick = asyncCall(/* .nextTick */0)\r\n\r\nconst setImmediate = asyncCall(/* .immediate */1)\r\n\r\nconst timeoutCall = asyncCall(/* .timeeout */2)\r\n\r\nexport const _setTimeout = (cb, timeout) => {\r\n  // let index = 0\r\n  // while(timers[index]) {\r\n  //   index++\r\n  // }\r\n  // timers[index] = setTimeout(() => {\r\n  //   if(timers[index]) {\r\n  //     delete timers[index]\r\n  //     timeoutCall(cb)\r\n  //   }\r\n  // }, timeout)\r\n  //\r\n  // return index\r\n\r\n  return setTimeout(() => {\r\n    timeoutCall(cb)\r\n  }, timeout)\r\n}\r\n\r\nexport const _setInterval = (cb, timeout) => {\r\n  return (function setTimer() {\r\n    return _setTimeout(() => {\r\n      setTimer()\r\n      cb()\r\n    }, timeout)\r\n  })()\r\n}\r\n\r\nexport {\r\n  nextTick,\r\n  setImmediate,\r\n  _setTimeout as setTimeout,\r\n  _setInterval as setInterval\r\n}\r\n","export default (name, f) => {\r\n  defProp(f, 'name', { value: name })\r\n  //defProp(f, 'toString', { value: () => '[Function' + (f.name !== undefined ? ': ' + f.name : '') + ']' })\r\n\r\n  return f\r\n}\r\n","import Bus from 'bus'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  ERR,\r\n  INFO\r\n} from './'\r\nimport {\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_WRITE_16,\r\n  PN532_BRTY_ISO14443A,\r\n  PN532_BRTY_ISO14443B\r\n} from './constants'\r\n\r\nimport series from 'series'\r\n\r\nconst sliceAck = chunk => chunk.slice( ACK.length )\r\n\r\nconst parseInfo = chunk => {\r\n  return {\r\n    raw: chunk,\r\n    code: chunk[ 6 ],\r\n    body: Buffer.from( chunk.slice( 7, 5 + chunk[ 3 ] ) )\r\n  }\r\n}\r\n\r\nconst parseBlockData = data => {\r\n  if ( data.body.length == 1 ) {\r\n    throw {\r\n      cmd: data.code,\r\n      errCode: data.body[ 0 ]\r\n    }\r\n  } else {\r\n    return {\r\n      chunk: data.body.slice( 1 )\r\n    }\r\n  }\r\n}\r\n\r\nconst NfcBus = {\r\n  makeTransaction( cmd, info, parsers ) {\r\n    return new Promise( ( done, fail ) => {\r\n        // Don't be silly again - info frame refers to index from beginning, i.e. to ACK\r\n        // this.rx([...ACK, ...info], chunk => done((parsers || [sliceAck, parseInfo]).reduce((data, parse) => parse(data), chunk)))\r\n        this.rx( ACK, () => {\r\n          this.rx( info, chunk => done( ( parsers || [ parseInfo ] )\r\n            .reduce( ( data, parse ) => parse( data ), chunk ) ) )\r\n        } )\r\n\r\n        this.rx( NACK, fail )\r\n        this.rx( ERR, fail )\r\n\r\n        this.tx( command( cmd ) )\r\n      } )\r\n      .catch( err => {\r\n        this.unwatch()\r\n        throw err\r\n      } )\r\n      .then( data => {\r\n        this.unwatch()\r\n        return data\r\n      } )\r\n  },\r\n\r\n  findTargets( count, type ) {\r\n    if ( type == 'A' ) {\r\n      type = PN532_BRTY_ISO14443A\r\n    } else if ( type == 'B' ) {\r\n      type = PN532_BRTY_ISO14443B\r\n    } else {\r\n      throw new Error( 'Unknown ISO14443 type:', type )\r\n    }\r\n\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INLISTPASSIVETARGET,\r\n      count,\r\n      type\r\n    ], INFO, [ chunk => {\r\n      const body = chunk.slice( 7, 5 + chunk[ 3 ] )\r\n      const uid = body.slice( 6, 6 + body[ 5 ] )\r\n      return {\r\n        code: chunk[ 6 ],\r\n        body,\r\n        count: body[ 0 ],\r\n        atqa: body.slice( 2, 4 ), // SENS_RES\r\n        sak: body[ 4 ],\r\n        uid\r\n      }\r\n    } ] )\r\n  },\r\n\r\n  authenticate( block, uid, key ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_AUTH_A,\r\n      block,\r\n      ...[].slice.call( key ),\r\n      ...[].slice.call( uid )\r\n    ], INFO )\r\n  },\r\n\r\n  readBlock( block ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_READ_16,\r\n      block\r\n    ], INFO, [ parseInfo, parseBlockData ] )\r\n  },\r\n\r\n  writeBlock( block, chunk ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_WRITE_16,\r\n      block,\r\n      ...[].slice.call( chunk )\r\n    ], INFO )\r\n  },\r\n\r\n  readSector( sector ) {\r\n    return new Promise( ( done, fail ) => {\r\n      const readBlocksArr = []\r\n      for ( let block = sector * 4; block < sector * 4 + 3; block++ ) {\r\n        readBlocksArr.push( block )\r\n      }\r\n\r\n      series( readBlocksArr, ( next, block, index ) => {\r\n        this.readBlock( block )\r\n          .then( data => {\r\n            readBlocksArr[ index ] = data\r\n            next()\r\n          } )\r\n          .catch( err => {\r\n            console.log( '!!!' )\r\n            next( err )\r\n          } )\r\n      }, err => err ? fail( err ) : done( readBlocksArr ) )\r\n    } )\r\n  },\r\n\r\n  writeSector( start, chunk ) {\r\n\r\n  }\r\n}\r\n\r\nexport default options => Object.assign( new Bus( options ), NfcBus )","export default function series( arr, cb, done ) {\r\n  let i = 0\r\n  let aborted = false;\r\n  ( function next( res ) {\r\n    if ( !aborted ) {\r\n      if ( typeof res !== 'undefined' || i >= arr.length ) {\r\n        done && done( res )\r\n      } else {\r\n        setImmediate( () => {\r\n          try {\r\n            cb( next, arr[ i ], i++, arr )\r\n          } catch ( err ) {\r\n            next( err )\r\n            aborted = true\r\n          }\r\n        } )\r\n      }\r\n    }\r\n  } )()\r\n}\r\n","// import Bus from 'bus'\r\n//\r\n// const preamble = [ 1, 2, 3 ]\r\n// const postamble = [ 4, ( {\r\n//   getFrame,\r\n//   getAbsoluteIndex,\r\n//   getRelativeIndex\r\n// } ) => {\r\n//   console.log( getAbsoluteIndex( 1 ), getRelativeIndex( 0 ) )\r\n//   return true\r\n// }, 6 ]\r\n//\r\n// const bus = new Bus( {\r\n//   read() {},\r\n//   write() {},\r\n//   setup() {}\r\n// } )\r\n//\r\n// bus.on( 'error', console.error )\r\n//\r\n// bus.rx( [\r\n//   preamble,\r\n//   postamble\r\n// ], console.log )\r\n//\r\n// bus.push( preamble )\r\n// bus.push( postamble )\r\n\r\n// import Bus from 'bus'\r\n// import Schedule from 'schedule'\r\nimport * as Blink from 'blink'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  INFO,\r\n  XINFO\r\n} from 'nfc'\r\nimport Bus from 'nfc/bus'\r\nimport {\r\n  PN532_I2C_ADDRESS,\r\n  PN532_COMMAND_SAMCONFIGURATION,\r\n  PN532_SAM_NORMAL_MODE,\r\n  PN532_COMMAND_WRITEGPIO,\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  PN532_COMMAND_GETFIRMWAREVERSION,\r\n  PN532_COMMAND_WAKEUP,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_AUTH_B,\r\n  MIFARE_COMMAND_WRITE_4,\r\n  MIFARE_COMMAND_WRITE_16\r\n} from 'nfc/constants'\r\n\r\nimport {\r\n  encodeMessage,\r\n  decodeMessage,\r\n  textRecord\r\n} from 'esp-ndef'\r\n\r\n// let usbConsole = true\r\n// let consoleBus = null\r\n// let log = ''\r\n//\r\n//\r\n// function toggleConsole() {\r\n//   usbConsole = !usbConsole\r\n//   if (usbConsole) {\r\n//     consoleBus = null\r\n//     USB.removeAllListeners()\r\n//   } else {\r\n//     consoleBus = new Bus({\r\n//       setup() {\r\n//         USB.on('data', data => {\r\n//           this.parse.call(this, data)\r\n//           USB.setup()\r\n//           // USB.write(Buffer.from(['!', ...[].slice.call(data, 0)]))\r\n//         })\r\n//       },\r\n//       read() {},\r\n//       write() {}\r\n//     })\r\n//\r\n//     consoleBus.rx([Buffer.from('/on')], () => {\r\n//       Blink.once(LED1)\r\n//       USB.write(JSON.stringify(consoleBus._busState))\r\n//       // toggleConsole()\r\n//     })\r\n//\r\n//     // consoleBus.rx([Buffer.from('/off')], () => {\r\n//     //   LED1.write(1)\r\n//     //   // USB.write('/off\\r\\n')\r\n//     //   // toggleConsole()\r\n//     // })\r\n//     //\r\n//     // consoleBus.on('error', err => {\r\n//     //   Blink.once(LED1, 200)\r\n//     // })\r\n//\r\n//     consoleBus.setup()\r\n//   }\r\n//\r\n//   usbConsole ?\r\n//     USB.setConsole(false) :\r\n//     LoopbackA.setConsole(false)\r\n// }\r\n//\r\n// toggleConsole()\r\n\r\n// setWatch( toggleConsole, BTN1, {\r\n//   repeat: true,\r\n//   edge: 'rising',\r\n//   debounce: 50\r\n// } )\r\n//\r\n// Blink.start( LED2 )\r\n//\r\n// const encoded = encodeMessage( [\r\n//   textRecord( '2enhello world!' )\r\n// ] )\r\n//\r\n// import fs from 'fs'\r\n\r\nconst wakeup = command( [ PN532_COMMAND_WAKEUP ] )\r\nconst sam = command( [ PN532_COMMAND_SAMCONFIGURATION, PN532_SAM_NORMAL_MODE, 20, 0 ] )\r\n\r\n// [0, 0, 255, 0, 255, 0]\r\n// [0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0]\r\n\r\n// [0, 0, 255, 0, 255, 0, 2, 42, 1, 6, 7, 232, 0, 0, 0, ]\r\n\r\n// [1, 0, 0, 255, 0, 255, 0, 2, 42, 0, 0, 0, 0, 0, 0, 0]\r\n// [1, 0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0, 0, 0]\r\n\r\nfunction setup() {\r\n  if ( this.type == 'serial' ) {\r\n    this.transport.setup( 115200 )\r\n\r\n    this.transport.write( wakeup )\r\n    this.transport.write( sam )\r\n\r\n    setTimeout( () => {\r\n      this.transport.read()\r\n      this.transport.on( 'data', data => this.push( data ) )\r\n      console.log( 'Bus has been set up' )\r\n      Blink.once( LED1, 20, () => {\r\n        setTimeout( () => Blink.once( LED1, 20 ), 200 )\r\n      } )\r\n\r\n      this.rx( [\r\n        ...ACK,\r\n        ...INFO\r\n      ], frame => {\r\n        console.log( 'frame' )\r\n        console.log( frame )\r\n      } )\r\n\r\n      this.tx( command( [ PN532_COMMAND_GETFIRMWAREVERSION ] ) )\r\n    }, 500 )\r\n  } else if ( this.type == 'i2c' ) {\r\n    this.transport.setup( {\r\n      bitrate: 400 * 1000\r\n    } )\r\n\r\n    this.on( 'drain', () => {\r\n      this._read()\r\n    } )\r\n\r\n    try {\r\n      this.tx( 1 )\r\n    } catch ( err ) {\r\n      console.log( 'Handled', err.msg )\r\n      console.log( 'Continue...' )\r\n    }\r\n\r\n    this.tx( command( [ PN532_COMMAND_GETFIRMWAREVERSION ] ) )\r\n\r\n    this.rx( [\r\n      ...ACK,\r\n      ...INFO\r\n    ], {\r\n      timeout: 10\r\n    }, frame => {\r\n      console.log( 'frame' )\r\n      console.log( frame )\r\n    } )\r\n  }\r\n}\r\n\r\nconst bus = new Bus( {\r\n  transport: Serial1,\r\n  type: 'serial',\r\n  setup,\r\n  read( length ) {\r\n    if ( this.type == 'i2c' ) {\r\n      while ( true ) {\r\n        if ( this.transport.readFrom( PN532_I2C_ADDRESS, 1 )[ 0 ] ) {\r\n          const chunk = this.transport.readFrom( PN532_I2C_ADDRESS, 1 + length )\r\n          this.push( chunk )\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n    } else if ( this.type == 'serial' ) {\r\n      // const chunk = this.transport.read(length)\r\n      // this.push(chunk)\r\n    }\r\n  },\r\n  write( chunk ) {\r\n    if ( this.type == 'serial' ) {\r\n      this.transport.write( chunk )\r\n    } else if ( this.type == 'i2c' ) {\r\n      this.transport.writeTo( PN532_I2C_ADDRESS, chunk )\r\n    }\r\n  },\r\n  highWaterMark: 16\r\n} )\r\n\r\nbus.on( 'error', err => {\r\n  console.error( 'BusError:', err )\r\n} )\r\n\r\nbus.setup()\r\n\r\n// const key = new Uint8  Array(Array(6).fill(0xff))\r\n\r\n// console.log(key)\r\n\r\n\r\n// setTimeout(() => {\r\n//   (function poll() {\r\n//     // console.log(process.memory().free)\r\n//     // console.log(bus._busState.watching.length)\r\n//     Promise.resolve()\r\n//       .then(() => bus.findTargets(1, 'A')) // .then(data => { console.log('found card', data.uid); return data })\r\n//       .then(data => {\r\n//         LED1.write(0)\r\n//         return data\r\n//       })\r\n//       // .then(data => bus.authenticate(4, data.uid, key).then(data => { console.log('auth op 4:', data) }).then(() => bus.authenticate(3, data.uid, key).then(data => { console.log('auth op:', data) })))\r\n//       .then(data => bus.authenticate(1 * 4, data.uid, key)) // .then(data => { console.log('auth', data) })\r\n//       // .then(data => bus.writeBlock(4, [1, 3, 6, 4])).then(data => { console.log('write op:', data) })\r\n//       // .then(data => { console.time('reading 2 sector'); return data })\r\n//       .then(data => bus.readSector(1))\r\n//       .then(data => {\r\n//         LED1.write(1)\r\n//         return data\r\n//       }) // .then(data => { console.log('sector 2:', data); return data })\r\n//       .then(data => data.reduce((buffer, data) => [...buffer, ...[].slice.call(data.chunk, 0)], []))\r\n//       .then(console.log)\r\n//       // .then(data => { console.timeEnd('reading 2 sector'); return data })\r\n//       // .then(data => bus.readBlock(4)).then(data => { console.log('block 4:', data) })\r\n//       // .then(data => bus.readBlock(5)).then(data => { console.log('block 5:', data) })\r\n//       // .then(data => bus.readBlock(6)).then(data => { console.log('block 6:', data) })\r\n//       // .then(data => bus.readBlock(7)).then(data => { console.log('block 7:', data) })\r\n//       .catch(err => {\r\n//         LED1.write(1)\r\n//         console.error('Error:', err)\r\n//       })\r\n//       .then(() => {\r\n//         setTimeout(() => {\r\n//           poll()\r\n//         }, 500)\r\n//       })\r\n//   })()\r\n// }, 1000)\r\n"],"names":["Buffer","Error","EventEmitter","_listeners","_duplicateEvent","event","this","BufferState","options","assign","decrementActive","_busState","active","emit","_resetWatcher","watcher","currentPattern","arrayOffset","patternIndex","byteIndex","length","_Bus","transport","type","_setup","setup","bind","_read","read","call","undefined","_this2","highWaterMark","_write","write","DEFAULT_HIGHWATERMARK","console","time","timers","label","Date","now","timeEnd","log","toFixed","error","ON","OFF","process","env","CHIP","toUpperCase","once","led","timeout","cb","check","values","reduce","sum","value","CHECKSUM_std","getFrame","getAbsoluteIndex","slice","INFO","PN532_PREAMBLE","PN532_STARTCODE1","PN532_STARTCODE2","ERR","ACK","Uint8ClampedArray","NACK","command","Uint8Array","PN532_HOST_TO_PN532","checksum","byte","Object","target","args","i","obj","key","concat","concatenated","push","arguments","j","Promise","race","promises","Array","TypeError","resolve","reject","promise","then","from","iterable","offset","parsed","c","charCodeAt","ArrayBuffer","_list","_totalLength","list","totalLength","array","buffer","buf","set","_copyChain","Extended","ProtoChain","chainPropName","ignoreExtended","prototype","defineProperty","forEach","isExtended","Proto","PROTOTYPE_IS_EXTENDED_PROP","hasSameChain","alreadyInChain","some","P","shouldBePushed","loop","queue","immediatePush","tick","asyncFlush","stage","exec","splice","asyncCall","setImmediate","listener","on","removeListener","_listener","apply","chunk","node","_buffer","next","unshift","count","nodes","_this","index","nodeIndex","to","callee","firstNode","lastNode","at","configured","ticker","watching","frame","currentChunkIndex","watcherIndex","isEqual","patterns","err","expected","isArray","ReferenceError","callback","pattern","nextPattern","indexOf","setWatcher","_this4","watch","binary","Bus","SUPER_CHAIN_APPLY_PROP","Super","super","static","Child","name","prop","desc","e","get","proto","constructor","SUPER_CHAIN_PROTO_PROP","_extend","parseInfo","parseBlockData","data","body","code","NfcBus","cmd","info","parsers","done","fail","rx","parse","tx","catch","unwatch","makeTransaction","uid","block","PN532_COMMAND_INDATAEXCHANGE","MIFARE_COMMAND_AUTH_A","MIFARE_COMMAND_WRITE_16","sector","readBlocksArr","arr","aborted","res","readBlock","start","wakeup","sam","bus","Serial1","LED1","Blink","msg","readFrom","writeTo"],"mappings":"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"}
