{"version":3,"file":"index.esp32.min.js","sources":["../globals/buffer.js","../lib/events.js","../lib/stream/bufferState.js","../lib/bus.js","../globals/console.js","../globals/object.js","../globals/def.js","../globals/extend/index.js","../globals/array.js","../globals/promise.js","../globals/event-loop.js","../src/index.js","../globals/namedFunc.js"],"sourcesContent":["// import Uint8Array from './Uint8Array'\n// import { toBuffer } from './utils/to'\n\n// function copy(target) {\n// \tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\n// \t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\n// \t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\n//\n// \tlet copied = 0\n//\n// \tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\n// \t\ttarget.set([ this[sourceIndex] ], targetIndex)\n//\n// \treturn copied\n// }\n//\nfunction Buffer() {\n  throw new Error()\n}\n\n//Buffer.from = (iterable, offset, length) => E.toUint8Array(iterable)\n\nBuffer.from = (iterable, offset, length) => {\n  if (typeof iterable == 'string') {\n    const parsed = []\n\n    for (let c in iterable) {\n      parsed[c] = iterable.charCodeAt(c)\n    }\n\n    return new Uint8Array(parsed)\n  } else if (iterable instanceof ArrayBuffer) {\n    return new Uint8Array(iterable.slice(offset !== undefined ? offset : 0, offset + (length !== undefined ? length : iterable.length)))\n  } else if (iterable instanceof Array || iterable instanceof Uint8Array) {\n    return new Uint8Array(iterable)\n  } else {\n    throw new TypeError('Cannot create buffer from', typeof iterable)\n  }\n}\n\nBuffer.concat = (_list, _totalLength) => {\n  const list = _list || [],\n    totalLength = _totalLength !== undefined ? _totalLength : list.reduce((totalLength, array) => totalLength + array.length, 0),\n    buffer = Buffer.from([], 0, totalLength)\n\n  list.reduce((offset, buf) => {\n    buffer.set(buf, offset)\n    return offset + buf.length\n  }, 0)\n\n  return buffer\n}\n\nexport default Buffer\n","function EventEmitter() {\n  this._listeners = {}\n}\n\n//_named('EventEmitter', EventEmitter)\n\nfunction _duplicateEvent(event) {\n  if(event) {\n    if(`#${ event }` in this) {\n      this._listeners[event] = this[`#${ event }`]\n    } else {\n      delete this._listeners[event]\n    }\n  }\n}\n\nEventEmitter.prototype = {\n  on(event, listener) {\n    Object.prototype.on.call(this, event, listener)\n    _duplicateEvent.call(this, event)\n\n    // this._listeners[event]\n    //   ? this._listeners[event].push(listener)\n    //   : this._listeners[event] = [listener]\n\n    return this\n  },\n\n  removeListener(event, listener) {\n    Object.prototype.on.call(this, event, listener)\n    _duplicateEvent.call(this, event)\n    // if(!event) {\n    //   this._listeners = {}\n    // } else {\n    //   if(listener && this._listeners[event]) {\n    //     const index = this._listeners[event].indexOf(listener)\n    //\n    //     if(~index) {\n    //       this._listeners[event].splice(index, 1)\n    //     }\n    //   }\n    //\n    //   if(!listener || !this._listeners[event]) {\n    //     delete this._listeners[event]\n    //   }\n    // }\n    return this\n  },\n\n  once(event, listener) {\n    function once() {\n      this.removeListener(event, _listener)\n      return listener.apply(this, arguments)\n    }\n\n    return this.on(event, once)\n  }\n}\n\nexport default EventEmitter\n","function BufferState(options = {}) {\n  Object.assign(this, {\n\t\t_buffer: [],\n\t\tlength: 0\n\t}, options)\n}\n\nBufferState.prototype = {\n  push(chunk) {\n    if(chunk.length) {\n      const node = {\n    \t\tchunk: Buffer.from(chunk),\n        encoding: 'binary',\n    \t\tnext: null\n    \t}\n\n      if(this._buffer.length) {\n        this._buffer[this._buffer.length - 1].next = node\n      }\n\n      this._buffer.push(node)\n      this.length += node.chunk.length\n    }\n\n    return this.length\n  },\n\n  unshift(chunk) {\n    const node = {\n  \t\tchunk: Buffer.from(chunk),\n      encoding: 'binary',\n  \t\tnext: null\n  \t}\n\n    if(this._buffer.length) {\n      node.next = this._buffer[0]\n    }\n\n    this._buffer.unshift(node)\n    this.length += node.chunk.length\n\n    return this.length\n  },\n\n  nodes(count) {\n    const nodes = this._buffer.splice(0, count)\n    nodes.forEach(node => this.length -= node.chunk.length)\n\n    return nodes\n  },\n\n  at(index) {\n    if(index >= this.length || index < 0) {\n      return\n    }\n\n    for(let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex ++) {\n      const chunk = this._buffer[nodeIndex].chunk\n      if(index < chunk.length) {\n        return {\n          index,\n          nodeIndex,\n          value: chunk[index]\n        }\n      }\n\n      index -= chunk.length\n    }\n  },\n\n  for(from, to, callee) {\n    const firstNode = this._buffer[from.nodeIndex]\n    for(let index = from.nodeIndex; index < firstNode.chunk.length; index ++) {\n      callee.call(this, firstNode.chunk[index])\n    }\n\n    for(let nodeIndex = 1 + from.nodeIndex; nodeIndex < to.nodeIndex; nodeIndex ++) {\n      const node = this._buffer[nodeIndex]\n      for(let index = 0; index < node.chunk.length; index ++) {\n        callee.call(this, node.chunk[index])\n      }\n    }\n\n    if(from.nodeIndex < to.nodeIndex) {\n      const lastNode = this._buffer[to.nodeIndex]\n      for(let index = 0; index <= to.index; index ++) {\n        callee.call(this, lastNode.chunk[index])\n      }\n    }\n  },\n\n  slice(length) {\n    if(length === undefined) {\n      length = this.length\n    }\n\n    if(!length) {\n      return Buffer.from([])\n    }\n\n    if(length > this.length) {\n      length = this.length\n    }\n\n    let to\n\n    if(length) {\n      to = this.at(length)\n    }\n\n    if(!to) {\n      to = {\n        index: this.length - 1,\n        nodeIndex: this._buffer.length - 1\n      }\n    }\n\n    const buffer = Buffer.from(Array(length))\n\n    const offset = this._buffer.slice(0, to.nodeIndex).reduce((offset, node) => {\n      buffer.set(node.chunk, offset)\n      return offset + node.chunk.length\n    }, 0)\n\n    if(offset < length) {\n      const node = this._buffer[to.nodeIndex]\n\n      buffer.set(node.chunk.slice(0, length - offset), offset)\n    }\n\n    return buffer\n  },\n\n  buffer(length) {\n    if(length === undefined) {\n      length = this.length\n    }\n\n    if(!length) {\n      return Buffer.from([])\n    }\n\n    if(length > this.length) {\n      length = this.length\n    }\n\n    let to\n\n    if(length) {\n      // console.time('at')\n      to = this.at(length)\n      // console.timeEnd('at')\n    }\n\n    if(!to) {\n      to = {\n        index: this.length - 1,\n        nodeIndex: this._buffer.length - 1\n      }\n    }\n    // console.time('from')\n    const buffer = Buffer.from(Array(length))\n    // console.timeEnd('from')\n    // console.time('offset')\n\n    // console.timeEnd('buffer')\n\n    const offset = this.nodes(1 + to.nodeIndex).reduce((offset, node) => {\n      buffer.set(node.chunk, offset)\n      return offset + node.chunk.length\n    }, 0)\n    // console.timeEnd('offset')\n    if(offset < length) {\n      const node = this.nodes(1)[0]\n\n      buffer.set(node.chunk.slice(0, length - offset), offset)\n      node.chunk = node.chunk.slice(length - offset)\n\n      this.unshift(node.chunk)\n    }\n\n    return buffer\n\n    // return from.nodeIndex == to.nodeIndex\n    //   ? this._buffer[from.nodeIndex].chunk.slice(from.index, to.index)\n    //   : Buffer.concat([\n    //       this._buffer[from.nodeIndex].chunk.slice(from.index),\n    //       ...this._buffer.slice(1 + from.nodeIndex, to.nodeIndex).map(node => node.chunk),\n    //       this._buffer[to.nodeIndex].chunk.slice(0, to.index)\n    //     ])\n  }\n}\n\nexport default BufferState\n","import EventEmitter from 'events'\nimport BufferState from 'stream/bufferState'\n//import Schedule from 'schedule'\nimport series from 'series'\n\nconst DEFAULT_HIGHWATERMARK = 64\n// const defaultWatcher = {\n//   cache: {},\n//   currentPattern: null,\n//   arrayOffset: 0,\n//   patternIndex: 0,\n//   byteIndex: 0,\n//   length: 0,\n//   active: false\n// }\n\nfunction decrementActive() {\n  if(!--this._busState.active) {\n    this.emit('inactive')\n  }\n}\n\nfunction _resetWatcher(watcher) {\n  watcher.currentPattern = null\n  watcher.arrayOffset =\n    watcher.patternIndex =\n    watcher.byteIndex =\n    watcher.length = 0\n  watcher.active = false\n\n  return watcher\n\n  // return Object.assign(watcher, defaultWatcher)\n}\n\nfunction _parse() {\n  const {\n    watching,\n    frame,\n    _buffer\n  } = this._busState\n\n  if (!watching.length) {\n    this.emit('error', {\n      msg: 'Unexpected watching data',\n      data: this._busState.buffer()\n    })\n    return\n  }\n\n  if (this._busState.nodeIndex < 0) {\n    this._busState.nodeIndex = 0\n  }\n\n  for (; this._busState.nodeIndex < _buffer.length; this._busState.nodeIndex++) {\n    const {\n      chunk\n    } = _buffer[this._busState.nodeIndex]\n    let currentChunkIndex = 0\n    let currentIncomingWatcherIndex = 0\n    let watcherIndex = 0\n    let isEqual = false\n    let isChunkCorrupted = false\n\n    for (; currentChunkIndex < chunk.length; currentChunkIndex++) {\n      let isChunkCorrupted = false\n      if (!this._busState.active) {\n        this._busState.active = this._busState.watching.reduce((active, watcher) => {\n          const {\n            patterns\n          } = watcher\n          try {\n            watcher.currentPattern = typeof patterns[0] == 'function' ? patterns[0](Buffer.from([])) : patterns[0],\n              watcher.active = true\n            return active + 1\n          } catch (err) {\n            this.emit('error', err)\n            return active\n          }\n        }, 0)\n      }\n\n      const byte = chunk[currentChunkIndex]\n\n      for (watcherIndex = 0; watcherIndex < watching.length; watcherIndex++, isEqual = false) {\n        const watcher = watching[watcherIndex]\n\n        if (!watcher.active) {\n          continue\n        }\n\n        const expected = watcher.currentPattern[watcher.byteIndex]\n\n        // console.log('current watching:', watcher.currentPattern)\n        // console.log('current chunk:', chunk)\n        // console.log('byte:', byte)\n        // console.log('expected:', expected)\n\n        if (expected === undefined || expected === byte) {\n          isEqual = true\n        } else if (Array.isArray(expected)) {\n          if (watcher.arrayOffset <= 0 && expected[0] > 0) {\n            watcher.arrayOffset = expected[0]\n          }\n\n          if (--watcher.arrayOffset > 0) {\n            watcher.length++\n              continue\n          }\n\n          isEqual = true\n        } else if (typeof expected == 'function') {\n          try {\n            isEqual = !!expected.call(this, byte, watcher.length, this._busState.slice(1 + watcher.length))\n          } catch (err) {\n            isEqual = false\n            this.emit('error', err)\n          }\n        }\n\n        if (isEqual) {\n          watcher.length++\n\n          if (++watcher.byteIndex >= watcher.currentPattern.length) {\n            if (++watcher.patternIndex >= watcher.patterns.length) {\n              // console.time( 'buffer' )\n              // console.log(watcher.callback)\n              const chunk = this._busState.buffer(watcher.length)\n              // console.timeEnd( 'buffer' )\n              this._busState.nodeIndex = -1\n              try {\n                // console.time( 'cb' )\n                watcher.callback(\n                  chunk,\n                  // frame.splice(-watcher.length),\n                  watcher.pattern\n                )\n                // console.timeEnd( 'cb' )\n              } catch (err) {\n                this.emit('error', err)\n              }\n              // this._busState.watching = []\n              // console.time( 'reset' )\n              watching.forEach(watcher => {\n                _resetWatcher(watcher)\n                decrementActive.call(this)\n              })\n              // console.timeEnd( 'reset' )\n            } else {\n              // console.time('next pattern')\n              const nextPattern = watcher.patterns[watcher.patternIndex]\n              watcher.byteIndex = 0\n\n              try {\n                if (typeof nextPattern == 'function') {\n                  watcher.currentPattern = nextPattern.call(this, this._busState.slice(watcher.length))\n                } else {\n                  watcher.currentPattern = nextPattern\n                }\n              } catch (err) {\n                _resetWatcher(watcher)\n                decrementActive.call(this)\n                this.emit('error', err)\n              }\n              // console.timeEnd('next pattern')\n            }\n          }\n        } else {\n          _resetWatcher(watcher)\n          decrementActive.call(this)\n\n          if (!this._busState.active) {\n              this.emit('error', {\n                msg: 'Unparsed chunk',\n                data: this._busState.buffer() // frame.splice(0)\n              })\n            //\n            // if(!isChunkCorrupted) {\n            //   isChunkCorrupted = true\n            //   setImmediate(() => {\n            //     isChunkCorrupted = false\n            //     this.emit('error', {\n            //       msg: 'Unparsed chunk',\n            //       data: frame.splice(0)\n            //     })\n            //   })\n            // }\n          }\n        }\n      }\n    }\n  }\n\n  if(this._busState.active) {\n    this.emit('drain')\n  }\n}\n\nfunction _Bus(options = {}) {\n  this.transport = options.transport\n  this.type = options.type\n  this._setup = options.setup.bind(this)\n  this._read = length => options.read.call(this, length === undefined ? length : this.options.highWaterMark)\n  this._write = options.write.bind(this)\n\n  this.options = {\n    highWaterMark: options.highWaterMark || DEFAULT_HIGHWATERMARK\n  }\n\n  this._busState = new BufferState({\n    watching: [],\n    active: 0,\n    nodeIndex: 0,\n    configured: false,\n    ticker: false\n  })\n}\n\n_Bus.prototype = {\n  setup() {\n    if (this._busState.configured) {\n      return Promise.reject('already configured')\n    }\n\n    this._busState.configured = true\n    return this._setup.apply(this, arguments)\n  },\n\n  push(chunk) {\n    if (chunk.length) {\n      this._busState.push(chunk)\n\n      if (!this._busState.ticker) {\n        this._busState.ticker = true\n        setImmediate(() => {\n          this._busState.ticker = false\n          _parse.call(this)\n        })\n      }\n    }\n    // const highWaterMark = this.options.highWaterMark,\n    //       parse = _parse.bind(this)\n    //\n    // if(chunk.length > highWaterMark) {\n    //   const chunks = []\n    //   let subchunkIndex = 0\n    //\n    //   for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\n    //     const subchunk = chunk.slice(offset, offset += highWaterMark)\n    //     chunks.push(subchunk)\n    //   }\n    //\n    //   series(chunks, (next, subchunk) => {\n    //     parse(subchunk)\n    //     next()\n    //   })\n    // }\n    // else {\n    //   parse(chunk)\n    // }\n  },\n\n  watch(patterns, cb) {\n    const watcher = _resetWatcher({\n      patterns,\n      callback: cb.bind(this)\n    })\n\n    this._busState.watching.push(watcher)\n\n    return watcher\n  },\n\n  unwatch(watcher) {\n    if (watcher) {\n      const index = this._busState.watching.indexOf(watcher)\n\n      if (index >= 0) {\n        this._busState.watching.splice(index, 1)\n      }\n    } else {\n      this._busState.watching.splice(0)\n    }\n\n    return this\n  },\n\n  /**\n    @TODO Promise interface\n  */\n\n  rx(patterns, ...args) {\n    let cb, options = {}\n\n    if (typeof args[0] == 'function') {\n      cb = args[0]\n    } else if (typeof args[1] == 'function') {\n      cb = args[1]\n      Object.assign(options, args[0])\n    } else {\n      throw new ReferenceError('Callback is not provided')\n    }\n\n    let watcher\n    const setWatcher = () => {\n      watcher = this.watch(patterns, cb)\n      this._read(this.options.highWaterMark)\n    }\n\n    if ('timeout' in options) {\n      setTimeout(setWatcher, options.timeout)\n    } else {\n      setWatcher()\n    }\n\n    return watcher\n  },\n\n  tx(binary, options = {}) {\n    if ('timeout' in options) {\n      setTimeout(() => {\n        this._write(binary)\n      }, options.timeout)\n    } else {\n      this._write(binary)\n    }\n\n    return this\n  },\n\n  reset() {\n    this._busState.watching.splice(0)\n    return this\n  }\n}\n\nconst Bus = _extend({\n  super: [_Bus, EventEmitter],\n  apply: [_Bus, EventEmitter]\n})\n\nexport default Bus\n","if(typeof console.time !== 'function') {\n  const timers = {}\n\n  console.time = label => {\n    timers[label] = Date.now()\n  }\n\n  console.timeEnd = label => {\n    if(label in timers) {\n      console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\n      delete timers[label]\n    }\n  }\n}\n\nif(typeof console.error !== 'function') {\n  console.error = console.log\n}\n\nexport default console\n","Object.assign = (target, ...args) => {\n  for(let i in args) {\n    const obj = args[i]\n    if(obj instanceof Object) {\n      for(let key in obj) {\n        target[key] = obj[key]\n      }\n    }\n  }\n\n  return target\n}\n\nexport default Object\n","const defProp = (obj, prop, desc) => {\n  try {\n    return Object.defineProperty(obj, prop, desc)\n  } catch(e) {\n    if(desc.get) {\n      obj.value = desc.get()\n    }\n    else if(desc.value) {\n      obj[prop] = desc.value\n    }\n\n    return obj\n  }\n}\n\nexport {\n  defProp\n}\n","import {\n  SUPER_CHAIN_PROTO_PROP,\n  SUPER_CHAIN_APPLY_PROP,\n  PROTOTYPE_IS_EXTENDED_PROP\n} from './props'\n\nconst _copyChain = (Extended, ProtoChain, chainPropName, ignoreExtended) => {\n  //if chain on [Extended] has not been created yet\n  if(!Extended.prototype[chainPropName]) {\n    Object.defineProperty(Extended.prototype, chainPropName, { value: [] })\n  }\n\n  ProtoChain.forEach(Proto => {\n    //console.log(!!Proto.prototype['__extended__'], Proto)\n    //if [Proto] has been '__extended__' and has same-named proto chain, copy the Proto chain to Extended chain\n    const isExtended = !!Proto.prototype[PROTOTYPE_IS_EXTENDED_PROP],\n          hasSameChain = !!Proto.prototype[chainPropName]\n\n    const alreadyInChain = Extended.prototype[chainPropName].some(P => P === Proto),\n          shouldBePushed = (!isExtended || !ignoreExtended) && !alreadyInChain,\n          shouldCopyChain = isExtended && hasSameChain\n\n    if(shouldCopyChain)\n      Proto.prototype[chainPropName].forEach(Proto => {\n        //avoid pushing twice\n        if(!Extended.prototype[chainPropName].some(P => P === Proto) ) {\n          //console.log('pushed', Proto)\n          Extended.prototype[chainPropName].push(Proto)\n        }\n      })\n\n    if(shouldBePushed) {\n      Extended.prototype[chainPropName].push(Proto)\n    }\n  })\n\n  //console.log(Extended.prototype[chainPropName])\n}\n\nconst _extend = (options = {}) => {\n  if(!options.apply)\n    options.apply = []\n  if(!options.super)\n    options.super = []\n  if(!options.static)\n    options.static = []\n\n  const Child = options.super[0]\n\n  if(!options.name)\n    options.name = Child.name\n\n  function Extended() {\n    Extended.prototype[SUPER_CHAIN_APPLY_PROP].forEach(Super => {\n      if(Super !== Extended) {\n        Super.apply(this, arguments)\n      }\n    })\n  }\n\n  _named(options.name, Extended)\n\n  for(let i in options.static) {\n    for(let prop in options.static[i]) {\n      if('prototype' != prop) {\n        Object.defineProperty(Extended, prop, {\n          value: proto[prop],\n          enumerable: true,\n          writable: true\n        })\n      }\n    }\n  }\n\n  Extended.prototype = {}\n  Extended.prototype.constructor = Child\n  Extended.prototype[PROTOTYPE_IS_EXTENDED_PROP] = true\n\n  for(let i in options.super) {\n    function Proto() {}\n    Proto.prototype = options.super[i].prototype\n    const proto = new Proto()\n\n    for(let prop in proto) {\n      if(['constructor', PROTOTYPE_IS_EXTENDED_PROP, SUPER_CHAIN_PROTO_PROP, SUPER_CHAIN_APPLY_PROP].indexOf(prop) < 0) {\n        Object.defineProperty(Extended.prototype, prop, {\n          value: proto[prop],\n          enumerable: true,\n          writable: true\n        })\n      }\n    }\n  }\n\n  _copyChain(Extended, options.super, SUPER_CHAIN_PROTO_PROP, false)\n  _copyChain(Extended, options.apply, SUPER_CHAIN_APPLY_PROP, true)\n\n  return Extended\n}\n\nexport const extend = (...args) => _extend({ super: args.slice(1), apply: args })\n\nexport { _extend, _copyChain }\n","Array.prototype.concat = function () {\n  const concatenated = []\n\n  for(let i in this) {\n    concatenated.push(this[i])\n  }\n\n  for(let i in arguments) {\n    for(let j in arguments[i]) {\n      concatenated.push(arguments[i][j])\n    }\n  }\n\n  return concatenated\n}\n\nexport default Array\n","// var PENDING = 'pending'\n// var SEALED = 'sealed'\n// var FULFILLED = 'fulfilled'\n// var REJECTED = 'rejected'\n//\n// var NOOP = function() {}\n//\n// function invokeResolver(resolver, promise) {\n//   function resolvePromise(value) {\n//     resolve(promise, value)\n//   }\n//\n//   function rejectPromise(reason) {\n//     reject(promise, reason)\n//   }\n//\n//   try {\n//     resolver(resolvePromise, rejectPromise)\n//   } catch(e) {\n//     rejectPromise(e)\n//   }\n// }\n//\n// function invokeCallback(subscriber) {\n//   var owner = subscriber.owner\n//   var settled = owner.state_\n//   var value = owner.data_\n//   var callback = subscriber[settled]\n//   var promise = subscriber.then\n//\n//   if (typeof callback === 'function')\n//   {\n//     settled = FULFILLED\n//     try {\n//       value = callback(value)\n//     } catch(e) {\n//       reject(promise, e)\n//     }\n//   }\n//\n//   if (!handleThenable(promise, value))\n//   {\n//     if (settled === FULFILLED)\n//       resolve(promise, value)\n//\n//     if (settled === REJECTED)\n//       reject(promise, value)\n//   }\n// }\n//\n// function handleThenable(promise, value) {\n//   var resolved\n//\n//   try {\n//     if (promise === value)\n//       throw new TypeError('A promises callback cannot return that same promise.')\n//\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\n//     {\n//       var then = value.then  // then should be retrived only once\n//\n//       if (typeof then === 'function')\n//       {\n//         then.call(value, function(val){\n//           if (!resolved)\n//           {\n//             resolved = true\n//\n//             if (value !== val)\n//               resolve(promise, val)\n//             else\n//               fulfill(promise, val)\n//           }\n//         }, function(reason){\n//           if (!resolved)\n//           {\n//             resolved = true\n//\n//             reject(promise, reason)\n//           }\n//         })\n//\n//         return true\n//       }\n//     }\n//   } catch (e) {\n//     if (!resolved)\n//       reject(promise, e)\n//\n//     return true\n//   }\n//\n//   return false\n// }\n//\n// function resolve(promise, value){\n//   if (promise === value || !handleThenable(promise, value))\n//     fulfill(promise, value)\n// }\n//\n// function publish(promise) {\n//   var callbacks = promise.then_\n//   promise.then_ = undefined\n//\n//   for (var i = 0 i < callbacks.length i++) {\n//     invokeCallback(callbacks[i])\n//   }\n// }\n//\n// function fulfill(promise, value){\n//   if (promise.state_ === PENDING)\n//   {\n//     promise.state_ = SEALED\n//     promise.data_ = value\n//\n//     setImmediate(() => {\n//       promise.state_ = FULFILLED\n//       publish(promise)\n//     })\n//   }\n// }\n//\n// function reject(promise, reason){\n//   if (promise.state_ === PENDING)\n//   {\n//     promise.state_ = SEALED\n//     promise.data_ = reason\n//\n//     setImmediate(() => {\n//       promise.state_ = REJECTED\n//       publish(promise)\n//     })\n//   }\n// }\n//\n// function Promise(resolver) {\n//   if (typeof resolver !== 'function')\n//     throw new TypeError('Promise constructor takes a function argument')\n//\n//   if (this instanceof Promise === false)\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\n//\n//   this.then_ = []\n//\n//   invokeResolver(resolver, this)\n// }\n//\n// Promise.prototype = {\n//   constructor: Promise,\n//\n//   state_: PENDING,\n//   then_: null,\n//   data_: undefined,\n//\n//   then: function(onFulfillment, onRejection){\n//     var subscriber = {\n//       owner: this,\n//       then: new this.constructor(NOOP),\n//       fulfilled: onFulfillment,\n//       rejected: onRejection\n//     }\n//\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\n//     {\n//       // already resolved, call callback async\n//       setImmediate(() => {invokeCallback(subscriber)})\n//     }\n//     else\n//     {\n//       // subscribe\n//       this.then_.push(subscriber)\n//     }\n//\n//     return subscriber.then\n//   },\n//\n//   'catch': function(onRejection) {\n//     return this.then(null, onRejection)\n//   }\n// }\n\n// Promise.all = function(promises) {\n//   if (!(promises instanceof Array)) {\n//     throw new TypeError('You must pass an array to Promise.all().')\n//   }\n//\n//   return new Promise((resolve, reject) => {\n//     var results = []\n//     var remaining = 0\n//\n//     function resolver(index) {\n//       remaining++\n//       return function(value) {\n//         results[index] = value\n//         if (!--remaining) {\n//           resolve(results)\n//         }\n//       }\n//     }\n//\n//     for (var i = 0, promise; i < promises.length; i++) {\n//       promise = promises[i]\n//\n//       if (promise && typeof promise.then === 'function') {\n//         promise.then(resolver(i), reject)\n//       }\n//       else {\n//         results[i] = promise\n//       }\n//     }\n//\n//     if (!remaining) {\n//       resolve(results)\n//     }\n//   })\n// }\n\nPromise.race = function(promises){\n  var Class = this\n\n  if (!(promises instanceof Array))\n    throw new TypeError('You must pass an array to Promise.race().')\n\n  return new Class((resolve, reject) => {\n    for (var i = 0, promise; i < promises.length; i++)\n    {\n      promise = promises[i]\n\n      if (promise && typeof promise.then === 'function')\n        promise.then(resolve, reject)\n      else\n        resolve(promise)\n    }\n  })\n}\n\n// Promise.resolve = function(value) {\n//   var Class = this\n//\n//   if (value && typeof value === 'object' && value.constructor === Class)\n//     return value\n//\n//   return new Class(function(resolve){\n//     resolve(value)\n//   })\n// }\n//\n// Promise.reject = function(reason){\n//   var Class = this\n//\n//   return new Class(function(resolve, reject){\n//     reject(reason)\n//   })\n// }\n//\n\nexport default Promise\n","const PUSH_TO_QUEUE_IMMEDIATE = 0,\n      PUSH_AT_NEXT_STAGE = 1,\n      loop = [\n        // nextTick\n        { queue: [], immediatePush: true, tick: false },\n        // immediate\n        { queue: [], immediatePush: true, tick: false },\n        // timeout\n        { queue: [], immediatePush: false, tick: false }\n      ]\n\nlet tick = false,\n    timers = {}\n\nconst asyncFlush = () => {\n  for (let stage in loop) {\n    if(loop[stage].queue.length) {\n      if(loop[stage].immediatePush) {\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\n          loop[stage].queue[exec]()\n        }\n        loop[stage].queue.splice(0)\n      } else {\n        const queue = loop[stage].queue.splice(0)\n        for (let exec = 0; exec < queue.length; exec ++) {\n          queue[exec]()\n        }\n      }\n    }\n\n    loop[stage].tick = tick = false\n  }\n}\n\nconst asyncCall = stage => cb => {\n  loop[stage].queue.push(cb)\n\n  if (!tick && !loop[stage].tick) {\n    loop[stage].tick = tick = true\n\n    setTimeout(asyncFlush)\n  }\n}\n\nconst nextTick = asyncCall(/* .nextTick */0)\n\nconst setImmediate = asyncCall(/* .immediate */1)\n\nconst timeoutCall = asyncCall(/* .timeeout */2)\n\nexport const _setTimeout = (cb, timeout) => {\n  // let index = 0\n  // while(timers[index]) {\n  //   index++\n  // }\n  // timers[index] = setTimeout(() => {\n  //   if(timers[index]) {\n  //     delete timers[index]\n  //     timeoutCall(cb)\n  //   }\n  // }, timeout)\n  //\n  // return index\n\n  return setTimeout(() => {\n    timeoutCall(cb)\n  }, timeout)\n}\n\nexport const _setInterval = (cb, timeout) => {\n  return (function setTimer() {\n    return _setTimeout(() => {\n      setTimer()\n      cb()\n    }, timeout)\n  })()\n}\n\nexport {\n  nextTick,\n  setImmediate,\n  _setTimeout as setTimeout,\n  _setInterval as setInterval\n}\n","import Bus from 'bus'\n\nconst preamble = [1, 2, 3]\nconst postamble = [4, (...args) => {\n  console.log(args)\n  return true\n}, 6]\n\nconst bus = new Bus({ read() {}, write() {}, setup() {} })\n\nbus.on('error', console.error)\n\nbus.rx([\n  preamble,\n  postamble\n], console.log)\n\nbus.push(preamble)\n\n// // import Bus from 'bus'\n// // import Schedule from 'schedule'\n// import * as Blink from 'blink'\n// import {\n//   command,\n//   ACK,\n//   NACK,\n//   INFO,\n//   XINFO\n// } from 'nfc'\n// import Bus from 'nfc/bus'\n// import {\n//   PN532_I2C_ADDRESS,\n//   PN532_COMMAND_SAMCONFIGURATION,\n//   PN532_SAM_NORMAL_MODE,\n//   PN532_COMMAND_WRITEGPIO,\n//   PN532_COMMAND_INLISTPASSIVETARGET,\n//   PN532_COMMAND_INDATAEXCHANGE,\n//   PN532_COMMAND_GETFIRMWAREVERSION,\n//   PN532_COMMAND_WAKEUP,\n//   MIFARE_COMMAND_READ_16,\n//   MIFARE_COMMAND_AUTH_A,\n//   MIFARE_COMMAND_AUTH_B,\n//   MIFARE_COMMAND_WRITE_4,\n//   MIFARE_COMMAND_WRITE_16\n// } from 'nfc/constants'\n//\n// import {\n//   encodeMessage,\n//   decodeMessage,\n//   textRecord\n// } from 'esp-ndef'\n//\n// // let usbConsole = true\n// // let consoleBus = null\n// // let log = ''\n// //\n// //\n// // function toggleConsole() {\n// //   usbConsole = !usbConsole\n// //   if (usbConsole) {\n// //     consoleBus = null\n// //     USB.removeAllListeners()\n// //   } else {\n// //     consoleBus = new Bus({\n// //       setup() {\n// //         USB.on('data', data => {\n// //           this.parse.call(this, data)\n// //           USB.setup()\n// //           // USB.write(Buffer.from(['!', ...[].slice.call(data, 0)]))\n// //         })\n// //       },\n// //       read() {},\n// //       write() {}\n// //     })\n// //\n// //     consoleBus.rx([Buffer.from('/on')], () => {\n// //       Blink.once(LED1)\n// //       USB.write(JSON.stringify(consoleBus._busState))\n// //       // toggleConsole()\n// //     })\n// //\n// //     // consoleBus.rx([Buffer.from('/off')], () => {\n// //     //   LED1.write(1)\n// //     //   // USB.write('/off\\r\\n')\n// //     //   // toggleConsole()\n// //     // })\n// //     //\n// //     // consoleBus.on('error', err => {\n// //     //   Blink.once(LED1, 200)\n// //     // })\n// //\n// //     consoleBus.setup()\n// //   }\n// //\n// //   usbConsole ?\n// //     USB.setConsole(false) :\n// //     LoopbackA.setConsole(false)\n// // }\n// //\n// // toggleConsole()\n//\n// // setWatch( toggleConsole, BTN1, {\n// //   repeat: true,\n// //   edge: 'rising',\n// //   debounce: 50\n// // } )\n// //\n// // Blink.start( LED2 )\n// //\n// // const encoded = encodeMessage( [\n// //   textRecord( '2enhello world!' )\n// // ] )\n// //\n// // import fs from 'fs'\n//\n// const wakeup = command([PN532_COMMAND_WAKEUP])\n// const sam = command([PN532_COMMAND_SAMCONFIGURATION, PN532_SAM_NORMAL_MODE, 20, 0])\n//\n// // [0, 0, 255, 0, 255, 0]\n// // [0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0]\n//\n// // [0, 0, 255, 0, 255, 0, 2, 42, 1, 6, 7, 232, 0, 0, 0, ]\n//\n// // [1, 0, 0, 255, 0, 255, 0, 2, 42, 0, 0, 0, 0, 0, 0, 0]\n// // [1, 0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0, 0, 0]\n//\n// function setup() {\n//   if(this.type == 'serial') {\n//     this.transport.setup(115200)\n//\n//     this.transport.write(wakeup)\n//     this.transport.write(sam)\n//\n//     setTimeout(() => {\n//       this.transport.on('data', data => this.push(data))\n//       console.log('Bus has been set up')\n//       Blink.once(LED1, 20, () => {\n//         setTimeout(() => Blink.once(LED1, 20), 200)\n//       })\n//\n//       this.rx([\n//         ...ACK,\n//         ...INFO\n//       ], frame => {\n//         console.log('frame')\n//         console.log(frame)\n//       })\n//\n//       this.tx(command([PN532_COMMAND_GETFIRMWAREVERSION]))\n//     }, 500)\n//   } else if (this.type == 'i2c') {\n//     this.transport.setup({ bitrate: 400*1000 })\n//\n//     this.on('drain', () => {\n//       this._read()\n//     })\n//\n//     try {\n//       this.tx(1)\n//     } catch(err) {\n//       console.log('Handled', err.msg)\n//       console.log('Continue...')\n//     }\n//\n//     this.tx(command([PN532_COMMAND_GETFIRMWAREVERSION]))\n//\n//     this.rx([\n//       ...ACK,\n//       ...INFO\n//     ], { timeout: 10 }, frame => {\n//       console.log('frame')\n//       console.log(frame)\n//     })\n//   }\n// }\n//\n// const bus = new Bus({\n//   transport: Serial1,\n//   type: 'serial',\n//   setup,\n//   read(length) {\n//     if(this.type == 'i2c') {\n//       while(true) {\n//         if(this.transport.readFrom(PN532_I2C_ADDRESS, 1)[0]) {\n//           const chunk = this.transport.readFrom(PN532_I2C_ADDRESS, 1 + length)\n//           this.push(chunk)\n//         } else {\n//           break\n//         }\n//       }\n//     } else if(this.type == 'serial') {\n//       // const chunk = this.transport.read(length)\n//       // this.push(chunk)\n//     }\n//   },\n//   write(chunk) {\n//     if(this.type == 'serial') {\n//       this.transport.write(chunk)\n//     } else if(this.type == 'i2c') {\n//       this.transport.writeTo(PN532_I2C_ADDRESS, chunk)\n//     }\n//   },\n//   highWaterMark: 16\n// })\n//\n// bus.on('error', err => {\n//   console.error('BusError:', err)\n// })\n//\n// bus.setup()\n//\n// // const key = new Uint8  Array(Array(6).fill(0xff))\n//\n// // console.log(key)\n//\n//\n// // setTimeout(() => {\n// //   (function poll() {\n// //     // console.log(process.memory().free)\n// //     // console.log(bus._busState.watching.length)\n// //     Promise.resolve()\n// //       .then(() => bus.findTargets(1, 'A')) // .then(data => { console.log('found card', data.uid); return data })\n// //       .then(data => {\n// //         LED1.write(0)\n// //         return data\n// //       })\n// //       // .then(data => bus.authenticate(4, data.uid, key).then(data => { console.log('auth op 4:', data) }).then(() => bus.authenticate(3, data.uid, key).then(data => { console.log('auth op:', data) })))\n// //       .then(data => bus.authenticate(1 * 4, data.uid, key)) // .then(data => { console.log('auth', data) })\n// //       // .then(data => bus.writeBlock(4, [1, 3, 6, 4])).then(data => { console.log('write op:', data) })\n// //       // .then(data => { console.time('reading 2 sector'); return data })\n// //       .then(data => bus.readSector(1))\n// //       .then(data => {\n// //         LED1.write(1)\n// //         return data\n// //       }) // .then(data => { console.log('sector 2:', data); return data })\n// //       .then(data => data.reduce((buffer, data) => [...buffer, ...[].slice.call(data.chunk, 0)], []))\n// //       .then(console.log)\n// //       // .then(data => { console.timeEnd('reading 2 sector'); return data })\n// //       // .then(data => bus.readBlock(4)).then(data => { console.log('block 4:', data) })\n// //       // .then(data => bus.readBlock(5)).then(data => { console.log('block 5:', data) })\n// //       // .then(data => bus.readBlock(6)).then(data => { console.log('block 6:', data) })\n// //       // .then(data => bus.readBlock(7)).then(data => { console.log('block 7:', data) })\n// //       .catch(err => {\n// //         LED1.write(1)\n// //         console.error('Error:', err)\n// //       })\n// //       .then(() => {\n// //         setTimeout(() => {\n// //           poll()\n// //         }, 500)\n// //       })\n// //   })()\n// // }, 1000)\n","export default (name, f) => {\n  defProp(f, 'name', { value: name })\n  //defProp(f, 'toString', { value: () => '[Function' + (f.name !== undefined ? ': ' + f.name : '') + ']' })\n\n  return f\n}\n"],"names":["Buffer","Error","EventEmitter","_listeners","_duplicateEvent","event","this","BufferState","options","assign","decrementActive","_busState","active","emit","_resetWatcher","watcher","currentPattern","arrayOffset","patternIndex","byteIndex","length","_Bus","transport","type","_setup","setup","bind","_read","read","call","undefined","_this2","highWaterMark","_write","write","DEFAULT_HIGHWATERMARK","console","time","timers","label","Date","now","timeEnd","log","toFixed","error","Object","target","args","i","obj","key","_copyChain","Extended","ProtoChain","chainPropName","ignoreExtended","prototype","defineProperty","value","forEach","isExtended","Proto","PROTOTYPE_IS_EXTENDED_PROP","hasSameChain","alreadyInChain","some","P","shouldBePushed","push","concat","concatenated","arguments","j","Promise","race","promises","Array","TypeError","resolve","reject","promise","then","from","iterable","offset","parsed","c","charCodeAt","Uint8Array","ArrayBuffer","slice","_list","_totalLength","list","totalLength","reduce","array","buffer","buf","set","loop","queue","immediatePush","tick","asyncFlush","stage","exec","splice","asyncCall","cb","setImmediate","listener","on","removeListener","_listener","apply","chunk","node","_buffer","next","unshift","count","nodes","_this","index","nodeIndex","to","callee","firstNode","lastNode","at","configured","ticker","watching","frame","currentChunkIndex","watcherIndex","isEqual","patterns","err","byte","expected","isArray","callback","pattern","nextPattern","indexOf","ReferenceError","setWatcher","_this4","watch","timeout","binary","preamble","postamble","bus","SUPER_CHAIN_APPLY_PROP","Super","super","static","Child","name","prop","desc","e","get","proto","constructor","SUPER_CHAIN_PROTO_PROP","_extend","rx"],"mappings":"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"}