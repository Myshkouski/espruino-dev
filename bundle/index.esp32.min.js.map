{"version":3,"file":"index.esp32.min.js","sources":["../globals/buffer.js","../lib/events.js","../lib/stream/bufferState.js","../lib/bus.js","../lib/nfc/bus.js","../globals/console.js","../globals/array.js","../globals/promise.js","../globals/arrayBuffer.js","../globals/object.js","../lib/blink.js","../globals/extend/index.js","../globals/namedFunction.js","../globals/event-loop.js","../lib/nfc/frames.js","../helpers/series.js","../src/index.js"],"sourcesContent":["// import Uint8Array from './Uint8Array'\r\n// import { toBuffer } from './utils/to'\r\n\r\n// function copy(target) {\r\n// \tconst targetStart \t= arguments[1] !== undefined ? arguments[1] : 0,\r\n// \t\t\t\tsourceStart \t= arguments[2] !== undefined ? arguments[2] : 0,\r\n// \t\t\t\tsourceEnd \t\t= arguments[3] !== undefined ? arguments[3] : source.length\r\n//\r\n// \tlet copied = 0\r\n//\r\n// \tfor(let sourceIndex = sourceStart, targetIndex = targetStart; sourceIndex < sourceEnd; sourceIndex++, targetIndex++, copied++)\r\n// \t\ttarget.set([ this[sourceIndex] ], targetIndex)\r\n//\r\n// \treturn copied\r\n// }\r\n\r\nfunction Buffer() {\r\n  throw new Error( 'Buffer constructor is deprecated. Use Buffer.from() instead.' )\r\n}\r\n\r\nBuffer.from = ( iterable, offset, length ) => {\r\n  if ( typeof iterable == 'string' ) {\r\n    const parsed = []\r\n\r\n    for ( let c in iterable ) {\r\n      parsed[ c ] = iterable.charCodeAt( c )\r\n    }\r\n\r\n    return new Uint8Array( parsed )\r\n  } else if ( iterable instanceof ArrayBuffer ) {\r\n    return new Uint8Array( iterable.slice( offset !== undefined ? offset : 0, offset + ( length !== undefined ? length : iterable.length ) ) )\r\n  } else if ( iterable instanceof Array || iterable instanceof Uint8Array ) {\r\n    return new Uint8Array( iterable )\r\n  } else {\r\n    throw new TypeError( 'Cannot create buffer from', typeof iterable )\r\n  }\r\n}\r\n\r\nBuffer.concat = ( _list, _totalLength ) => {\r\n  const list = _list || [],\r\n    totalLength = _totalLength !== undefined ? _totalLength : list.reduce( ( totalLength, array ) => totalLength + array.length, 0 ),\r\n    buffer = Buffer.from( [], 0, totalLength )\r\n\r\n  list.reduce( ( offset, buf ) => {\r\n    buffer.set( buf, offset )\r\n    return offset + buf.length\r\n  }, 0 )\r\n\r\n  return buffer\r\n}\r\n\r\nexport default Buffer\r\n","function EventEmitter() {\r\n  this._listeners = {}\r\n}\r\n\r\n//_named('EventEmitter', EventEmitter)\r\n\r\nfunction _duplicateEvent(event) {\r\n  if(event) {\r\n    if(`#${ event }` in this) {\r\n      this._listeners[event] = this[`#${ event }`]\r\n    } else {\r\n      delete this._listeners[event]\r\n    }\r\n  }\r\n}\r\n\r\nEventEmitter.prototype = {\r\n  on(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n\r\n    // this._listeners[event]\r\n    //   ? this._listeners[event].push(listener)\r\n    //   : this._listeners[event] = [listener]\r\n\r\n    return this\r\n  },\r\n\r\n  removeListener(event, listener) {\r\n    Object.prototype.on.call(this, event, listener)\r\n    _duplicateEvent.call(this, event)\r\n    // if(!event) {\r\n    //   this._listeners = {}\r\n    // } else {\r\n    //   if(listener && this._listeners[event]) {\r\n    //     const index = this._listeners[event].indexOf(listener)\r\n    //\r\n    //     if(~index) {\r\n    //       this._listeners[event].splice(index, 1)\r\n    //     }\r\n    //   }\r\n    //\r\n    //   if(!listener || !this._listeners[event]) {\r\n    //     delete this._listeners[event]\r\n    //   }\r\n    // }\r\n    return this\r\n  },\r\n\r\n  once(event, listener) {\r\n    function once() {\r\n      this.removeListener(event, _listener)\r\n      return listener.apply(this, arguments)\r\n    }\r\n\r\n    return this.on(event, once)\r\n  }\r\n}\r\n\r\nexport default EventEmitter\r\n","function BufferState( options = {} ) {\r\n  Object.assign( this, {\r\n    _buffer: [],\r\n    length: 0\r\n  }, options )\r\n}\r\n\r\nBufferState.prototype = {\r\n  push( chunk ) {\r\n    if ( chunk.length ) {\r\n      const node = {\r\n        chunk: Buffer.from( chunk ),\r\n        encoding: 'binary',\r\n        next: null\r\n      }\r\n\r\n      if ( this._buffer.length ) {\r\n        this._buffer[ this._buffer.length - 1 ].next = node\r\n      }\r\n\r\n      this._buffer.push( node )\r\n      this.length += node.chunk.length\r\n    }\r\n\r\n    return this.length\r\n  },\r\n\r\n  unshift( chunk ) {\r\n    const node = {\r\n      chunk: Buffer.from( chunk ),\r\n      encoding: 'binary',\r\n      next: null\r\n    }\r\n\r\n    if ( this._buffer.length ) {\r\n      node.next = this._buffer[ 0 ]\r\n    }\r\n\r\n    this._buffer.unshift( node )\r\n    this.length += node.chunk.length\r\n\r\n    return this.length\r\n  },\r\n\r\n  nodes( count ) {\r\n    const nodes = this._buffer.splice( 0, count )\r\n    nodes.forEach( node => this.length -= node.chunk.length )\r\n\r\n    return nodes\r\n  },\r\n\r\n  at( index ) {\r\n    if ( index >= this.length || index < 0 ) {\r\n      return\r\n    }\r\n\r\n    for ( let nodeIndex = 0; nodeIndex < this._buffer.length; nodeIndex++ ) {\r\n      const chunk = this._buffer[ nodeIndex ].chunk\r\n      if ( index < chunk.length ) {\r\n        return {\r\n          index,\r\n          nodeIndex,\r\n          value: chunk[ index ]\r\n        }\r\n      }\r\n\r\n      index -= chunk.length\r\n    }\r\n  },\r\n\r\n  for ( from, to, callee ) {\r\n    const firstNode = this._buffer[ from.nodeIndex ]\r\n    for ( let index = from.nodeIndex; index < firstNode.chunk.length; index++ ) {\r\n      callee.call( this, firstNode.chunk[ index ] )\r\n    }\r\n\r\n    for ( let nodeIndex = 1 + from.nodeIndex; nodeIndex < to.nodeIndex; nodeIndex++ ) {\r\n      const node = this._buffer[ nodeIndex ]\r\n      for ( let index = 0; index < node.chunk.length; index++ ) {\r\n        callee.call( this, node.chunk[ index ] )\r\n      }\r\n    }\r\n\r\n    if ( from.nodeIndex < to.nodeIndex ) {\r\n      const lastNode = this._buffer[ to.nodeIndex ]\r\n      for ( let index = 0; index <= to.index; index++ ) {\r\n        callee.call( this, lastNode.chunk[ index ] )\r\n      }\r\n    }\r\n  },\r\n\r\n  slice( length ) {\r\n    if ( length === undefined ) {\r\n      length = this.length\r\n    }\r\n\r\n    if ( !length ) {\r\n      return Buffer.from( [] )\r\n    }\r\n\r\n    if ( length > this.length ) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if ( length ) {\r\n      to = this.at( length )\r\n    }\r\n\r\n    if ( !to ) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n\r\n    const buffer = Buffer.from( Array( length ) )\r\n\r\n    const offset = this._buffer.slice( to.nodeIndex - 1 )\r\n      .reduce( ( offset, node ) => {\r\n        buffer.set( node.chunk, offset )\r\n        return offset + node.chunk.length\r\n      }, 0 )\r\n\r\n    if ( offset < length ) {\r\n      const node = this._buffer[ to.nodeIndex ]\r\n\r\n      buffer.set( node.chunk.slice( 0, length - offset ), offset )\r\n    }\r\n\r\n    return buffer\r\n  },\r\n\r\n  buffer( length ) {\r\n    if ( length === undefined ) {\r\n      length = this.length\r\n    }\r\n\r\n    if ( !length ) {\r\n      return Buffer.from( [] )\r\n    }\r\n\r\n    if ( length > this.length ) {\r\n      length = this.length\r\n    }\r\n\r\n    let to\r\n\r\n    if ( length ) {\r\n      // console.time('at')\r\n      to = this.at( length )\r\n      // console.timeEnd('at')\r\n    }\r\n\r\n    if ( !to ) {\r\n      to = {\r\n        index: this.length - 1,\r\n        nodeIndex: this._buffer.length - 1\r\n      }\r\n    }\r\n    // console.time('from')\r\n    const buffer = Buffer.from( Array( length ) )\r\n    // console.timeEnd('from')\r\n    // console.time('offset')\r\n\r\n    // console.timeEnd('buffer')\r\n\r\n    const offset = this.nodes( to.nodeIndex )\r\n      .reduce( ( offset, node ) => {\r\n        buffer.set( node.chunk, offset )\r\n        return offset + node.chunk.length\r\n      }, 0 )\r\n    // console.timeEnd('offset')\r\n\r\n    if ( offset < length ) {\r\n      const node = this.nodes( 1 )[ 0 ]\r\n\r\n      buffer.set( node.chunk.slice( 0, length - offset ), offset )\r\n      if ( length - offset < node.chunk.length ) {\r\n        node.chunk = node.chunk.slice( length - offset )\r\n\r\n        this.unshift( node.chunk )\r\n      }\r\n    }\r\n\r\n    return buffer\r\n  }\r\n}\r\n\r\nexport default BufferState\r\n","import EventEmitter from 'events'\r\nimport BufferState from 'stream/bufferState'\r\n//import Schedule from 'schedule'\r\nimport series from 'series'\r\n\r\nconst DEFAULT_HIGHWATERMARK = 64\r\n\r\nfunction _resetWatcher( watcher ) {\r\n  return Object.assign( watcher, {\r\n    active: false,\r\n    currentPattern: null,\r\n    length: 0,\r\n    offset: 0,\r\n    byteIndex: 0,\r\n    patternIndex: 0\r\n  } )\r\n}\r\n\r\nfunction _resetActive() {\r\n  this._busState.active = 0\r\n  this.emit( 'inactive' )\r\n}\r\n\r\nfunction _decrementActive() {\r\n  if ( !--this._busState.active ) {\r\n    this.emit( 'inactive' )\r\n  }\r\n}\r\n\r\nfunction _found( watcher ) {\r\n  const {\r\n    _busState\r\n  } = this\r\n  const {\r\n    watching\r\n  } = _busState\r\n  const chunk = _busState.buffer( watcher.length )\r\n  _busState.nodeIndex = -1\r\n  try {\r\n    // console.time( 'cb' )\r\n    watcher.callback(\r\n      chunk,\r\n      // frame.splice(-watcher.length),\r\n      watcher\r\n    )\r\n    // console.timeEnd( 'cb' )\r\n  } catch ( err ) {\r\n    this.emit( 'error', err )\r\n  }\r\n  // _busState.watching = []\r\n  // console.time( 'reset' )\r\n  watching.forEach( _resetWatcher )\r\n  _resetActive.call( this )\r\n  // console.timeEnd( 'reset' )\r\n}\r\n\r\nfunction _nextPattern( watcher ) {\r\n  if ( 1 + watcher.patternIndex < watcher.list.length ) {\r\n    // console.time('next pattern')\r\n    const nextPattern = watcher.list[ ++watcher.patternIndex /* patternIndex has already been incremented when checked condition */ ]\r\n    watcher.byteIndex = 0\r\n\r\n    if ( typeof nextPattern == 'function' ) {\r\n      try {\r\n        watcher.currentPattern = nextPattern.call( this, this._busState.slice( 1 + watcher.length ) )\r\n      } catch ( err ) {\r\n        _resetWatcher( watcher )\r\n        _decrementActive.call( this )\r\n        this.emit( 'error', err )\r\n      }\r\n    } else {\r\n      watcher.currentPattern = nextPattern\r\n    }\r\n    // console.timeEnd('next pattern')\r\n  } else {\r\n    _found.call( this, watcher )\r\n  }\r\n}\r\n\r\nfunction _push() {\r\n  // console.log( '_push()' )\r\n  const {\r\n    _busState\r\n  } = this\r\n  const {\r\n    watching,\r\n    _buffer\r\n  } = _busState\r\n\r\n  for ( ; _busState.nodeIndex < _buffer.length; _busState.nodeIndex++ ) {\r\n    if ( !watching.length ) {\r\n      this.emit( 'error', {\r\n        msg: 'Unexpected incoming data',\r\n        data: _busState.buffer()\r\n      } )\r\n      return\r\n    }\r\n\r\n    if ( _busState.nodeIndex < 0 ) {\r\n      _busState.nodeIndex = 0\r\n    }\r\n\r\n    const {\r\n      chunk\r\n    } = _buffer[ _busState.nodeIndex ]\r\n    let currentChunkIndex = 0\r\n    let currentIncomingWatcherIndex = 0\r\n    let watcherIndex = 0\r\n    let isEqual = false\r\n    let isChunkCorrupted = false\r\n\r\n    if ( !_busState.active ) {\r\n      _busState.active = _busState.watching.reduce( ( active, watcher ) => {\r\n        const {\r\n          list\r\n        } = watcher\r\n        try {\r\n          watcher.currentPattern = typeof list[ 0 ] == 'function' ? list[ 0 ].call( this, _busState.slice( watcher.length ) ) : list[ 0 ]\r\n          watcher.active = true\r\n          return 1 + active\r\n        } catch ( err ) {\r\n          this.emit( 'error', err )\r\n          return active\r\n        }\r\n      }, 0 )\r\n    }\r\n\r\n    for ( ; currentChunkIndex < chunk.length; currentChunkIndex++ ) {\r\n      let isChunkCorrupted = false\r\n      const byte = chunk[ currentChunkIndex ]\r\n\r\n      for ( watcherIndex = 0; watcherIndex < watching.length; watcherIndex++, isEqual = false ) {\r\n        const watcher = watching[ watcherIndex ]\r\n        if ( !watcher.active ) {\r\n          continue\r\n        }\r\n\r\n        const {\r\n          currentPattern\r\n        } = watcher\r\n\r\n        if ( Array.isArray( currentPattern ) || ArrayBuffer.isView( currentPattern ) ) {\r\n          const expected = currentPattern[ watcher.byteIndex ]\r\n\r\n          if ( expected === undefined || ( typeof expected == 'number' && expected === byte ) ) {\r\n            isEqual = true\r\n          } else if ( typeof expected == 'function' ) {\r\n            try {\r\n              isEqual = !!expected.call( this, byte, watcher.length - 1 /*i.e. index*/ , _busState.slice( 1 + watcher.length /*i.e. actual length*/ ) )\r\n            } catch ( err ) {\r\n              this.emit( 'error', err )\r\n            }\r\n          }\r\n\r\n          // if ( !isEqual ) {\r\n          //   console.log( 'current watching:', watcher.currentPattern )\r\n          //   console.log( 'current chunk:', chunk )\r\n          //   console.log( 'byte:', byte )\r\n          //   console.log( 'expected:', expected )\r\n          // }\r\n\r\n          if ( isEqual ) {\r\n            ++watcher.length\r\n\r\n            if ( 1 + watcher.byteIndex < currentPattern.length ) {\r\n              ++watcher.byteIndex\r\n            } else {\r\n              _nextPattern.call( this, watcher )\r\n            }\r\n          } else {\r\n            _resetWatcher( watcher )\r\n            _decrementActive.call( this )\r\n\r\n            // console.log( 'active', _busState.active )\r\n\r\n            if ( !_busState.active ) {\r\n              this.emit( 'error', {\r\n                message: 'Unparsed chunk',\r\n                expected,\r\n                actual: byte,\r\n                pattern: currentPattern,\r\n                chunk: _busState.buffer(),\r\n                index: currentChunkIndex,\r\n                value: byte\r\n              } )\r\n            }\r\n\r\n            // break\r\n          }\r\n        } else if ( typeof currentPattern == 'number' ) {\r\n          if ( currentPattern <= 0 ) {\r\n            throw Object.assign( new ReferenceError( 'Pattern length should be a positive integer' ), {\r\n              pattern: currentPattern\r\n            } )\r\n          }\r\n\r\n          if ( watcher.offset <= 0 ) {\r\n            watcher.offset = currentPattern\r\n          }\r\n\r\n          watcher.length++\r\n\r\n            if ( --watcher.offset < 1 ) {\r\n              _nextPattern.call( this, watcher )\r\n            }\r\n        } else {\r\n          throw new TypeError( `Cannot parse pattern of ${ typeof currentPattern } type` )\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if ( _busState.active ) {\r\n    this.emit( 'drain' )\r\n  }\r\n}\r\n\r\nfunction _Bus( options = {} ) {\r\n  this.transport = options.transport\r\n  this.type = options.type\r\n  this._setup = options.setup.bind( this )\r\n  this._read = length => options.read.call( this, length === undefined ? length : this.options.highWaterMark )\r\n  this._write = options.write.bind( this )\r\n\r\n  this.options = {\r\n    highWaterMark: options.highWaterMark || DEFAULT_HIGHWATERMARK\r\n  }\r\n\r\n  this._busState = new BufferState( {\r\n    watching: [],\r\n    active: 0,\r\n    nodeIndex: 0,\r\n    configured: false,\r\n    ticker: false\r\n  } )\r\n}\r\n\r\n_Bus.prototype = {\r\n  setup() {\r\n    if ( this._busState.configured ) {\r\n      return Promise.reject( 'already configured' )\r\n    }\r\n\r\n    this._busState.configured = true\r\n    return this._setup.apply( this, arguments )\r\n  },\r\n\r\n  push( chunk ) {\r\n    // console.log( 'push()' )\r\n    // console.log( chunk )\r\n    if ( chunk.length ) {\r\n      this._busState.push( chunk )\r\n\r\n      if ( !this._busState.ticker ) {\r\n        this._busState.ticker = true\r\n        setImmediate( () => {\r\n          this._busState.ticker = false\r\n          _push.call( this )\r\n        } )\r\n      }\r\n    }\r\n    // const highWaterMark = this.options.highWaterMark,\r\n    //       parse = _parse.bind(this)\r\n    //\r\n    // if(chunk.length > highWaterMark) {\r\n    //   const chunks = []\r\n    //   let subchunkIndex = 0\r\n    //\r\n    //   for(let bytesLeft = chunk.length, offset = 0; bytesLeft > 0; bytesLeft -= highWaterMark) {\r\n    //     const subchunk = chunk.slice(offset, offset += highWaterMark)\r\n    //     chunks.push(subchunk)\r\n    //   }\r\n    //\r\n    //   series(chunks, (next, subchunk) => {\r\n    //     parse(subchunk)\r\n    //     next()\r\n    //   })\r\n    // }\r\n    // else {\r\n    //   parse(chunk)\r\n    // }\r\n  },\r\n\r\n  watch( list, cb ) {\r\n    const watcher = _resetWatcher( {\r\n      list,\r\n      callback: cb.bind( this )\r\n    } )\r\n\r\n    this._busState.watching.push( watcher )\r\n\r\n    return watcher\r\n  },\r\n\r\n  unwatch( watcher ) {\r\n    if ( watcher ) {\r\n      const index = this._busState.watching.indexOf( watcher )\r\n\r\n      if ( index >= 0 ) {\r\n        if ( this._busState.watching[ index ].active ) {\r\n          _resetWatcher( watcher )\r\n          _decrementActive.call( this )\r\n        }\r\n\r\n        this._busState.watching.splice( index, 1 )\r\n      }\r\n    } else {\r\n      this._busState.watching.splice( 0 )\r\n      _resetActive.call( this )\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  /**\r\n    @TODO Promise interface\r\n  */\r\n\r\n  expect( list, ...args ) {\r\n    let cb, options = {}\r\n\r\n    if ( typeof args[ 0 ] == 'function' ) {\r\n      cb = args[ 0 ]\r\n    } else if ( typeof args[ 1 ] == 'function' ) {\r\n      cb = args[ 1 ]\r\n      Object.assign( options, args[ 0 ] )\r\n    } else {\r\n      throw new ReferenceError( 'Callback is not provided' )\r\n    }\r\n\r\n    let watcher\r\n    const setWatcher = () => {\r\n      watcher = this.watch( list, ( ...args ) => {\r\n        this.unwatch( watcher )\r\n        cb.apply( this, args )\r\n      } )\r\n      this._read( this.options.highWaterMark )\r\n    }\r\n\r\n    // if ( 'timeout' in options ) {\r\n    //   setTimeout( setWatcher, options.timeout )\r\n    // } else {\r\n    //\r\n    // }\r\n\r\n    setWatcher()\r\n\r\n    return watcher\r\n  },\r\n\r\n  send( binary, options = {} ) {\r\n    if ( 'timeout' in options ) {\r\n      setTimeout( () => {\r\n        this._write( binary )\r\n      }, options.timeout )\r\n    } else {\r\n      this._write( binary )\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n  reset() {\r\n    this._busState.watching.splice( 0 )\r\n    return this\r\n  }\r\n}\r\n\r\nconst Bus = _extend( {\r\n  proto: [ EventEmitter, _Bus ],\r\n  apply: [ EventEmitter, _Bus ]\r\n} )\r\n\r\nexport default Bus\r\n","import Bus from 'bus'\r\nimport {\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_WRITE_16,\r\n  PN532_BRTY_ISO14443A,\r\n  PN532_BRTY_ISO14443B\r\n} from './constants'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  ERR,\r\n  INFO\r\n} from './frames'\r\n\r\nimport series from 'series'\r\n\r\nconst sliceAck = chunk => chunk.slice( ACK.length )\r\n\r\nconst parseInfo = chunk => {\r\n  return {\r\n    raw: chunk,\r\n    code: chunk[ 6 ],\r\n    body: chunk.slice( 7, 5 + chunk[ 3 ] )\r\n  }\r\n}\r\n\r\nconst parseBlockData = data => {\r\n  if ( data.body.length == 1 ) {\r\n    throw {\r\n      cmd: data.code,\r\n      code: data.body[ 0 ]\r\n    }\r\n  } else {\r\n    return {\r\n      chunk: data.body.slice( 1 )\r\n    }\r\n  }\r\n}\r\n\r\nfunction _Bus() {}\r\n\r\n_Bus.prototype = {\r\n  makeTransaction( cmd, info, parsers ) {\r\n    return new Promise( ( done, fail ) => {\r\n        // Don't be silly again - info frame refers to index from beginning, i.e. to ACK\r\n        // this.expect([...ACK, ...info], chunk => done((parsers || [sliceAck, parseInfo]).reduce((data, parse) => parse(data), chunk)))\r\n        this.expect( ACK, () => {\r\n          this.expect( info, chunk => {\r\n            const _parsers = parsers || [ parseInfo ]\r\n            done( _parsers.reduce( ( data, parse ) => parse( data ), chunk ) )\r\n          } )\r\n        } )\r\n\r\n        this.expect( NACK, fail )\r\n        this.expect( ERR, fail )\r\n\r\n        this.send( command( cmd ) )\r\n      } )\r\n      .catch( err => {\r\n        this.unwatch()\r\n        throw err\r\n      } )\r\n      .then( data => {\r\n        this.unwatch()\r\n        return data\r\n      } )\r\n  },\r\n\r\n  findTargets( count, type ) {\r\n    if ( type == 'A' ) {\r\n      type = PN532_BRTY_ISO14443A\r\n    } else if ( type == 'B' ) {\r\n      type = PN532_BRTY_ISO14443B\r\n    } else {\r\n      throw new Error( 'Unknown ISO14443 type:', `\"${ type }\"` )\r\n    }\r\n\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INLISTPASSIVETARGET,\r\n      count,\r\n      type\r\n    ], INFO, [ chunk => {\r\n      const body = chunk.slice( 7, 5 + chunk[ 3 ] )\r\n      const uid = body.slice( 6, 6 + body[ 5 ] )\r\n      return {\r\n        code: chunk[ 6 ],\r\n        body,\r\n        count: body[ 0 ],\r\n        atqa: body.slice( 2, 4 ), // SENS_RES\r\n        sak: body[ 4 ],\r\n        uid\r\n      }\r\n    } ] )\r\n  },\r\n\r\n  authenticate( block, uid, key ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_AUTH_A,\r\n      block,\r\n      ...[].slice.call( key ),\r\n      ...[].slice.call( uid )\r\n    ], INFO )\r\n  },\r\n\r\n  readBlock( block ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_READ_16,\r\n      block\r\n    ], INFO, [ parseInfo, parseBlockData ] )\r\n  },\r\n\r\n  writeBlock( block, chunk ) {\r\n    return this.makeTransaction( [\r\n      PN532_COMMAND_INDATAEXCHANGE,\r\n      1,\r\n      MIFARE_COMMAND_WRITE_16,\r\n      block,\r\n      ...[].slice.call( chunk )\r\n    ], INFO )\r\n  },\r\n\r\n  readSector( sector ) {\r\n    return new Promise( ( done, fail ) => {\r\n      const readBlocksArr = []\r\n      for ( let block = sector * 4; block < sector * 4 + 3; block++ ) {\r\n        readBlocksArr.push( block )\r\n      }\r\n\r\n      series( readBlocksArr, ( next, block, index ) => {\r\n        this.readBlock( block )\r\n          .then( data => {\r\n            readBlocksArr[ index ] = data\r\n            next()\r\n          } )\r\n          .catch( err => {\r\n            console.log( '!!!' )\r\n            next( err )\r\n          } )\r\n      }, err => err ? fail( err ) : done( readBlocksArr ) )\r\n    } )\r\n  },\r\n\r\n  writeSector( start, chunk ) {\r\n\r\n  }\r\n}\r\n\r\nexport default _extend( {\r\n  proto: [ Bus, _Bus ],\r\n  apply: [ Bus, _Bus ]\r\n} )\r\n","if(typeof console.time !== 'function') {\r\n  const timers = {}\r\n\r\n  console.time = label => {\r\n    timers[label] = Date.now()\r\n  }\r\n\r\n  console.timeEnd = label => {\r\n    if(label in timers) {\r\n      console.log(`${ label }: ${ (Date.now() - timers[label]).toFixed(3) }ms`)\r\n      delete timers[label]\r\n    }\r\n  }\r\n}\r\n\r\nif(typeof console.error !== 'function') {\r\n  console.error = console.log\r\n}\r\n\r\nexport default console\r\n","Array.prototype.concat = function () {\r\n  const concatenated = []\r\n\r\n  for(let i in this) {\r\n    concatenated.push(this[i])\r\n  }\r\n\r\n  for(let i in arguments) {\r\n    for(let j in arguments[i]) {\r\n      concatenated.push(arguments[i][j])\r\n    }\r\n  }\r\n\r\n  return concatenated\r\n}\r\n\r\nexport default Array\r\n","// var PENDING = 'pending'\r\n// var SEALED = 'sealed'\r\n// var FULFILLED = 'fulfilled'\r\n// var REJECTED = 'rejected'\r\n//\r\n// var NOOP = function() {}\r\n//\r\n// function invokeResolver(resolver, promise) {\r\n//   function resolvePromise(value) {\r\n//     resolve(promise, value)\r\n//   }\r\n//\r\n//   function rejectPromise(reason) {\r\n//     reject(promise, reason)\r\n//   }\r\n//\r\n//   try {\r\n//     resolver(resolvePromise, rejectPromise)\r\n//   } catch(e) {\r\n//     rejectPromise(e)\r\n//   }\r\n// }\r\n//\r\n// function invokeCallback(subscriber) {\r\n//   var owner = subscriber.owner\r\n//   var settled = owner.state_\r\n//   var value = owner.data_\r\n//   var callback = subscriber[settled]\r\n//   var promise = subscriber.then\r\n//\r\n//   if (typeof callback === 'function')\r\n//   {\r\n//     settled = FULFILLED\r\n//     try {\r\n//       value = callback(value)\r\n//     } catch(e) {\r\n//       reject(promise, e)\r\n//     }\r\n//   }\r\n//\r\n//   if (!handleThenable(promise, value))\r\n//   {\r\n//     if (settled === FULFILLED)\r\n//       resolve(promise, value)\r\n//\r\n//     if (settled === REJECTED)\r\n//       reject(promise, value)\r\n//   }\r\n// }\r\n//\r\n// function handleThenable(promise, value) {\r\n//   var resolved\r\n//\r\n//   try {\r\n//     if (promise === value)\r\n//       throw new TypeError('A promises callback cannot return that same promise.')\r\n//\r\n//     if (value && (typeof value === 'function' || typeof value === 'object'))\r\n//     {\r\n//       var then = value.then  // then should be retrived only once\r\n//\r\n//       if (typeof then === 'function')\r\n//       {\r\n//         then.call(value, function(val){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             if (value !== val)\r\n//               resolve(promise, val)\r\n//             else\r\n//               fulfill(promise, val)\r\n//           }\r\n//         }, function(reason){\r\n//           if (!resolved)\r\n//           {\r\n//             resolved = true\r\n//\r\n//             reject(promise, reason)\r\n//           }\r\n//         })\r\n//\r\n//         return true\r\n//       }\r\n//     }\r\n//   } catch (e) {\r\n//     if (!resolved)\r\n//       reject(promise, e)\r\n//\r\n//     return true\r\n//   }\r\n//\r\n//   return false\r\n// }\r\n//\r\n// function resolve(promise, value){\r\n//   if (promise === value || !handleThenable(promise, value))\r\n//     fulfill(promise, value)\r\n// }\r\n//\r\n// function publish(promise) {\r\n//   var callbacks = promise.then_\r\n//   promise.then_ = undefined\r\n//\r\n//   for (var i = 0 i < callbacks.length i++) {\r\n//     invokeCallback(callbacks[i])\r\n//   }\r\n// }\r\n//\r\n// function fulfill(promise, value){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = value\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = FULFILLED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function reject(promise, reason){\r\n//   if (promise.state_ === PENDING)\r\n//   {\r\n//     promise.state_ = SEALED\r\n//     promise.data_ = reason\r\n//\r\n//     setImmediate(() => {\r\n//       promise.state_ = REJECTED\r\n//       publish(promise)\r\n//     })\r\n//   }\r\n// }\r\n//\r\n// function Promise(resolver) {\r\n//   if (typeof resolver !== 'function')\r\n//     throw new TypeError('Promise constructor takes a function argument')\r\n//\r\n//   if (this instanceof Promise === false)\r\n//     throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.')\r\n//\r\n//   this.then_ = []\r\n//\r\n//   invokeResolver(resolver, this)\r\n// }\r\n//\r\n// Promise.prototype = {\r\n//   constructor: Promise,\r\n//\r\n//   state_: PENDING,\r\n//   then_: null,\r\n//   data_: undefined,\r\n//\r\n//   then: function(onFulfillment, onRejection){\r\n//     var subscriber = {\r\n//       owner: this,\r\n//       then: new this.constructor(NOOP),\r\n//       fulfilled: onFulfillment,\r\n//       rejected: onRejection\r\n//     }\r\n//\r\n//     if (this.state_ === FULFILLED || this.state_ === REJECTED)\r\n//     {\r\n//       // already resolved, call callback async\r\n//       setImmediate(() => {invokeCallback(subscriber)})\r\n//     }\r\n//     else\r\n//     {\r\n//       // subscribe\r\n//       this.then_.push(subscriber)\r\n//     }\r\n//\r\n//     return subscriber.then\r\n//   },\r\n//\r\n//   'catch': function(onRejection) {\r\n//     return this.then(null, onRejection)\r\n//   }\r\n// }\r\n\r\n// Promise.all = function(promises) {\r\n//   if (!(promises instanceof Array)) {\r\n//     throw new TypeError('You must pass an array to Promise.all().')\r\n//   }\r\n//\r\n//   return new Promise((resolve, reject) => {\r\n//     var results = []\r\n//     var remaining = 0\r\n//\r\n//     function resolver(index) {\r\n//       remaining++\r\n//       return function(value) {\r\n//         results[index] = value\r\n//         if (!--remaining) {\r\n//           resolve(results)\r\n//         }\r\n//       }\r\n//     }\r\n//\r\n//     for (var i = 0, promise; i < promises.length; i++) {\r\n//       promise = promises[i]\r\n//\r\n//       if (promise && typeof promise.then === 'function') {\r\n//         promise.then(resolver(i), reject)\r\n//       }\r\n//       else {\r\n//         results[i] = promise\r\n//       }\r\n//     }\r\n//\r\n//     if (!remaining) {\r\n//       resolve(results)\r\n//     }\r\n//   })\r\n// }\r\n\r\nPromise.race = function(promises){\r\n  var Class = this\r\n\r\n  if (!(promises instanceof Array))\r\n    throw new TypeError('You must pass an array to Promise.race().')\r\n\r\n  return new Class((resolve, reject) => {\r\n    for (var i = 0, promise; i < promises.length; i++)\r\n    {\r\n      promise = promises[i]\r\n\r\n      if (promise && typeof promise.then === 'function')\r\n        promise.then(resolve, reject)\r\n      else\r\n        resolve(promise)\r\n    }\r\n  })\r\n}\r\n\r\n// Promise.resolve = function(value) {\r\n//   var Class = this\r\n//\r\n//   if (value && typeof value === 'object' && value.constructor === Class)\r\n//     return value\r\n//\r\n//   return new Class(function(resolve){\r\n//     resolve(value)\r\n//   })\r\n// }\r\n//\r\n// Promise.reject = function(reason){\r\n//   var Class = this\r\n//\r\n//   return new Class(function(resolve, reject){\r\n//     reject(reason)\r\n//   })\r\n// }\r\n//\r\n\r\nexport default Promise\r\n","const arrayBufferViewInstances = [\r\n  Int8Array,\r\n  Uint8Array,\r\n  Uint8ClampedArray,\r\n  Int16Array,\r\n  Uint16Array,\r\n  Int32Array,\r\n  Uint32Array,\r\n  Float32Array,\r\n  Float64Array,\r\n  DataView\r\n]\r\n\r\nArrayBuffer.isView = value => typeof value == 'object' && value.buffer instanceof ArrayBuffer // arrayBufferViewInstances.some( ArrayBufferView => value instanceof ArrayBufferView )\r\n\r\nexport default ArrayBuffer\r\n","Object.assign = ( target, ...args ) => {\r\n  for ( let i in args ) {\r\n    const obj = args[ i ]\r\n    if ( obj instanceof Object ) {\r\n      for ( let key in obj ) {\r\n        target[ key ] = obj[ key ]\r\n      }\r\n    }\r\n  }\r\n\r\n  return target\r\n}\r\n\r\nconst _defProp = Object.defineProperty\r\n\r\nObject.defineProperty = ( obj, prop, descriptor ) => {\r\n  try {\r\n    return _defProp( obj, prop, descriptor )\r\n  } catch ( e ) {\r\n    if ( descriptor.get ) {\r\n      obj.value = descriptor.get()\r\n    } else if ( descriptor.value ) {\r\n      obj[ prop ] = descriptor.value\r\n    }\r\n\r\n    return obj\r\n  }\r\n}\r\n\r\nObject.defineProperties = ( obj, descriptors ) => {\r\n  for ( let prop in descriptors ) {\r\n    const descriptor = descriptors[ prop ]\r\n    Object.defineProperty( obj, prop, descriptor )\r\n  }\r\n  return obj\r\n}\r\n\r\n\r\nexport default Object\r\n","let defaultLed\r\nlet ON = 1,\r\n  OFF = 0\r\n\r\nif (process.env.CHIP && process.env.CHIP.toUpperCase() == 'ESP32') {\r\n  defaultLed = D5\r\n  ON = 0\r\n  OFF = 1\r\n} else {\r\n  defaultLed = LED2\r\n}\r\n\r\nlet status = false\r\nconst defaultTimeout = 20\r\n\r\nexport const once = (led, timeout, cb) => {\r\n  // D5.write(0)\r\n  // console.log('on')\r\n  led.write(ON)\r\n  setTimeout(() => {\r\n    // D5.write(1)\r\n    // console.log('off')\r\n    led.write(OFF)\r\n    cb && cb()\r\n  }, timeout || defaultTimeout)\r\n}\r\n\r\nexport const start = led => {\r\n  if (!led) {\r\n    led = defaultLed\r\n  }\r\n  if (!status) {\r\n    status = true\r\n\r\n    once(led, defaultTimeout, function cb() {\r\n      if (status) {\r\n        setTimeout(() => {\r\n          once(led, defaultTimeout, cb)\r\n        }, 1000 - defaultTimeout)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport const stop = () => {\r\n  if (status) {\r\n    status = false\r\n  }\r\n}\r\n","import {\r\n  SUPER_CHAIN_PROTO_PROP,\r\n  SUPER_CHAIN_APPLY_PROP,\r\n  PROTOTYPE_IS_EXTENDED_PROP\r\n} from './props'\r\n\r\nexport const _copyChain = ( Extended, ProtoChain, chainPropName, ignoreExtended ) => {\r\n  //if chain on [Extended] has not been created yet\r\n  if ( !Extended.prototype[ chainPropName ] ) {\r\n    Object.defineProperty( Extended.prototype, chainPropName, {\r\n      value: []\r\n    } )\r\n  }\r\n\r\n  ProtoChain.forEach( Proto => {\r\n    //console.log(!!Proto.prototype['__extended__'], Proto)\r\n    //if [Proto] has been '__extended__' and has same-named proto chain, copy the Proto chain to Extended chain\r\n    const isExtended = !!Proto.prototype[ PROTOTYPE_IS_EXTENDED_PROP ],\r\n      hasSameChain = !!Proto.prototype[ chainPropName ]\r\n\r\n    const alreadyInChain = Extended.prototype[ chainPropName ].some( P => P === Proto ),\r\n      shouldBePushed = ( !isExtended || !ignoreExtended ) && !alreadyInChain,\r\n      shouldCopyChain = isExtended && hasSameChain\r\n\r\n    if ( shouldCopyChain )\r\n      Proto.prototype[ chainPropName ].forEach( Proto => {\r\n        //avoid pushing twice\r\n        if ( !Extended.prototype[ chainPropName ].some( P => P === Proto ) ) {\r\n          //console.log('pushed', Proto)\r\n          Extended.prototype[ chainPropName ].push( Proto )\r\n        }\r\n      } )\r\n\r\n    if ( shouldBePushed ) {\r\n      Extended.prototype[ chainPropName ].push( Proto )\r\n    }\r\n  } )\r\n\r\n  //console.log(Extended.prototype[chainPropName])\r\n}\r\n\r\nexport const _extend = ( options = {} ) => {\r\n  if ( !options.apply )\r\n    options.apply = []\r\n  if ( !options.proto )\r\n    options.proto = []\r\n  // if ( !options.static )\r\n  //   options.static = []\r\n\r\n  const Child = options.proto[ 0 ]\r\n\r\n  if ( !options.name )\r\n    options.name = Child.name\r\n\r\n  function Extended() {\r\n    Extended.prototype[ SUPER_CHAIN_APPLY_PROP ].forEach( Super => {\r\n      if ( Super !== Extended ) {\r\n        Super.apply( this, arguments )\r\n      }\r\n    } )\r\n  }\r\n\r\n  _named( options.name, Extended )\r\n\r\n  // for ( let i in options.static ) {\r\n  //   for ( let prop in options.static[ i ] ) {\r\n  //     if ( 'prototype' != prop ) {\r\n  //       Object.defineProperty( Extended, prop, {\r\n  //         value: proto[ prop ],\r\n  //         enumerable: true,\r\n  //         writable: true\r\n  //       } )\r\n  //     }\r\n  //   }\r\n  // }\r\n\r\n  Object.defineProperty( Extended, 'prototype', {\r\n    value: {}\r\n  } )\r\n  Object.defineProperty( Extended.prototype, 'constructor', {\r\n    value: Child\r\n  } )\r\n  Object.defineProperty( Extended.prototype, PROTOTYPE_IS_EXTENDED_PROP, {\r\n    value: true\r\n  } )\r\n\r\n  for ( let i in options.proto ) {\r\n    function Proto() {}\r\n    Proto.prototype = options.proto[ i ].prototype\r\n    const proto = new Proto()\r\n\r\n    for ( let prop in proto ) {\r\n      if ( [ 'constructor', PROTOTYPE_IS_EXTENDED_PROP, SUPER_CHAIN_PROTO_PROP, SUPER_CHAIN_APPLY_PROP ].indexOf( prop ) < 0 ) {\r\n        Object.defineProperty( Extended.prototype, prop, {\r\n          value: proto[ prop ],\r\n          enumerable: true,\r\n          writable: true\r\n        } )\r\n      }\r\n    }\r\n  }\r\n\r\n  _copyChain( Extended, options.proto, SUPER_CHAIN_PROTO_PROP, false )\r\n  _copyChain( Extended, options.apply, SUPER_CHAIN_APPLY_PROP, true )\r\n\r\n  return Extended\r\n}\r\n\r\nexport const extend = ( ...args ) => _extend( {\r\n  super: args.slice( 1 ),\r\n  apply: args\r\n} )\r\n","export default (name, f) => Object.defineProperty(f, 'name', { value: name })\r\n","const loop = [\r\n  // immediate\r\n  { queue: [], immediatePush: true, tick: false },\r\n  // timeout\r\n  { queue: [], immediatePush: false, tick: false }\r\n]\r\n\r\nlet tick = false\r\n\r\nconst asyncFlush = () => {\r\n  for (let stage in loop) {\r\n    if(loop[stage].queue.length) {\r\n      if(loop[stage].immediatePush) {\r\n        for (let exec = 0; exec < loop[stage].queue.length; exec ++) {\r\n          loop[stage].queue[exec]()\r\n        }\r\n        loop[stage].queue.splice(0)\r\n      } else {\r\n        const queue = loop[stage].queue.splice(0)\r\n        for (let exec = 0; exec < queue.length; exec ++) {\r\n          queue[exec]()\r\n        }\r\n      }\r\n    }\r\n\r\n    loop[stage].tick = tick = false\r\n  }\r\n}\r\n\r\nconst asyncCall = stage => cb => {\r\n  loop[stage].queue.push(cb)\r\n\r\n  if (!tick && !loop[stage].tick) {\r\n    loop[stage].tick = tick = true\r\n\r\n    setTimeout(asyncFlush)\r\n  }\r\n}\r\n\r\nconst setImmediate = asyncCall(/* .immediate */0)\r\n\r\nconst timeoutCall = asyncCall(/* .timeeout */1)\r\n\r\nexport const _setTimeout = (cb, timeout) => setTimeout(() => { timeoutCall(cb) }, timeout)\r\n\r\nexport const _setInterval = (cb, timeout) => (function setTimer() {\r\n  return _setTimeout(() => {\r\n    setTimer()\r\n    cb()\r\n  }, timeout)\r\n})()\r\n\r\nexport {\r\n  setImmediate,\r\n  _setTimeout as setTimeout,\r\n  _setInterval as setInterval\r\n}\r\n","import {\r\n  PN532_PREAMBLE,\r\n  PN532_STARTCODE1,\r\n  PN532_STARTCODE2,\r\n  PN532_HOST_TO_PN532,\r\n  PN532_PN532_TO_HOST,\r\n  PN532_POSTAMBLE\r\n} from './constants'\r\n\r\nconst check = values => !( 0xff & ( -values.reduce( ( sum, value ) => sum + value, 0 ) ) )\r\n\r\nconst LCS = ( byte, length, frame ) => check( frame.slice( -2 ) )\r\n\r\nconst EXTENDED_LCS = ( byte, length, frame ) => check( [ frame[ 5 ] * 256 + frame[ 6 ], frame[ 7 ] ] )\r\n\r\nconst CHECKSUM = ( byte, length, frame ) => check( frame.slice( 5 ) )\r\n\r\nconst EXTENDED_CHECKSUM = ( byte, length, frame ) => check( frame.slice( 8 ) )\r\n\r\nconst BODY = frame => frame[ 3 ] - 1 /* response code + payload */\r\n\r\nconst EXTENDED_BODY = frame => 256 * frame[ 5 ] + frame[ 6 ]\r\n\r\nexport const INFO = [\r\n  [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, undefined, LCS, PN532_PN532_TO_HOST ],\r\n  BODY, [ CHECKSUM, PN532_POSTAMBLE ]\r\n]\r\n\r\nexport const XINFO = [\r\n  [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0xff ], 2, [ EXTENDED_LCS, PN532_PN532_TO_HOST ],\r\n  EXTENDED_BODY, [ EXTENDED_CHECKSUM, PN532_POSTAMBLE ]\r\n]\r\n\r\nexport const ERR = [\r\n  [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x01, 0xff, undefined, CHECKSUM, PN532_POSTAMBLE ]\r\n]\r\n\r\nexport const ACK = [\r\n  new Uint8Array( [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0x00, 0xff, PN532_POSTAMBLE ] )\r\n]\r\n\r\nexport const NACK = [\r\n  new Uint8Array( [ PN532_PREAMBLE, PN532_STARTCODE1, PN532_STARTCODE2, 0xff, 0x00, PN532_POSTAMBLE ] )\r\n]\r\n\r\nexport const command = command =>\r\n  new Uint8Array( [\r\n    PN532_PREAMBLE,\r\n    PN532_STARTCODE1,\r\n    PN532_STARTCODE2,\r\n    0xff & ( command.length + 1 ),\r\n    0xff & ( ~command.length ),\r\n    PN532_HOST_TO_PN532,\r\n    ...command,\r\n    // checksum\r\n    0xff & ( -command.reduce( ( checksum, byte ) => checksum + byte, PN532_HOST_TO_PN532 ) ),\r\n    PN532_POSTAMBLE\r\n  ] )\r\n","export default function series( arr, cb, done ) {\r\n  let i = 0\r\n  let aborted = false;\r\n  ( function next( res ) {\r\n    if ( !aborted ) {\r\n      if ( typeof res !== 'undefined' || i >= arr.length ) {\r\n        done && done( res )\r\n      } else {\r\n        setImmediate( () => {\r\n          try {\r\n            cb( next, arr[ i ], i++, arr )\r\n          } catch ( err ) {\r\n            next( err )\r\n            aborted = true\r\n          }\r\n        } )\r\n      }\r\n    }\r\n  } )()\r\n}\r\n","// import Bus from 'bus'\r\n//\r\n// const preamble = [ 1, 2, 3 ]\r\n// const postamble = [ 4, ( {\r\n//   getFrame,\r\n//   getAbsoluteIndex,\r\n//   getRelativeIndex\r\n// } ) => {\r\n//   console.log( getAbsoluteIndex( 1 ), getRelativeIndex( 0 ) )\r\n//   return true\r\n// }, 6 ]\r\n//\r\n// const bus = new Bus( {\r\n//   read() {},\r\n//   write() {},\r\n//   setup() {}\r\n// } )\r\n//\r\n// bus.on( 'error', console.error )\r\n//\r\n// bus.expect( [\r\n//   preamble,\r\n//   postamble\r\n// ], console.log )\r\n//\r\n// bus.push( preamble )\r\n// bus.push( postamble )\r\n\r\n// import Bus from 'bus'\r\n// import Schedule from 'schedule'\r\nimport * as Blink from 'blink'\r\nimport {\r\n  command,\r\n  ACK,\r\n  NACK,\r\n  ERR,\r\n  INFO,\r\n  XINFO\r\n} from 'nfc'\r\nimport Bus from 'nfc/bus'\r\nimport {\r\n  PN532_I2C_ADDRESS,\r\n  PN532_COMMAND_SAMCONFIGURATION,\r\n  PN532_SAM_NORMAL_MODE,\r\n  PN532_COMMAND_WRITEGPIO,\r\n  PN532_COMMAND_INLISTPASSIVETARGET,\r\n  PN532_COMMAND_INDATAEXCHANGE,\r\n  PN532_COMMAND_GETFIRMWAREVERSION,\r\n  PN532_COMMAND_WAKEUP,\r\n  MIFARE_COMMAND_READ_16,\r\n  MIFARE_COMMAND_AUTH_A,\r\n  MIFARE_COMMAND_AUTH_B,\r\n  MIFARE_COMMAND_WRITE_4,\r\n  MIFARE_COMMAND_WRITE_16\r\n} from 'nfc/constants'\r\n\r\nimport {\r\n  encodeMessage,\r\n  decodeMessage,\r\n  textRecord\r\n} from 'esp-ndef'\r\n\r\n// let usbConsole = true\r\n// let consoleBus = null\r\n// let log = ''\r\n//\r\n//\r\n// function toggleConsole() {\r\n//   usbConsole = !usbConsole\r\n//   if (usbConsole) {\r\n//     consoleBus = null\r\n//     USB.removeAllListeners()\r\n//   } else {\r\n//     consoleBus = new Bus({\r\n//       setup() {\r\n//         USB.on('data', data => {\r\n//           this.parse.call(this, data)\r\n//           USB.setup()\r\n//           // USB.write(Buffer.from(['!', ...[].slice.call(data, 0)]))\r\n//         })\r\n//       },\r\n//       read() {},\r\n//       write() {}\r\n//     })\r\n//\r\n//     consoleBus.expect([Buffer.from('/on')], () => {\r\n//       Blink.once(LED1)\r\n//       USB.write(JSON.stringify(consoleBus._busState))\r\n//       // toggleConsole()\r\n//     })\r\n//\r\n//     // consoleBus.expect([Buffer.from('/off')], () => {\r\n//     //   LED1.write(1)\r\n//     //   // USB.write('/off\\r\\n')\r\n//     //   // toggleConsole()\r\n//     // })\r\n//     //\r\n//     // consoleBus.on('error', err => {\r\n//     //   Blink.once(LED1, 200)\r\n//     // })\r\n//\r\n//     consoleBus.setup()\r\n//   }\r\n//\r\n//   usbConsole ?\r\n//     USB.setConsole(false) :\r\n//     LoopbackA.setConsole(false)\r\n// }\r\n//\r\n// toggleConsole()\r\n\r\n// setWatch( toggleConsole, BTN1, {\r\n//   repeat: true,\r\n//   edge: 'rising',\r\n//   debounce: 50\r\n// } )\r\n//\r\n// Blink.start( LED2 )\r\n//\r\n// const encoded = encodeMessage( [\r\n//   textRecord( '2enhello world!' )\r\n// ] )\r\n//\r\n// import fs from 'fs'\r\n\r\n// [0, 0, 255, 0, 255, 0]\r\n// [0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0]\r\n\r\n// [0, 0, 255, 0, 255, 0, 2, 42, 1, 6, 7, 232, 0, 0, 0, ]\r\n\r\n// [1, 0, 0, 255, 0, 255, 0, 2, 42, 0, 0, 0, 0, 0, 0, 0]\r\n// [1, 0, 0, 255, 6, 250, 213, 3, 50, 1, 6, 7, 232, 0, 0, 0]\r\n\r\nfunction parseTypeATargetData( raw ) {\r\n  return {\r\n    targetNumber: raw[ 0 ],\r\n    baudrate: 0x00,\r\n    SENS_RES: raw.slice( 1, 3 ), // ATQA\r\n    SEL_RES: raw[ 3 ], // SAK\r\n    NFCID1: raw.slice( 4, 4 + raw[ 4 ] )\r\n  }\r\n}\r\n\r\nfunction parseTypeBTargetData( raw ) {\r\n  return {\r\n    targetNumber: raw[ 0 ],\r\n    baudrate: 0x00,\r\n    ATQB: raw.slice( 1, 13 ),\r\n    ATTRIB_RES: raw.slice( 14, 14 + raw[ 13 ] )\r\n  }\r\n}\r\n\r\nfunction parse212or424TargetData( raw ) {\r\n  const parsed = {\r\n    targetNumber: raw[ 0 ],\r\n    code: raw[ 2 ],\r\n    NFCID2t: raw.slice( 3, 11 ),\r\n    pad: raw.slice( 11, 19 )\r\n  }\r\n\r\n  if ( raw[ 1 ] == 20 ) {\r\n    parsed.SYST_CODE = raw.slice( 19, 21 )\r\n  }\r\n\r\n  return parsed\r\n}\r\n\r\nfunction parseInnovisionJewelTargetData( raw ) {\r\n  return {\r\n    targetNumber: raw[ 0 ],\r\n    baudrate: 0x00,\r\n    SENS_RES: raw.slice( 1, 3 ),\r\n    JEWELID: raw.slice( 3, 7 )\r\n  }\r\n}\r\n\r\nfunction parseDEP( targetRaw, targetData ) {\r\n  let offset = 0\r\n  if ( targetData.type == 0x00 ) {\r\n    offset = 5 + targetRaw[ 4 ]\r\n    Object.assign( targetData, parseTypeATargetData( targetRaw.slice( 0, offset ) ) )\r\n  } else if ( targetData.type == 0x03 ) {\r\n    offset = 14 + targetRaw[ 13 ]\r\n    Object.assign( targetData, parseTypeBTargetData( targetRaw.slice( 0, offset ) ) )\r\n  } else if ( targetData.type == 0x01 || targetData.type == 0x02 ) {\r\n    offset = 1 + targetRaw[ 1 ]\r\n    Object.assign( targetData, parse212or424TargetData( targetRaw.slice( 0, offset ) ), {\r\n      baudrate: targetData.type\r\n    } )\r\n  } else if ( targetData.type == 0x04 ) {\r\n    offset = 7\r\n    Object.assign( targetData, parseInnovisionJewelTargetData( targetRaw.slice( 0, offset ) ) )\r\n  } else {\r\n    throw new TypeError( 'Unknown type', targetType.type )\r\n  }\r\n  return offset\r\n}\r\n\r\nfunction setup() {\r\n  if ( this.type == 'serial' ) {\r\n    this.transport.setup( 115200 )\r\n\r\n    this.transport.on( 'data', data => {\r\n      console.log( Buffer.from( data ) )\r\n      this.push( data )\r\n    } )\r\n\r\n    this.transport.write( PN532_COMMAND_WAKEUP )\r\n\r\n    console.log( 'configuring sam' )\r\n    this.send( command( [ PN532_COMMAND_SAMCONFIGURATION, 0x01, 20, 0 ] ) )\r\n    this.expect( ACK, () => {\r\n      console.log( 'sam ACK' )\r\n    } )\r\n    this.expect( INFO, () => {\r\n      console.log( 'sam configured' )\r\n\r\n      Blink.once( LED1, 20, () => {\r\n        setTimeout( () => Blink.once( LED1, 20 ), 200 )\r\n      } )\r\n    } )\r\n  } else if ( this.type == 'i2c' ) {\r\n    this.transport.setup( {\r\n      bitrate: 400 * 1000\r\n    } )\r\n\r\n    this.on( 'drain', () => {\r\n      this._read()\r\n    } )\r\n\r\n    try {\r\n      this.send( 1 )\r\n    } catch ( err ) {\r\n      console.log( 'Handled', err.msg )\r\n      console.log( 'Continue...' )\r\n    }\r\n\r\n    this.send( command( [ PN532_COMMAND_GETFIRMWAREVERSION ] ) )\r\n\r\n    this.expect( [\r\n      ...ACK,\r\n      ...INFO\r\n    ], {\r\n      timeout: 10\r\n    }, frame => {\r\n      console.log( 'frame' )\r\n      console.log( frame )\r\n    } )\r\n  }\r\n}\r\n\r\nconst bus = new Bus( {\r\n  transport: Serial1,\r\n  type: 'serial',\r\n  setup,\r\n  read( length ) {\r\n    if ( this.type == 'i2c' ) {\r\n      while ( true ) {\r\n        if ( this.transport.readFrom( PN532_I2C_ADDRESS, 1 )[ 0 ] ) {\r\n          const chunk = this.transport.readFrom( PN532_I2C_ADDRESS, 1 + length )\r\n          this.push( chunk )\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n    } else if ( this.type == 'serial' ) {\r\n      // const chunk = this.transport.read(length)\r\n      // this.push(chunk)\r\n    }\r\n  },\r\n  write( chunk ) {\r\n    if ( this.type == 'serial' ) {\r\n      this.transport.write( chunk )\r\n    } else if ( this.type == 'i2c' ) {\r\n      this.transport.writeTo( PN532_I2C_ADDRESS, chunk )\r\n    }\r\n  },\r\n  highWaterMark: 16\r\n} )\r\n\r\nbus.on( 'error', err => {\r\n  console.error( 'BusError:', err )\r\n} )\r\n\r\nbus.setup()\r\n\r\nconst key = new Uint8Array( Array( 6 )\r\n  .fill( 0xff ) )\r\n\r\nconst NFCID3 = [ 0x01, 0xFE, 0x0F, 0xBB, 0xBA, 0xA6, 0xC9, 0x89, 0x00, 0x00 ]\r\n\r\nconst toHexString = arr => [].slice.call( arr )\r\n  .reduce( ( arr, v ) => {\r\n    const str = v.toString( 16 )\r\n      .toUpperCase()\r\n    arr.push( '0x' + ( str.length > 1 ? '' : '0' ) + str )\r\n    return arr\r\n  }, [] )\r\n  .join( ', ' )\r\n\r\nsetTimeout( () => {\r\n  Promise.resolve()\r\n    .then( () => {\r\n      ( function poll() {\r\n        const sector = 1\r\n        console.log( process.memory()\r\n          .free )\r\n        console.log( bus._busState.watching.length )\r\n        Promise.resolve()\r\n          .then( () => bus.findTargets( 2, 'A' ) )\r\n          .then( data => {\r\n            console.log( 'found target', data )\r\n            LED1.write( 1 )\r\n            return data\r\n          } )\r\n          .then( data => {\r\n            return bus.authenticate( sector * 4, data.uid, key )\r\n          } )\r\n          .then( data => {\r\n            console.log( 'auth', data )\r\n          } )\r\n          // .then( data => bus.writeBlock( 4, [ 1, 3, 6, 4 ] ) )\r\n          // .then( data => {\r\n          //   console.log( 'write op:', data )\r\n          // } )\r\n          .then( data => {\r\n            console.log( 'reading', sector, 'sector' );\r\n            return data\r\n          } )\r\n          .then( data => bus.readSector( sector ) )\r\n          .then( data => {\r\n            console.log( 'after init', data )\r\n            return data\r\n          } )\r\n          // .then( () => new Promise( ( done, fail ) => {\r\n          //   console.log( 'COMMAND InAutoPoll' )\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'ACK InAutoPoll' )\r\n          //     bus.expect( INFO, frame => {\r\n          //       let index = 7\r\n          //       // console.log( 'RESPONSE ( raw ) InAutoPoll', frame )\r\n          //       const data = {\r\n          //         count: frame[ index ],\r\n          //         targets: []\r\n          //       }\r\n          //       for ( let i = 0; i < data.count; i++ ) {\r\n          //         const type = frame[ ++index ]\r\n          //         const length = frame[ ++index ]\r\n          //\r\n          //         const targetRaw = frame.slice( ++index, index += length )\r\n          //\r\n          //         // console.log( 'targetRaw', targetRaw )\r\n          //\r\n          //         const targetData = {\r\n          //           type: type & 7,\r\n          //           br106A: ( type & 7 ) == 0,\r\n          //           br106B: ( type & 7 ) == 3,\r\n          //           br212: ( type & 7 ) == 1,\r\n          //           br424: ( type & 7 ) == 2,\r\n          //\r\n          //           mifareOrFelica: !!( type & 16 ),\r\n          //           isoCompilant: !!( type & 32 ),\r\n          //           dep: !!( type & 64 ),\r\n          //           active: !!( type & 128 )\r\n          //         }\r\n          //\r\n          //         if ( targetData.dep ) {\r\n          //           let offset = 0\r\n          //\r\n          //           if ( !targetData.active ) {\r\n          //             offset = parseDEP( targetRaw, targetData )\r\n          //           }\r\n          //\r\n          //           Object.assign( targetData, {\r\n          //             NFCID3t: targetRaw.slice( offset, offset + 10 ),\r\n          //             DIDt: frame[ offset + 10 ],\r\n          //             BSt: frame[ offset + 11 ],\r\n          //             BRt: frame[ offset + 12 ],\r\n          //             TO: frame[ offset + 13 ],\r\n          //             PPt: frame[ offset + 14 ],\r\n          //             Gt: targetRaw.slice( offset + 15, targetRaw.length )\r\n          //           } )\r\n          //         } else {\r\n          //           parseDEP( targetRaw, targetData )\r\n          //         }\r\n          //\r\n          //         data.targets.push( targetData )\r\n          //       }\r\n          //\r\n          //       console.log( 'RESPONSE InAutoPoll', data )\r\n          //\r\n          //       done( data )\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x60,\r\n          //     0xff, // poll n\r\n          //     0x01, // period = n * 150 ms\r\n          //     0x42, 0x82\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( found => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'initAsTarget ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       const data = {\r\n          //         mode: {\r\n          //           baudrate: ( frame[ 8 ] & 112 ) >> 4,\r\n          //           picc: !!( frame[ 8 ] & 15 ),\r\n          //           dep: !!( frame[ 8 ] & 4 ),\r\n          //           framingType: frame[ 8 ] & 3\r\n          //         },\r\n          //         initiatorCommand: frame.slice( 9, -2 )\r\n          //       }\r\n          //\r\n          //       console.log( 'initAsTarget RESPONSE', data )\r\n          //       console.log( 'initAsTarget COMMAND', toHexString( data.initiatorCommand ) )\r\n          //\r\n          //       done( data )\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   const c = command( [\r\n          //     0x8c,\r\n          //     1,\r\n          //\r\n          //     0x00, 0x00, //SENS_RES\r\n          //     ...NFCID3.slice( 0, 3 ), //NFCID1\r\n          //     0x40, //SEL_RES\r\n          //\r\n          //     0x01, 0xFE, 0x0F, 0xBB, 0xBA, 0xA6, 0xC9, 0x89, // POL_RES\r\n          //     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n          //     0xFF, 0xFF,\r\n          //\r\n          //     ...NFCID3,\r\n          //\r\n          //     13, // length gt\r\n          //\r\n          //     0x46, 0x66, 0x6d,\r\n          //     0x01, 0x01, 0x11,\r\n          //     0x03, 0x02, 0x00, 0x13,\r\n          //     0x04, 0x01, 0x96,\r\n          //\r\n          //     0 // Tk length\r\n          //   ] )\r\n          //\r\n          //   // console.log( c )\r\n          //\r\n          //   bus.send( c )\r\n          // } ) )\r\n          // .then( data => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'TgResponseToInitiator ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'TgResponseToInitiator RESPONSE', frame )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x90,\r\n          //     0x1f,\r\n          //     0xd5, 0x01,\r\n          //     ...NFCID3,\r\n          //     0,\r\n          //     0,\r\n          //     0,\r\n          //     0x0e,\r\n          //     0x32,\r\n          //\r\n          //     0x46, 0x66, 0x6D,\r\n          //     0x01, 0x01, 0x12,\r\n          //     0x03, 0x02, 0x00, 0x13,\r\n          //     0x04, 0x01, 0x64\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( data => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'TgGetInitiatorCommand ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'TgGetInitiatorCommand RESPONSE', toHexString( frame ) )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x88\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( data => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'TgResponseToInitiator ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'TgResponseToInitiator RESPONSE', toHexString( frame ) )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x90,\r\n          //     0x06,\r\n          //     0xd4, 0x06,\r\n          //     0x00,\r\n          //     0x00, 0x00\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( () => new Promise( ( done, fail ) => {\r\n          //   const nack = setTimeout( () => {\r\n          //     bus.send( ...ACK )\r\n          //     bus.unwatch()\r\n          //\r\n          //     fail( 'no answer for tgGetTargetStatus!' )\r\n          //   }, 1000 )\r\n          //\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'tgGetTargetStatus ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //       clearTimeout( nack )\r\n          //       bus.unwatch()\r\n          //       console.log( 'tgGetTargetStatus RESPONSE:' )\r\n          //       console.log( toHexString( frame ) )\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.send( command( [ 0x8a ] ) )\r\n          // } ) )\r\n          // .then( found => {\r\n          //   return found.targets[ 0 ]\r\n          // } )\r\n          // .then( target => new Promise( ( done, fail ) => {\r\n          //   console.log( 'requesting DEP exchange...' )\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'injumpfordep ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //       const data = {\r\n          //         code: frame[ 6 ],\r\n          //         status: frame[ 7 ],\r\n          //         targetNumber: frame[ 8 ],\r\n          //         NFCID3t: frame.slice( 9, 19 ),\r\n          //         DIDt: frame[ 19 ],\r\n          //         BSt: frame[ 20 ],\r\n          //         BRt: frame[ 21 ],\r\n          //         TO: frame[ 22 ],\r\n          //         PPt: frame[ 23 ],\r\n          //         Gt: frame.slice( 24, -2 )\r\n          //       }\r\n          //\r\n          //       console.log( 'injumpfordep RESPONSE', data )\r\n          //       console.log( 'general bytes:', toHexString( data.Gt ) )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       done( data )\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   let payload = [\r\n          //     0x56,\r\n          //     target.active ? 0x00 : 0x01, // active\r\n          //     target.baudrate\r\n          //   ]\r\n          //\r\n          //   if ( !target.active ) {\r\n          //     payload = [\r\n          //       ...payload,\r\n          //       6,\r\n          //\r\n          //       ...NFCID3,\r\n          //\r\n          //       // 0x25, // len,\r\n          //       // 0xd4, 0x00, // atr req\r\n          //       // 0x00,\r\n          //       // 0x00,\r\n          //       // 0x00,\r\n          //       // 0x32,\r\n          //\r\n          //       0x46, 0x66, 0x6D,\r\n          //       0x01, 0x01, 0x12,\r\n          //       0x02, 0x02, 0x07, 0x80, // TLV: MIUX = 128 + MIU 1920\r\n          //       0x03, 0x02, 0x00, 0x03, // TLV: Services\r\n          //       0x04, 0x01, 0x64,\r\n          //       0x07, 0x01, 0x03\r\n          //     ]\r\n          //   } else {\r\n          //     payload = [\r\n          //       ...payload,\r\n          //       1,\r\n          //\r\n          //       0x01, 0x02, 0x03, 0x04, 0x05\r\n          //     ]\r\n          //   }\r\n          //\r\n          //   console.log( payload )\r\n          //\r\n          //   bus.send( command( payload ) )\r\n          // } ) )\r\n          // .then( target => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'indataexchange ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'indataexchange RESPONSE', frame )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //       bus.unwatch()\r\n          //\r\n          //       done( target )\r\n          //\r\n          //       // if ( frame[ 7 ] == frame[ 8 ] == frame[ 9 ] == 0x00 ) {\r\n          //       //   console.log( 'SYMM received' )\r\n          //       //   done( target )\r\n          //       // } else {\r\n          //       //   console.log( 'SYMM does not received' )\r\n          //       //   fail()\r\n          //       // }\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x40,\r\n          //     // target.targetNumber,\r\n          //     0x06, // len\r\n          //     0xd4, 0x06, // dep_req\r\n          //     0x00, // PFB\r\n          //     0x00, 0x00 // SYMM PDU\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( target => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'indataexchange ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'indataexchange RESPONSE', frame )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //\r\n          //       if ( frame[ 7 ] == frame[ 8 ] == frame[ 9 ] == 0x00 ) {\r\n          //         console.log( 'SYMM_RES received' )\r\n          //         done( target )\r\n          //       } else {\r\n          //         console.log( 'SYMM_RES does not received' )\r\n          //         fail()\r\n          //       }\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x40,\r\n          //     target.targetNumber,\r\n          //     0x06, // len\r\n          //     0xd4, 0x06, // dep_req\r\n          //     0x01, // PFB\r\n          //     0x00, 0x00 // SYMM PDU\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( target => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'indataexchange ACK' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'indataexchange RESPONSE', frame )\r\n          //       console.log( 'CONNECT PDU' )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //\r\n          //       done( target )\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x40,\r\n          //     target.targetNumber,\r\n          //     0x1e, // len\r\n          //     0x04, 0x06, // DEP_RES\r\n          //     0x01, // info_pdu, pni 0\r\n          //     0x05, 0x20, // CONNECT PDU\r\n          //     0x06, // service name\r\n          //     0x0f, // len\r\n          //     ...[].slice.call( Buffer.from( 'urn:nfc:sn:snep' ) ),\r\n          //     0x02, 0x02, 0x07, 0x80, // TLV MIUX\r\n          //     0x05, 0x01, 0x04 // TLV RWS\r\n          //   ] ) )\r\n          // } ) )\r\n          // // .then( found => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'tgGetData ack' )\r\n          //     bus.expect( INFO, frame => {\r\n          //\r\n          //       console.log( 'tgGetData response', frame )\r\n          //\r\n          //       bus.send( ...ACK )\r\n          //\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x86\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then( data => bus.authenticate( 4, data.uid, key ) )\r\n          // .then( data => {\r\n          //   console.log( 'auth', data )\r\n          // } )\r\n          // .then( found => new Promise( ( done, fail ) => {\r\n          //   bus.expect( ACK, () => {\r\n          //     console.log( 'indataexchange ack' )\r\n          //     bus.expect( INFO, frame => {\r\n          //       console.log( 'indataexchange response', frame )\r\n          //       done()\r\n          //     } )\r\n          //   } )\r\n          //\r\n          //   bus.expect( ERR, fail )\r\n          //   bus.expect( NACK, fail )\r\n          //\r\n          //   bus.send( command( [\r\n          //     0x40,\r\n          //     1\r\n          //   ] ) )\r\n          // } ) )\r\n          // .then(data => { console.log('sector 2:', data); return data })\r\n          // .then( data => data.reduce( ( buffer, data ) => [ ...buffer, ...[].slice.call( data.chunk, 0 ) ], [] ) )\r\n          // .then( console.log )\r\n          // .then(data => { console.timeEnd('reading 2 sector'); return data })\r\n          // .then(data => bus.readBlock(4)).then(data => { console.log('block 4:', data) })\r\n          // .then(data => bus.readBlock(5)).then(data => { console.log('block 5:', data) })\r\n          // .then(data => bus.readBlock(6)).then(data => { console.log('block 6:', data) })\r\n          // .then(data => bus.readBlock(7)).then(data => { console.log('block 7:', data) })\r\n          .catch( err => {\r\n            console.error( 'Error:', err )\r\n          } )\r\n          .then( () => {\r\n            LED1.write( 0 )\r\n            LED2.write( 0 )\r\n\r\n            bus.send( ...ACK )\r\n            bus.unwatch()\r\n\r\n            setTimeout( () => {\r\n              poll()\r\n            }, 500 )\r\n          } )\r\n      } )()\r\n    } )\r\n    .catch( console.error )\r\n}, 1000 )\r\n"],"names":["Buffer","Error","EventEmitter","_listeners","_duplicateEvent","event","this","BufferState","options","assign","_resetWatcher","watcher","Object","_resetActive","_busState","active","emit","_decrementActive","_nextPattern","patternIndex","list","length","nextPattern","byteIndex","currentPattern","call","slice","err","watching","chunk","buffer","nodeIndex","callback","forEach","_Bus","transport","type","_setup","setup","bind","_read","read","undefined","_this2","highWaterMark","_write","write","DEFAULT_HIGHWATERMARK","console","time","timers","label","Date","now","timeEnd","log","toFixed","error","concat","concatenated","i","push","arguments","j","Promise","race","promises","Array","TypeError","resolve","reject","promise","then","ArrayBuffer","isView","value","from","iterable","offset","parsed","c","charCodeAt","Uint8Array","_list","_totalLength","totalLength","reduce","array","buf","set","target","args","obj","key","_defProp","defineProperty","prop","descriptor","e","get","defineProperties","descriptors","ON","OFF","process","env","CHIP","toUpperCase","once","led","timeout","cb","_copyChain","Extended","ProtoChain","chainPropName","ignoreExtended","prototype","isExtended","Proto","PROTOTYPE_IS_EXTENDED_PROP","hasSameChain","alreadyInChain","some","P","shouldBePushed","_extend","SUPER_CHAIN_APPLY_PROP","Super","apply","proto","Child","name","f","SUPER_CHAIN_PROTO_PROP","indexOf","loop","queue","immediatePush","tick","asyncFlush","stage","exec","splice","asyncCall","setImmediate","listener","on","removeListener","_listener","node","_buffer","next","unshift","count","nodes","_this","index","to","callee","firstNode","lastNode","at","configured","ticker","currentChunkIndex","watcherIndex","isEqual","byte","isArray","expected","ReferenceError","_this4","watch","unwatch","binary","Bus","check","values","sum","CHECKSUM","frame","INFO","PN532_PREAMBLE","PN532_STARTCODE1","PN532_STARTCODE2","ERR","ACK","NACK","command","PN532_HOST_TO_PN532","checksum","parseInfo","parseBlockData","data","body","code","cmd","info","parsers","done","fail","expect","parse","send","catch","makeTransaction","uid","block","PN532_COMMAND_INDATAEXCHANGE","MIFARE_COMMAND_AUTH_A","MIFARE_COMMAND_WRITE_16","sector","readBlocksArr","arr","aborted","res","readBlock","start","bus","Serial1","LED1","Blink","msg","readFrom","writeTo","fill","setTimeout","poll","memory","free","findTargets","authenticate","readSector"],"mappings":"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"}